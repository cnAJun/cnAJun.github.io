{"meta":{"title":"阿俊的博客","subtitle":"每天成长一点点","description":"iOS and Java Developer","author":"iOS阿俊","url":"github.com:ChinaArJun/ChinaArJun.github.io.git"},"pages":[{"title":"关于","date":"2018-11-29T14:33:06.000Z","updated":"2018-11-29T14:34:53.221Z","comments":true,"path":"about/index.html","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/about/index.html","excerpt":"","text":"AJiOS and Java Developer GitHub: https://github.com/ChinaArJun"},{"title":"categories","date":"2018-11-22T02:22:00.000Z","updated":"2018-11-29T14:30:57.003Z","comments":false,"path":"categories/index.html","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-29T14:27:03.000Z","updated":"2018-11-29T14:27:26.252Z","comments":true,"path":"tags/index.html","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java基础巩固之注解(8)","slug":"java基础巩固之注解-8","date":"2018-12-03T03:20:36.000Z","updated":"2018-12-03T03:20:56.866Z","comments":true,"path":"2018/12/03/java基础巩固之注解-8/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/12/03/java基础巩固之注解-8/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"java基础巩固之注解(7)","slug":"java基础巩固之注解-7","date":"2018-12-03T03:20:08.000Z","updated":"2018-12-03T03:20:08.540Z","comments":true,"path":"2018/12/03/java基础巩固之注解-7/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/12/03/java基础巩固之注解-7/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"java 历史版本新特性","slug":"Java基础巩固之设计模式-4","date":"2014-12-27T16:19:00.000Z","updated":"2018-12-02T17:30:52.496Z","comments":true,"path":"2014/12/28/Java基础巩固之设计模式-4/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/28/Java基础巩固之设计模式-4/","excerpt":"JDK5新特性-自己实现枚举类 A:枚举概述 是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内。举例：一周只有7天，一年只有12个月等。 B:回想单例设计模式：单例类是一个类只有一个实例 那么多例类就是一个类有多个实例，但不是无限个数的实例，而是有限个数的实例。这才能是枚举类。","text":"JDK5新特性-自己实现枚举类 A:枚举概述 是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内。举例：一周只有7天，一年只有12个月等。 B:回想单例设计模式：单例类是一个类只有一个实例 那么多例类就是一个类有多个实例，但不是无限个数的实例，而是有限个数的实例。这才能是枚举类。 C:案例演示 自己实现枚举类1,自动拆装箱2,泛型3,可变参数4,静态导入5,增强for循环6,互斥锁7,枚举 JDK5新特性-通过enum实现枚举类 A:案例演示 通过enum实现枚举类 JDK5新特性-枚举的注意事项 A:案例演示 定义枚举类要用关键字enum 所有枚举类都是Enum的子类 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略 枚举类可以有构造器，但必须是private的，它默认的也是private的。 枚举类也可以有抽象方法，但是枚举项必须重写该方法 枚举在switch语句中的使用 JDK5新特性-枚举类的常见方法 A:枚举类的常见方法 int ordinal() int compareTo(E o) String name() String toString() T valueOf(Class type,String name) values() 此方法虽然在JDK文档中查找不到，但每个枚举类都具有该方法，它遍历枚举类的所有枚举值非常方便 B:案例演示 枚举类的常见方法 JDK7新特性-JDK7的六个新特性回顾和讲解 A:二进制字面量 B:数字字面量可以出现下划线 C:switch 语句可以用字符串 D:泛型简化,菱形泛型 E:异常的多个catch合并,每个异常用或| F:try-with-resources 语句 JDK8新特性-JDK8的新特性 接口中可以定义有方法体的方法,如果是非静态,必须用default修饰 如果是静态的就不用了 1234567891011121314class Test &#123; public void run() &#123; final int x = 10; class Inner &#123; public void method() &#123; System.out.println(x); &#125; &#125; Inner i = new Inner(); i.method(); &#125; &#125; 局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么? 因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}],"tags":[{"name":"JDK","slug":"JDK","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/tags/JDK/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}]},{"title":"java基础巩固之多线程线程通信(6)","slug":"java基础巩固之多线程并发编程-6","date":"2014-12-06T16:58:00.000Z","updated":"2018-12-02T17:28:51.038Z","comments":true,"path":"2014/12/07/java基础巩固之多线程并发编程-6/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/07/java基础巩固之多线程并发编程-6/","excerpt":"多线程-单例 单例设计模式：保证类在内存中只有一个对象。 如何保证类在内存中只有一个对象呢？ (1)控制类的创建，不让其他类来创建本类的对象。private (2)在本类中定义一个本类的对象。Singleton s; (3)提供公共的访问方式。 public static Singleton getInstance(){return s}","text":"多线程-单例 单例设计模式：保证类在内存中只有一个对象。 如何保证类在内存中只有一个对象呢？ (1)控制类的创建，不让其他类来创建本类的对象。private (2)在本类中定义一个本类的对象。Singleton s; (3)提供公共的访问方式。 public static Singleton getInstance(){return s} 单例写法两种： (1)饿汉式 开发用这种方式。 123456789101112131415//饿汉式class Singleton &#123; //1,私有构造函数 private Singleton()&#123;&#125; //2,创建本类对象 private static Singleton s = new Singleton(); //3,对外提供公共的访问方法 public static Singleton getInstance() &#123; return s; &#125; public static void print() &#123; System.out.println(\"11111111111\"); &#125;&#125; (2)懒汉式 面试写这种方式。多线程的问题？ 123456789101112131415161718//懒汉式,单例的延迟加载模式class Singleton &#123; //1,私有构造函数 private Singleton()&#123;&#125; //2,声明一个本类的引用 private static Singleton s; //3,对外提供公共的访问方法 public static Singleton getInstance() &#123; if(s == null) //线程1,线程2 s = new Singleton(); return s; &#125; public static void print() &#123; System.out.println(\"11111111111\"); &#125;&#125; (3)第三种格式 12345class Singleton &#123; private Singleton() &#123;&#125; public static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改&#125; 多线程-Runtime类 Runtime类是一个单例类 123Runtime r = Runtime.getRuntime();//r.exec(\"shutdown -s -t 300\"); //300秒后关机r.exec(\"shutdown -a\"); //取消关机 多线程-Timer Timer类:计时器 1234567891011121314151617181920212223public class Demo5_Timer &#123; /** * @param args * 计时器 * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; Timer t = new Timer(); t.schedule(new MyTimerTask(), new Date(114,9,15,10,54,20),3000); while(true) &#123; System.out.println(new Date()); Thread.sleep(1000); &#125; &#125;&#125;class MyTimerTask extends TimerTask &#123; @Override public void run() &#123; System.out.println(\"起床背英语单词\"); &#125; &#125; 多线程-两个线程间的通信 1.什么时候需要通信 多个线程并发执行时, 在默认情况下CPU是随机切换线程的 如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印 2.怎么通信 如果希望线程等待, 就调用wait() 如果希望唤醒等待的线程, 就调用notify(); 这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用 多线程-三个或三个以上间的线程通信 多个线程通信的问题 notify()方法是随机唤醒一个线程 notifyAll()方法是唤醒所有线程 JDK5之前无法唤醒指定的一个线程 如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件多线程-JDK1.5的新特性互斥锁 1.同步 使用ReentrantLock类的lock()和unlock()方法进行同步 2.通信 使用ReentrantLock类的newCondition()方法可以获取Condition对象 需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法 不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了 多线程-线程组的概述和使用 A:线程组概述 Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。 默认情况下，所有的线程都属于主线程组。 public final ThreadGroup getThreadGroup()//通过线程对象获取他所属于的组 public final String getName()//通过线程组对象获取他组的名字 我们也可以给线程设置分组 1,ThreadGroup(String name) 创建线程组对象并给其赋值名字 2,创建线程对象 3,Thread(ThreadGroup?group, Runnable?target, String?name) 4,设置整组的优先级或者守护线程 B:案例演示 线程组的使用,默认是主线程组 12345678910111213141516171819202122232425262728293031 MyRunnable mr = new MyRunnable(); Thread t1 = new Thread(mr, \"张三\"); Thread t2 = new Thread(mr, \"李四\"); //获取线程组 // 线程类里面的方法：public final ThreadGroup getThreadGroup() ThreadGroup tg1 = t1.getThreadGroup(); ThreadGroup tg2 = t2.getThreadGroup(); // 线程组里面的方法：public final String getName() String name1 = tg1.getName(); String name2 = tg2.getName(); System.out.println(name1); System.out.println(name2); // 通过结果我们知道了：线程默认情况下属于main线程组 // 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组 System.out.println(Thread.currentThread().getThreadGroup().getName()); * 自己设定线程组* // ThreadGroup(String name) ThreadGroup tg = new ThreadGroup(\"这是一个新的组\"); MyRunnable mr = new MyRunnable(); // Thread(ThreadGroup group, Runnable target, String name) Thread t1 = new Thread(tg, mr, \"张三\"); Thread t2 = new Thread(tg, mr, \"李四\"); System.out.println(t1.getThreadGroup().getName()); System.out.println(t2.getThreadGroup().getName()); //通过组名称设置后台线程，表示该组的线程都是后台线程 tg.setDaemon(true); 多线程-线程的五种状态 看图说话 新建,就绪,运行,阻塞,死亡 多线程-线程池的概述和使用 A:线程池概述 程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池 B:内置线程池的使用概述 JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法 public static ExecutorService newFixedThreadPool(int nThreads) public static ExecutorService newSingleThreadExecutor() 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法 Future&lt;?&gt; submit(Runnable task) Future submit(Callable task) 使用步骤： 创建线程池对象 创建Runnable实例 提交Runnable实例 关闭线程池 C:案例演示 提交的是Runnable 123456789// public static ExecutorService newFixedThreadPool(int nThreads)ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程pool.submit(new MyRunnable());pool.submit(new MyRunnable());//结束线程池pool.shutdown(); 多线程-多线程程序实现的方式3 提交的是Callable 1234567891011121314151617181920212223242526272829303132333435// 创建线程池对象ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程Future&lt;Integer&gt; f1 = pool.submit(new MyCallable(100));Future&lt;Integer&gt; f2 = pool.submit(new MyCallable(200));// V get()Integer i1 = f1.get();Integer i2 = f2.get();System.out.println(i1);System.out.println(i2);// 结束pool.shutdown();public class MyCallable implements Callable&lt;Integer&gt; &#123; private int number; public MyCallable(int number) &#123; this.number = number; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int x = 1; x &lt;= number; x++) &#123; sum += x; &#125; return sum; &#125;&#125; 多线程程序实现的方式3的好处和弊端 好处： 可以有返回值 可以抛出异常 弊端： 代码比较复杂，所以一般不用 ###25.11_设计模式(简单工厂模式概述和使用)(了解) A:简单工厂模式概述 又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例 B:优点 客户端不需要在负责对象的创建，从而明确了各个类的职责 C:缺点 这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护 D:案例演示 动物抽象类：public abstract Animal { public abstract void eat(); } 具体狗类：public class Dog extends Animal {} 具体猫类：public class Cat extends Animal {} 开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。 12345678910111213141516public class AnimalFactory &#123; private AnimalFactory()&#123;&#125; //public static Dog createDog() &#123;return new Dog();&#125; //public static Cat createCat() &#123;return new Cat();&#125; //改进 public static Animal createAnimal(String animalName) &#123; if(“dog”.equals(animalName)) &#123;&#125; else if(“cat”.equals(animale)) &#123; &#125;else &#123; return null; &#125; &#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/tags/多线程/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}]},{"title":"java基础巩固之多线程安全(5)","slug":"java基础巩固之多线程安全-4","date":"2014-12-04T16:44:00.000Z","updated":"2018-12-02T17:28:43.342Z","comments":true,"path":"2014/12/05/java基础巩固之多线程安全-4/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/05/java基础巩固之多线程安全-4/","excerpt":"多线程-同步代码块 1.什么情况下需要同步 当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步. 如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码. 2.同步代码块 使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块 多个同步代码块如果使用相同的锁对象, 那么他们就是同步的","text":"多线程-同步代码块 1.什么情况下需要同步 当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步. 如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码. 2.同步代码块 使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块 多个同步代码块如果使用相同的锁对象, 那么他们就是同步的 123456789101112131415class Printer &#123; Demo d = new Demo(); public static void print1() &#123; synchronized(d)&#123; //锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象 System.out.print(\"\\r\\n\"); &#125; &#125; public static void print2() &#123; synchronized(d)&#123; System.out.print(\"\\r\\n\"); &#125; &#125;&#125; 多线程-同步方法 使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的 1234567891011121314151617181920212223class Printer &#123; public static void print1() &#123; synchronized(Printer.class)&#123; //锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象 System.out.print(\"黑\"); System.out.print(\"马\"); System.out.print(\"程\"); System.out.print(\"序\"); System.out.print(\"员\"); System.out.print(\"\\r\\n\"); &#125; &#125; /* * 非静态同步函数的锁是:this * 静态的同步函数的锁是:字节码对象 */ public static synchronized void print2() &#123; System.out.print(\"传\"); System.out.print(\"智\"); System.out.print(\"播\"); System.out.print(\"客\"); System.out.print(\"\\r\\n\"); &#125;&#125; 多线程-线程安全问题 多线程并发操作同一数据时, 就有可能出现线程安全问题 使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Demo2_Synchronized &#123; /** * @param args * 需求:铁路售票,一共100张,通过四个窗口卖完. */ public static void main(String[] args) &#123; TicketsSeller t1 = new TicketsSeller(); TicketsSeller t2 = new TicketsSeller(); TicketsSeller t3 = new TicketsSeller(); TicketsSeller t4 = new TicketsSeller(); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t4.setName(\"窗口4\"); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125;class TicketsSeller extends Thread &#123; private static int tickets = 100; static Object obj = new Object(); public TicketsSeller() &#123; super(); &#125; public TicketsSeller(String name) &#123; super(name); &#125; public void run() &#123; while(true) &#123; synchronized(obj) &#123; if(tickets &lt;= 0) break; try &#123; Thread.sleep(10);//线程1睡,线程2睡,线程3睡,线程4睡 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + \"...这是第\" + tickets-- + \"号票\"); &#125; &#125; &#125;&#125; 多线程-死锁 多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁 尽量不要嵌套使用 1234567891011121314151617181920212223242526272829private static String s1 = \"筷子左\";private static String s2 = \"筷子右\";public static void main(String[] args) &#123; new Thread() &#123; public void run() &#123; while(true) &#123; synchronized(s1) &#123; System.out.println(getName() + \"...拿到\" + s1 + \"等待\" + s2); synchronized(s2) &#123; System.out.println(getName() + \"...拿到\" + s2 + \"开吃\"); &#125; &#125; &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while(true) &#123; synchronized(s2) &#123; System.out.println(getName() + \"...拿到\" + s2 + \"等待\" + s1); synchronized(s1) &#123; System.out.println(getName() + \"...拿到\" + s1 + \"开吃\"); &#125; &#125; &#125; &#125; &#125;.start();&#125; 多线程-以前的线程安全的类回顾 A:回顾以前说过的线程安全问题 看源码：Vector,StringBuffer,Hashtable,Collections.synchroinzed(xxx) Vector是线程安全的,ArrayList是线程不安全的 StringBuffer是线程安全的,StringBuilder是线程不安全的 Hashtable是线程安全的,HashMap是线程不安全的","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}],"tags":[],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}]},{"title":"java基础巩固之多线程概念和应用(4)","slug":"java基础笔记-4-多线程","date":"2014-12-03T16:30:00.000Z","updated":"2018-12-02T17:28:31.923Z","comments":true,"path":"2014/12/04/java基础笔记-4-多线程/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/04/java基础笔记-4-多线程/","excerpt":"多线程-多线程的引入 1.什么是线程 线程是程序执行的一条路径, 一个进程中可以包含多条线程 多线程并发执行可以提高程序的效率, 可以同时完成多项工作 2.多线程的应用场景 红蜘蛛同时共享屏幕给多个电脑 迅雷开启多条线程一起下载 QQ同时和多个人一起视频 服务器同时处理多个客户端请求","text":"多线程-多线程的引入 1.什么是线程 线程是程序执行的一条路径, 一个进程中可以包含多条线程 多线程并发执行可以提高程序的效率, 可以同时完成多项工作 2.多线程的应用场景 红蜘蛛同时共享屏幕给多个电脑 迅雷开启多条线程一起下载 QQ同时和多个人一起视频 服务器同时处理多个客户端请求 多线程-多线程并行和并发的区别 并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU) 并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。 比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。 如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。 多线程-Java程序运行原理和JVM的启动是多线程的吗 A:Java程序运行原理 Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。 B:JVM的启动是多线程的吗 JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。 多线程-多线程程序实现的方式1 1.继承Thread 定义类继承Thread 重写run方法 把新线程要做的事写在run方法中 创建线程对象 开启新线程, 内部会自动执行run方法 1234567891011121314151617181920212223public class Demo2_Thread &#123; /** * @param args */ public static void main(String[] args) &#123; MyThread mt = new MyThread(); // 4,创建自定义类的对象 mt.start(); // 5,开启线程 for (int i = 0; i &lt; 3000; i++) &#123; System.out.println(\"bb\"); &#125; &#125;&#125;class MyThread extends Thread &#123; // 1,定义类继承Thread public void run() &#123; // 2,重写run方法 for (int i = 0; i &lt; 3000; i++) &#123; // 3,将要执行的代码,写在run方法中 System.out.println(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125;&#125; 多线程-多线程程序实现的方式2 2.实现Runnable 定义类实现Runnable接口 实现run方法 把新线程要做的事写在run方法中 创建自定义的Runnable的子类对象 创建Thread对象, 传入Runnable 调用start()开启新线程, 内部会自动调用Runnable的run()方法 12345678910111213141516171819202122232425public class Demo3_Runnable &#123; /** * @param args */ public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); // 4,创建自定义类对象 // Runnable target = new MyRunnable(); Thread t = new Thread(mr); // 5,将其当作参数传递给Thread的构造函数 t.start(); // 6,开启线程 for (int i = 0; i &lt; 3000; i++) &#123; System.out.println(\"bb\"); &#125; &#125;&#125;class MyRunnable implements Runnable &#123; // 1,自定义类实现Runnable接口 @Override public void run() &#123; // 2,重写run方法 for (int i = 0; i &lt; 3000; i++) &#123; // 3,将要执行的代码,写在run方法中 System.out.println(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125;&#125; 多线程-实现Runnable的原理 查看源码 1,看Thread类的构造函数,传递了Runnable接口的引用 2,通过init()方法找到传递的target给成员变量的target赋值 3,查看run方法,发现run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法 多线程-两种方式的区别 查看源码的区别: a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法 b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法 继承Thread 好处是:可以直接使用Thread类中的方法,代码简单 弊端是:如果已经有了父类,就不能用这种方法 实现Runnable接口 好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的 弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂多线程-匿名内部类实现线程的两种方式 继承Thread类 1234567891011121314151617public static void main(String[] args) &#123; new Thread() &#123; // 1,new 类()&#123;&#125;继承这个类 public void run() &#123; // 2,重写run方法 for (int i = 0; i &lt; 3000; i++) &#123; // 3,将要执行的代码,写在run方法中 System.out.println(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125; &#125;.start(); // 实现Runnable接口 new Thread(new Runnable() &#123; // 1,new 接口()&#123;&#125;实现这个接口 public void run() &#123; // 2,重写run方法 for (int i = 0; i &lt; 3000; i++) &#123; // 3,将要执行的代码,写在run方法中 System.out.println(\"bb\"); &#125; &#125; &#125;).start();&#125; 多线程-获取名字和设置名字 1.获取名字 通过getName()方法获取线程对象的名字 2.设置名字 通过构造函数可以传入String类型的名字 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Test &#123; public static void main(String[] args) &#123; new Thread(\"xxx\") &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + \"....aaaaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125; &#125;.start(); new Thread(\"yyy\") &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + \"....bb\"); &#125; &#125; &#125;.start(); /* * 通过setName(String)方法可以设置线程对象的名字 */ Thread t1 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + \"....aaaaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + \"....bb\"); &#125; &#125; &#125;; t1.setName(\"芙蓉姐姐\"); t2.setName(\"凤姐\"); t1.start(); t2.start(); &#125;&#125; 多线程-获取当前线程的对象 Thread.currentThread(), 主线程也可以获取 1234567891011121314151617new Thread(new Runnable() &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + \"...aaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125;&#125;).start();new Thread(new Runnable() &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + \"...bb\"); &#125; &#125;&#125;).start();Thread.currentThread().setName(\"我是主线程\"); //获取主函数线程的引用,并改名字System.out.println(Thread.currentThread().getName()); //获取主函数线程的引用,并获取名字 多线程-休眠线程 Thread.sleep(毫秒,纳秒), 控制当前线程休眠若干毫秒1秒= 1000毫秒 1秒 = 1000 1000 1000纳秒 1000000000 12345678910111213141516171819202122232425new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + \"...aaaaaaaaaaaaaaaaaaaaaa\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;.start();new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + \"...bb\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;.start(); 多线程-守护线程 setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Thread t1 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 50; i++) &#123; System.out.println(getName() + \"...aaaaaaaaaaaaaaaaaaaaaa\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 5; i++) &#123; System.out.println(getName() + \"...bb\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; t1.setDaemon(true); //将t1设置为守护线程 t1.start(); t2.start();### 多线程-加入线程* join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续* join(int), 可以等待指定的毫秒之后继续 * final Thread t1 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 50; i++) &#123; System.out.println(getName() + \"...aaaaaaaaaaaaaaaaaaaaaa\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 50; i++) &#123; if(i == 2) &#123; try &#123; //t1.join(); //插队,加入 t1.join(30); //加入,有固定的时间,过了固定时间,继续交替执行 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(getName() + \"...bb\"); &#125; &#125; &#125;; t1.start(); t2.start(); 多线程-礼让线程 yield让出cpu 多线程-设置线程的优先级 setPriority()设置线程的优先级","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/tags/多线程/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}]},{"title":"java基础巩固之设计模式(3)","slug":"Java基础巩固之设计模式-3","date":"2014-12-03T15:59:00.000Z","updated":"2018-12-02T17:29:03.604Z","comments":true,"path":"2014/12/03/Java基础巩固之设计模式-3/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/03/Java基础巩固之设计模式-3/","excerpt":"设计模式-模版(Template)设计模式概述和使用 A:模版设计模式概述 模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现 B:优点和缺点 a:优点 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求 b:缺点 如果算法骨架有修改的话，则需要修改抽象类","text":"设计模式-模版(Template)设计模式概述和使用 A:模版设计模式概述 模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现 B:优点和缺点 a:优点 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求 b:缺点 如果算法骨架有修改的话，则需要修改抽象类 1,装饰2,单例 多线程-单例 单例设计模式：保证类在内存中只有一个对象。 如何保证类在内存中只有一个对象呢？ (1)控制类的创建，不让其他类来创建本类的对象。private (2)在本类中定义一个本类的对象。Singleton s; (3)提供公共的访问方式。 public static Singleton getInstance(){return s} 单例写法两种： (1)饿汉式 开发用这种方式。 123456789101112131415//饿汉式class Singleton &#123; //1,私有构造函数 private Singleton()&#123;&#125; //2,创建本类对象 private static Singleton s = new Singleton(); //3,对外提供公共的访问方法 public static Singleton getInstance() &#123; return s; &#125; public static void print() &#123; System.out.println(\"11111111111\"); &#125;&#125; (2)懒汉式 面试写这种方式。多线程的问题？ 123456789101112131415161718//懒汉式,单例的延迟加载模式class Singleton &#123; //1,私有构造函数 private Singleton()&#123;&#125; //2,声明一个本类的引用 private static Singleton s; //3,对外提供公共的访问方法 public static Singleton getInstance() &#123; if(s == null) //线程1,线程2 s = new Singleton(); return s; &#125; public static void print() &#123; System.out.println(\"11111111111\"); &#125;&#125; (3)第三种格式1234567891011 class Singleton &#123; private Singleton() &#123;&#125; public static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改 &#125;###25.02_多线程(Runtime类)* Runtime类是一个单例类 * Runtime r = Runtime.getRuntime(); //r.exec(\"shutdown -s -t 300\"); //300秒后关机 r.exec(\"shutdown -a\"); //取消关机 3,简单工厂4,工厂方法 设计模式-工厂方法模式的概述和使用 A:工厂方法模式概述 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。 B:优点 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性 C:缺点 需要额外的编写代码，增加了工作量 D:案例演示 动物抽象类：public abstract Animal { public abstract void eat(); } 工厂接口：public interface Factory {public abstract Animal createAnimal();} 具体狗类：public class Dog extends Animal {} 具体猫类：public class Cat extends Animal {} 开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。 狗工厂：public class DogFactory implements Factory { public Animal createAnimal() {…} } 猫工厂：public class CatFactory implements Factory { public Animal createAnimal() {…} } 5,适配器6,模版","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/tags/JAVA/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}]},{"title":"java基础巩固之动态代理(2)","slug":"Java基础巩固之动态代理-2","date":"2014-12-03T15:53:00.000Z","updated":"2018-12-03T03:29:38.351Z","comments":true,"path":"2014/12/03/Java基础巩固之动态代理-2/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/03/Java基础巩固之动态代理-2/","excerpt":"1.代理模式代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法 举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子","text":"1.代理模式代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法 举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/tags/JAVA/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}]},{"title":"java基础巩固之反射(1)","slug":"Untitled","date":"2014-12-02T15:20:00.000Z","updated":"2018-12-03T02:37:24.699Z","comments":true,"path":"2014/12/02/Untitled/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/02/Untitled/","excerpt":"反射-类的加载概述和加载时机 A:类的加载概述 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。 加载 就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。 连接 验证 是否有正确的内部结构，并和其他类协调一致 准备 负责为类的静态成员分配内存，并设置默认初始化值 解析 将类的二进制数据中的符号引用替换为直接引用 初始化 就是我们以前讲过的初始化步骤","text":"反射-类的加载概述和加载时机 A:类的加载概述 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。 加载 就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。 连接 验证 是否有正确的内部结构，并和其他类协调一致 准备 负责为类的静态成员分配内存，并设置默认初始化值 解析 将类的二进制数据中的符号引用替换为直接引用 初始化 就是我们以前讲过的初始化步骤 B:加载时机 创建类的实例 访问类的静态变量，或者为静态变量赋值 调用类的静态方法 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 ###27.02_反射(类加载器的概述和分类) A:类加载器的概述 负责将.class文件加载到内存中，并为之生成对应的Class对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。 B:类加载器的分类 Bootstrap ClassLoader 根类加载器 Extension ClassLoader 扩展类加载器 Sysetm ClassLoader 系统类加载器 C:类加载器的作用 Bootstrap ClassLoader 根类加载器 也被称为引导类加载器，负责Java核心类的加载 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中 Extension ClassLoader 扩展类加载器 负责JRE的扩展目录中jar包的加载。 在JDK中JRE的lib目录下ext目录 Sysetm ClassLoader 系统类加载器 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径 ###27.03_反射(反射概述) A:反射概述 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性； 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 要想解剖一个类,必须先要获取到该类的字节码文件对象。 而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。 B:三种方式 a:Object类的getClass()方法,判断两个对象是否是同一个字节码文件 b:静态属性class,锁对象 c:Class类中静态方法forName(),读取配置文件 C:案例演示 获取class文件对象的三种方式 反射-Class.forName()读取配置文件举例 榨汁机(Juicer)榨汁的案例 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze) 1234567891011121314151617181920212223242526272829303132333435363738394041public class Demo2_Reflect &#123; /** * 榨汁机(Juicer)榨汁的案例 * 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze) * @throws Exception */ public static void main(String[] args) throws Exception &#123; /*Juicer j = new Juicer(); //j.run(new Apple()); j.run(new Orange());*/ BufferedReader br = new BufferedReader(new FileReader(\"config.properties\")); //创建输入流对象,关联配置文件 Class&lt;?&gt; clazz = Class.forName(br.readLine()); //读取配置文件一行内容,获取该类的字节码对象 Fruit f = (Fruit) clazz.newInstance(); //通过字节码对象创建实例对象 Juicer j = new Juicer(); j.run(f); &#125;&#125;interface Fruit &#123; public void squeeze();&#125;class Apple implements Fruit &#123; public void squeeze() &#123; System.out.println(\"榨出一杯苹果汁儿\"); &#125;&#125;class Orange implements Fruit &#123; public void squeeze() &#123; System.out.println(\"榨出一杯桔子汁儿\"); &#125;&#125;class Juicer &#123; public void run(Fruit f) &#123; f.squeeze(); &#125;&#125; 反射-通过反射获取带参构造方法并使用 Constructor Class类的newInstance()方法是使用该类无参的构造函数创建对象, 如果一个类没有无参的构造函数, 就不能这样创建了,可以调用Class类的getConstructor(String.class,int.class)方法获取一个指定的构造函数然后再调用Constructor类的newInstance(“张三”,20)方法创建对象 反射-通过反射获取成员变量并使用 Field Class.getField(String)方法可以获取类中的指定字段(可见的), 如果是私有的可以用getDeclaedField(“name”)方法获取,通过set(obj, “李四”)方法可以设置指定对象上该字段的值, 如果是私有的需要先调用setAccessible(true)设置访问权限,用获取的指定的字段调用get(obj)可以获取指定对象中该字段的值 反射-通过反射获取方法并使用 Method Class.getMethod(String, Class…) 和 Class.getDeclaredMethod(String, Class…)方法可以获取类中的指定方法,调用invoke(Object, Object…)可以调用该方法,Class.getMethod(“eat”) invoke(obj) Class.getMethod(“eat”,int.class) invoke(obj,10) 反射-通过反射越过泛型检查 A:案例演示 ArrayList的一个对象，在这个集合中添加一个字符串数据，如何实现呢？ 反射-通过反射写一个通用的设置某个对象的某个属性为指定的值 public void setProperty(Object obj, String propertyName, Object value){}，此方法可将obj对象中名为propertyName的属性的值设置为value。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/tags/JAVA/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/编程语言/"}]}]}