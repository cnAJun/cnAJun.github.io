{"meta":{"title":"阿俊的博客","subtitle":"每天成长一点点","description":"iOS and Java Developer","author":"阿俊","url":"github.com:cnAJun/cnAJun.github.io"},"pages":[{"title":"categories","date":"2018-11-22T02:22:00.000Z","updated":"2018-11-29T14:30:57.000Z","comments":false,"path":"categories/index.html","permalink":"github.com:cnAJun/cnAJun.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-11-29T14:33:06.000Z","updated":"2018-11-29T14:34:53.000Z","comments":true,"path":"about/index.html","permalink":"github.com:cnAJun/cnAJun.github.io/about/index.html","excerpt":"","text":"AJiOS and Java Developer GitHub: https://github.com/ChinaArJun"},{"title":"tags","date":"2018-11-29T14:27:03.000Z","updated":"2018-11-29T14:27:26.000Z","comments":true,"path":"tags/index.html","permalink":"github.com:cnAJun/cnAJun.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring基础(1)","slug":"Spring基础","date":"2018-12-04T16:23:52.000Z","updated":"2018-12-05T08:52:49.000Z","comments":true,"path":"2018/12/05/Spring基础/","link":"","permalink":"github.com:cnAJun/cnAJun.github.io/2018/12/05/Spring基础/","excerpt":"","text":"第一章 Spring简史第一阶段：XML配置 在Spring1.x时代，都是使用XML配置Bean，随着项目扩大，我们把XML文件切分成多个配置文件，那时候需要频繁地在开发类和配置文件之间切换 第二阶段：注解配置 在Spring2.x时代，随着JDK1.5带来的注解支持，Spring提供了声明Bean的注解（如@Service等），大大减少了配置量。这时Spring圈子里存在一种争论：注解配置和XML配置究竟哪个更好？我们最终的选择是应用的基本配置用XML，业务配置用注解。 第三阶段：Java配置 从Spring3.x开始，Spring提供了JAVA配置的能力。Spring4.x信Spring Boot都推荐使用JAVA配置。使用JAVA配置可以让你更理解你所配置的Bean。","categories":[],"tags":[],"keywords":[]},{"title":"java基础巩固之注解(7)","slug":"java基础巩固之注解-7","date":"2018-12-03T03:20:08.000Z","updated":"2018-12-03T03:20:08.000Z","comments":true,"path":"2018/12/03/java基础巩固之注解-7/","link":"","permalink":"github.com:cnAJun/cnAJun.github.io/2018/12/03/java基础巩固之注解-7/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"java 历史版本新特性","slug":"Java基础巩固之设计模式-4","date":"2014-12-27T16:19:00.000Z","updated":"2018-12-02T17:30:52.000Z","comments":true,"path":"2014/12/28/Java基础巩固之设计模式-4/","link":"","permalink":"github.com:cnAJun/cnAJun.github.io/2014/12/28/Java基础巩固之设计模式-4/","excerpt":"JDK5新特性-自己实现枚举类 A:枚举概述 是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内。举例：一周只有7天，一年只有12个月等。 B:回想单例设计模式：单例类是一个类只有一个实例 那么多例类就是一个类有多个实例，但不是无限个数的实例，而是有限个数的实例。这才能是枚举类。","text":"JDK5新特性-自己实现枚举类 A:枚举概述 是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内。举例：一周只有7天，一年只有12个月等。 B:回想单例设计模式：单例类是一个类只有一个实例 那么多例类就是一个类有多个实例，但不是无限个数的实例，而是有限个数的实例。这才能是枚举类。 C:案例演示 自己实现枚举类1,自动拆装箱2,泛型3,可变参数4,静态导入5,增强for循环6,互斥锁7,枚举 JDK5新特性-通过enum实现枚举类 A:案例演示 通过enum实现枚举类 JDK5新特性-枚举的注意事项 A:案例演示 定义枚举类要用关键字enum 所有枚举类都是Enum的子类 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略 枚举类可以有构造器，但必须是private的，它默认的也是private的。 枚举类也可以有抽象方法，但是枚举项必须重写该方法 枚举在switch语句中的使用 JDK5新特性-枚举类的常见方法 A:枚举类的常见方法 int ordinal() int compareTo(E o) String name() String toString() T valueOf(Class type,String name) values() 此方法虽然在JDK文档中查找不到，但每个枚举类都具有该方法，它遍历枚举类的所有枚举值非常方便 B:案例演示 枚举类的常见方法 JDK7新特性-JDK7的六个新特性回顾和讲解 A:二进制字面量 B:数字字面量可以出现下划线 C:switch 语句可以用字符串 D:泛型简化,菱形泛型 E:异常的多个catch合并,每个异常用或| F:try-with-resources 语句 JDK8新特性-JDK8的新特性 接口中可以定义有方法体的方法,如果是非静态,必须用default修饰 如果是静态的就不用了 1234567891011121314class Test &#123; public void run() &#123; final int x = 10; class Inner &#123; public void method() &#123; System.out.println(x); &#125; &#125; Inner i = new Inner(); i.method(); &#125; &#125; 局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么? 因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}],"tags":[{"name":"JDK","slug":"JDK","permalink":"github.com:cnAJun/cnAJun.github.io/tags/JDK/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}]},{"title":"Tomcat和Nginx对应多个子域名的配置","slug":"Tomcat","date":"2014-12-23T06:24:00.000Z","updated":"2018-12-04T16:34:29.000Z","comments":true,"path":"2014/12/23/Tomcat/","link":"","permalink":"github.com:cnAJun/cnAJun.github.io/2014/12/23/Tomcat/","excerpt":"在网上找了半天也没找到相关的资料,都说的太含糊. 本人对tomcat下配置 一ip对多域名的方法详细如下,按下面配置一定能成功,经过测试了. 此方法也可以配置线上域名服务,比如加域名前缀如api.test.com,admin.test.com等指定不同的文件夹目录 如下图","text":"在网上找了半天也没找到相关的资料,都说的太含糊. 本人对tomcat下配置 一ip对多域名的方法详细如下,按下面配置一定能成功,经过测试了. 此方法也可以配置线上域名服务,比如加域名前缀如api.test.com,admin.test.com等指定不同的文件夹目录 如下图 Nginx配置方式 找到对应的conf文件，vi编辑文件,主要修改以下两个位置12server_name web.Test.com api.Test.com;root /data/wwwroot/www.Test.com; Tomcat配置方式hosts配置1234567891011121314151617181920212223242526272829&lt;Host name=\"localhost\" debug=\"0\" appBase=\"D://Tomcat 5.0//webapps\" unpackWARs=\"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\"&gt; &lt;Alias&gt;localhost.com&lt;/Alias&gt; &lt;Logger className=\"org.apache.catalina.logger.FileLogger\" directory=\"logs\" prefix=\"localhost_log.\" suffix=\".txt\" timestamp=\"true\"/&gt; &lt;Context path=\"\" docBase=\"D://Tomcat 5.0//webapps//gg\" reloadable=\"true\" caseSensitive=\"false\" debug=\"0\"&gt;&lt;/Context&gt;&lt;/Host&gt;&lt;Host name=\"one.localhost\" debug=\"0\" appBase=\"D://Tomcat 5.0//webapps\" unpackWARs=\"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\"&gt; &lt;Alias&gt;one.localhost.com&lt;/Alias&gt; &lt;Logger className=\"org.apache.catalina.logger.FileLogger\" directory=\"logs\" prefix=\"localhost_log.\" suffix=\".txt\" timestamp=\"true\"/&gt; &lt;Context path=\"\" docBase=\"D://Tomcat 5.0//webapps//kk//a\" reloadable=\"true\" caseSensitive=\"false\" debug=\"0\"&gt;&lt;/Context&gt;&lt;/Host&gt;&lt;Host name=\"two.localhost\" debug=\"0\" appBase=\"D://Tomcat 5.0//webapps\" unpackWARs=\"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\"&gt; &lt;Alias&gt;two.localhost.com&lt;/Alias&gt; &lt;Logger className=\"org.apache.catalina.logger.FileLogger\" directory=\"logs\" prefix=\"localhost_log.\" suffix=\".txt\" timestamp=\"true\"/&gt; &lt;Context path=\"\" docBase=\"D://Tomcat 5.0//webapps//kk//b\" reloadable=\"true\" caseSensitive=\"false\" debug=\"0\"&gt;&lt;/Context&gt;&lt;/Host&gt; 因无域名解析服务器,所以在hosts上配,来模拟dns解析. 10.1.1.241 localhost 指向gg文件夹10.1.1.241 localhost.com 指向gg文件夹10.1.1.241 one.localhost 指向a文件夹10.1.1.241 one.localhost.com 指向a文件夹10.1.1.241 two.localhost 指向b文件夹10.1.1.241 two.localhost.com 指向b文件夹 经过多方面尝试,终于在tomcat下配置成功了. 修改默认的应用时：改defaulthost,并将context的path置为空。 配置多个应用时： 如：http://localhost:8080/ http://localhost:8080/first http://localhost:8080/second 对应的配置如下：123456789101112&lt;Host name=\"localhost\" debug=\"0\" appBase=\"D://Tomcat 5.0//webapps\" unpackWARs=\"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\"&gt; &lt;Alias&gt;localhost.com&lt;/Alias&gt; &lt;Logger className=\"org.apache.catalina.logger.FileLogger\" directory=\"logs\" prefix=\"localhost_log.\" suffix=\".txt\" timestamp=\"true\"/&gt; &lt;Context path=\"\" docBase=\"D://Tomcat 5.0//webapps//Root\" reloadable=\"true\" caseSensitive=\"false\" debug=\"0\"&gt;&lt;/Context&gt; &lt;Context path=\"/first\" docBase=\"D://Tomcat 5.0//webapps//first\" reloadable=\"true\" caseSensitive=\"false\" debug=\"0\"&gt;&lt;/Context&gt; &lt;Context path=\"/second\" docBase=\"D://Tomcat 5.0//webapps//second\" reloadable=\"true\" caseSensitive=\"false\" debug=\"0\"&gt;&lt;/Context&gt;&lt;/Host&gt;","categories":[{"name":"JAVA配置","slug":"JAVA配置","permalink":"github.com:cnAJun/cnAJun.github.io/categories/JAVA配置/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"github.com:cnAJun/cnAJun.github.io/tags/Tomcat/"}],"keywords":[{"name":"JAVA配置","slug":"JAVA配置","permalink":"github.com:cnAJun/cnAJun.github.io/categories/JAVA配置/"}]},{"title":"java基础巩固之多线程线程通信(6)","slug":"java基础巩固之多线程并发编程-6","date":"2014-12-06T16:58:00.000Z","updated":"2018-12-02T17:28:51.000Z","comments":true,"path":"2014/12/07/java基础巩固之多线程并发编程-6/","link":"","permalink":"github.com:cnAJun/cnAJun.github.io/2014/12/07/java基础巩固之多线程并发编程-6/","excerpt":"多线程-单例 单例设计模式：保证类在内存中只有一个对象。 如何保证类在内存中只有一个对象呢？ (1)控制类的创建，不让其他类来创建本类的对象。private (2)在本类中定义一个本类的对象。Singleton s; (3)提供公共的访问方式。 public static Singleton getInstance(){return s}","text":"多线程-单例 单例设计模式：保证类在内存中只有一个对象。 如何保证类在内存中只有一个对象呢？ (1)控制类的创建，不让其他类来创建本类的对象。private (2)在本类中定义一个本类的对象。Singleton s; (3)提供公共的访问方式。 public static Singleton getInstance(){return s} 单例写法两种： (1)饿汉式 开发用这种方式。 123456789101112131415//饿汉式class Singleton &#123; //1,私有构造函数 private Singleton()&#123;&#125; //2,创建本类对象 private static Singleton s = new Singleton(); //3,对外提供公共的访问方法 public static Singleton getInstance() &#123; return s; &#125; public static void print() &#123; System.out.println(\"11111111111\"); &#125;&#125; (2)懒汉式 面试写这种方式。多线程的问题？ 123456789101112131415161718//懒汉式,单例的延迟加载模式class Singleton &#123; //1,私有构造函数 private Singleton()&#123;&#125; //2,声明一个本类的引用 private static Singleton s; //3,对外提供公共的访问方法 public static Singleton getInstance() &#123; if(s == null) //线程1,线程2 s = new Singleton(); return s; &#125; public static void print() &#123; System.out.println(\"11111111111\"); &#125;&#125; (3)第三种格式 12345class Singleton &#123; private Singleton() &#123;&#125; public static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改&#125; 多线程-Runtime类 Runtime类是一个单例类 123Runtime r = Runtime.getRuntime();//r.exec(\"shutdown -s -t 300\"); //300秒后关机r.exec(\"shutdown -a\"); //取消关机 多线程-Timer Timer类:计时器 1234567891011121314151617181920212223public class Demo5_Timer &#123; /** * @param args * 计时器 * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; Timer t = new Timer(); t.schedule(new MyTimerTask(), new Date(114,9,15,10,54,20),3000); while(true) &#123; System.out.println(new Date()); Thread.sleep(1000); &#125; &#125;&#125;class MyTimerTask extends TimerTask &#123; @Override public void run() &#123; System.out.println(\"起床背英语单词\"); &#125; &#125; 多线程-两个线程间的通信 1.什么时候需要通信 多个线程并发执行时, 在默认情况下CPU是随机切换线程的 如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印 2.怎么通信 如果希望线程等待, 就调用wait() 如果希望唤醒等待的线程, 就调用notify(); 这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用 多线程-三个或三个以上间的线程通信 多个线程通信的问题 notify()方法是随机唤醒一个线程 notifyAll()方法是唤醒所有线程 JDK5之前无法唤醒指定的一个线程 如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件多线程-JDK1.5的新特性互斥锁 1.同步 使用ReentrantLock类的lock()和unlock()方法进行同步 2.通信 使用ReentrantLock类的newCondition()方法可以获取Condition对象 需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法 不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了 多线程-线程组的概述和使用 A:线程组概述 Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。 默认情况下，所有的线程都属于主线程组。 public final ThreadGroup getThreadGroup()//通过线程对象获取他所属于的组 public final String getName()//通过线程组对象获取他组的名字 我们也可以给线程设置分组 1,ThreadGroup(String name) 创建线程组对象并给其赋值名字 2,创建线程对象 3,Thread(ThreadGroup?group, Runnable?target, String?name) 4,设置整组的优先级或者守护线程 B:案例演示 线程组的使用,默认是主线程组 12345678910111213141516171819202122232425262728293031 MyRunnable mr = new MyRunnable(); Thread t1 = new Thread(mr, \"张三\"); Thread t2 = new Thread(mr, \"李四\"); //获取线程组 // 线程类里面的方法：public final ThreadGroup getThreadGroup() ThreadGroup tg1 = t1.getThreadGroup(); ThreadGroup tg2 = t2.getThreadGroup(); // 线程组里面的方法：public final String getName() String name1 = tg1.getName(); String name2 = tg2.getName(); System.out.println(name1); System.out.println(name2); // 通过结果我们知道了：线程默认情况下属于main线程组 // 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组 System.out.println(Thread.currentThread().getThreadGroup().getName()); * 自己设定线程组* // ThreadGroup(String name) ThreadGroup tg = new ThreadGroup(\"这是一个新的组\"); MyRunnable mr = new MyRunnable(); // Thread(ThreadGroup group, Runnable target, String name) Thread t1 = new Thread(tg, mr, \"张三\"); Thread t2 = new Thread(tg, mr, \"李四\"); System.out.println(t1.getThreadGroup().getName()); System.out.println(t2.getThreadGroup().getName()); //通过组名称设置后台线程，表示该组的线程都是后台线程 tg.setDaemon(true); 多线程-线程的五种状态 看图说话 新建,就绪,运行,阻塞,死亡 多线程-线程池的概述和使用 A:线程池概述 程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池 B:内置线程池的使用概述 JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法 public static ExecutorService newFixedThreadPool(int nThreads) public static ExecutorService newSingleThreadExecutor() 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法 Future&lt;?&gt; submit(Runnable task) Future submit(Callable task) 使用步骤： 创建线程池对象 创建Runnable实例 提交Runnable实例 关闭线程池 C:案例演示 提交的是Runnable 123456789// public static ExecutorService newFixedThreadPool(int nThreads)ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程pool.submit(new MyRunnable());pool.submit(new MyRunnable());//结束线程池pool.shutdown(); 多线程-多线程程序实现的方式3 提交的是Callable 1234567891011121314151617181920212223242526272829303132333435// 创建线程池对象ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程Future&lt;Integer&gt; f1 = pool.submit(new MyCallable(100));Future&lt;Integer&gt; f2 = pool.submit(new MyCallable(200));// V get()Integer i1 = f1.get();Integer i2 = f2.get();System.out.println(i1);System.out.println(i2);// 结束pool.shutdown();public class MyCallable implements Callable&lt;Integer&gt; &#123; private int number; public MyCallable(int number) &#123; this.number = number; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int x = 1; x &lt;= number; x++) &#123; sum += x; &#125; return sum; &#125;&#125; 多线程程序实现的方式3的好处和弊端 好处： 可以有返回值 可以抛出异常 弊端： 代码比较复杂，所以一般不用 ###25.11_设计模式(简单工厂模式概述和使用)(了解) A:简单工厂模式概述 又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例 B:优点 客户端不需要在负责对象的创建，从而明确了各个类的职责 C:缺点 这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护 D:案例演示 动物抽象类：public abstract Animal { public abstract void eat(); } 具体狗类：public class Dog extends Animal {} 具体猫类：public class Cat extends Animal {} 开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。 12345678910111213141516public class AnimalFactory &#123; private AnimalFactory()&#123;&#125; //public static Dog createDog() &#123;return new Dog();&#125; //public static Cat createCat() &#123;return new Cat();&#125; //改进 public static Animal createAnimal(String animalName) &#123; if(“dog”.equals(animalName)) &#123;&#125; else if(“cat”.equals(animale)) &#123; &#125;else &#123; return null; &#125; &#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"github.com:cnAJun/cnAJun.github.io/tags/多线程/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}]},{"title":"java基础巩固之多线程安全(5)","slug":"java基础巩固之多线程安全-4","date":"2014-12-04T16:44:00.000Z","updated":"2018-12-02T17:28:43.000Z","comments":true,"path":"2014/12/05/java基础巩固之多线程安全-4/","link":"","permalink":"github.com:cnAJun/cnAJun.github.io/2014/12/05/java基础巩固之多线程安全-4/","excerpt":"多线程-同步代码块 1.什么情况下需要同步 当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步. 如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码. 2.同步代码块 使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块 多个同步代码块如果使用相同的锁对象, 那么他们就是同步的","text":"多线程-同步代码块 1.什么情况下需要同步 当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步. 如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码. 2.同步代码块 使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块 多个同步代码块如果使用相同的锁对象, 那么他们就是同步的 123456789101112131415class Printer &#123; Demo d = new Demo(); public static void print1() &#123; synchronized(d)&#123; //锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象 System.out.print(\"\\r\\n\"); &#125; &#125; public static void print2() &#123; synchronized(d)&#123; System.out.print(\"\\r\\n\"); &#125; &#125;&#125; 多线程-同步方法 使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的 1234567891011121314151617181920212223class Printer &#123; public static void print1() &#123; synchronized(Printer.class)&#123; //锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象 System.out.print(\"黑\"); System.out.print(\"马\"); System.out.print(\"程\"); System.out.print(\"序\"); System.out.print(\"员\"); System.out.print(\"\\r\\n\"); &#125; &#125; /* * 非静态同步函数的锁是:this * 静态的同步函数的锁是:字节码对象 */ public static synchronized void print2() &#123; System.out.print(\"传\"); System.out.print(\"智\"); System.out.print(\"播\"); System.out.print(\"客\"); System.out.print(\"\\r\\n\"); &#125;&#125; 多线程-线程安全问题 多线程并发操作同一数据时, 就有可能出现线程安全问题 使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Demo2_Synchronized &#123; /** * @param args * 需求:铁路售票,一共100张,通过四个窗口卖完. */ public static void main(String[] args) &#123; TicketsSeller t1 = new TicketsSeller(); TicketsSeller t2 = new TicketsSeller(); TicketsSeller t3 = new TicketsSeller(); TicketsSeller t4 = new TicketsSeller(); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t4.setName(\"窗口4\"); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125;class TicketsSeller extends Thread &#123; private static int tickets = 100; static Object obj = new Object(); public TicketsSeller() &#123; super(); &#125; public TicketsSeller(String name) &#123; super(name); &#125; public void run() &#123; while(true) &#123; synchronized(obj) &#123; if(tickets &lt;= 0) break; try &#123; Thread.sleep(10);//线程1睡,线程2睡,线程3睡,线程4睡 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + \"...这是第\" + tickets-- + \"号票\"); &#125; &#125; &#125;&#125; 多线程-死锁 多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁 尽量不要嵌套使用 1234567891011121314151617181920212223242526272829private static String s1 = \"筷子左\";private static String s2 = \"筷子右\";public static void main(String[] args) &#123; new Thread() &#123; public void run() &#123; while(true) &#123; synchronized(s1) &#123; System.out.println(getName() + \"...拿到\" + s1 + \"等待\" + s2); synchronized(s2) &#123; System.out.println(getName() + \"...拿到\" + s2 + \"开吃\"); &#125; &#125; &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while(true) &#123; synchronized(s2) &#123; System.out.println(getName() + \"...拿到\" + s2 + \"等待\" + s1); synchronized(s1) &#123; System.out.println(getName() + \"...拿到\" + s1 + \"开吃\"); &#125; &#125; &#125; &#125; &#125;.start();&#125; 多线程-以前的线程安全的类回顾 A:回顾以前说过的线程安全问题 看源码：Vector,StringBuffer,Hashtable,Collections.synchroinzed(xxx) Vector是线程安全的,ArrayList是线程不安全的 StringBuffer是线程安全的,StringBuilder是线程不安全的 Hashtable是线程安全的,HashMap是线程不安全的","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}],"tags":[],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}]},{"title":"java基础巩固之多线程概念和应用(4)","slug":"java基础笔记-4-多线程","date":"2014-12-03T16:30:00.000Z","updated":"2018-12-02T17:28:31.000Z","comments":true,"path":"2014/12/04/java基础笔记-4-多线程/","link":"","permalink":"github.com:cnAJun/cnAJun.github.io/2014/12/04/java基础笔记-4-多线程/","excerpt":"多线程-多线程的引入 1.什么是线程 线程是程序执行的一条路径, 一个进程中可以包含多条线程 多线程并发执行可以提高程序的效率, 可以同时完成多项工作 2.多线程的应用场景 红蜘蛛同时共享屏幕给多个电脑 迅雷开启多条线程一起下载 QQ同时和多个人一起视频 服务器同时处理多个客户端请求","text":"多线程-多线程的引入 1.什么是线程 线程是程序执行的一条路径, 一个进程中可以包含多条线程 多线程并发执行可以提高程序的效率, 可以同时完成多项工作 2.多线程的应用场景 红蜘蛛同时共享屏幕给多个电脑 迅雷开启多条线程一起下载 QQ同时和多个人一起视频 服务器同时处理多个客户端请求 多线程-多线程并行和并发的区别 并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU) 并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。 比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。 如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。 多线程-Java程序运行原理和JVM的启动是多线程的吗 A:Java程序运行原理 Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。 B:JVM的启动是多线程的吗 JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。 多线程-多线程程序实现的方式1 1.继承Thread 定义类继承Thread 重写run方法 把新线程要做的事写在run方法中 创建线程对象 开启新线程, 内部会自动执行run方法 1234567891011121314151617181920212223public class Demo2_Thread &#123; /** * @param args */ public static void main(String[] args) &#123; MyThread mt = new MyThread(); // 4,创建自定义类的对象 mt.start(); // 5,开启线程 for (int i = 0; i &lt; 3000; i++) &#123; System.out.println(\"bb\"); &#125; &#125;&#125;class MyThread extends Thread &#123; // 1,定义类继承Thread public void run() &#123; // 2,重写run方法 for (int i = 0; i &lt; 3000; i++) &#123; // 3,将要执行的代码,写在run方法中 System.out.println(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125;&#125; 多线程-多线程程序实现的方式2 2.实现Runnable 定义类实现Runnable接口 实现run方法 把新线程要做的事写在run方法中 创建自定义的Runnable的子类对象 创建Thread对象, 传入Runnable 调用start()开启新线程, 内部会自动调用Runnable的run()方法 12345678910111213141516171819202122232425public class Demo3_Runnable &#123; /** * @param args */ public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); // 4,创建自定义类对象 // Runnable target = new MyRunnable(); Thread t = new Thread(mr); // 5,将其当作参数传递给Thread的构造函数 t.start(); // 6,开启线程 for (int i = 0; i &lt; 3000; i++) &#123; System.out.println(\"bb\"); &#125; &#125;&#125;class MyRunnable implements Runnable &#123; // 1,自定义类实现Runnable接口 @Override public void run() &#123; // 2,重写run方法 for (int i = 0; i &lt; 3000; i++) &#123; // 3,将要执行的代码,写在run方法中 System.out.println(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125;&#125; 多线程-实现Runnable的原理 查看源码 1,看Thread类的构造函数,传递了Runnable接口的引用 2,通过init()方法找到传递的target给成员变量的target赋值 3,查看run方法,发现run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法 多线程-两种方式的区别 查看源码的区别: a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法 b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法 继承Thread 好处是:可以直接使用Thread类中的方法,代码简单 弊端是:如果已经有了父类,就不能用这种方法 实现Runnable接口 好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的 弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂多线程-匿名内部类实现线程的两种方式 继承Thread类 1234567891011121314151617public static void main(String[] args) &#123; new Thread() &#123; // 1,new 类()&#123;&#125;继承这个类 public void run() &#123; // 2,重写run方法 for (int i = 0; i &lt; 3000; i++) &#123; // 3,将要执行的代码,写在run方法中 System.out.println(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125; &#125;.start(); // 实现Runnable接口 new Thread(new Runnable() &#123; // 1,new 接口()&#123;&#125;实现这个接口 public void run() &#123; // 2,重写run方法 for (int i = 0; i &lt; 3000; i++) &#123; // 3,将要执行的代码,写在run方法中 System.out.println(\"bb\"); &#125; &#125; &#125;).start();&#125; 多线程-获取名字和设置名字 1.获取名字 通过getName()方法获取线程对象的名字 2.设置名字 通过构造函数可以传入String类型的名字 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Test &#123; public static void main(String[] args) &#123; new Thread(\"xxx\") &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + \"....aaaaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125; &#125;.start(); new Thread(\"yyy\") &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + \"....bb\"); &#125; &#125; &#125;.start(); /* * 通过setName(String)方法可以设置线程对象的名字 */ Thread t1 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + \"....aaaaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + \"....bb\"); &#125; &#125; &#125;; t1.setName(\"芙蓉姐姐\"); t2.setName(\"凤姐\"); t1.start(); t2.start(); &#125;&#125; 多线程-获取当前线程的对象 Thread.currentThread(), 主线程也可以获取 1234567891011121314151617new Thread(new Runnable() &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + \"...aaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125;&#125;).start();new Thread(new Runnable() &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + \"...bb\"); &#125; &#125;&#125;).start();Thread.currentThread().setName(\"我是主线程\"); //获取主函数线程的引用,并改名字System.out.println(Thread.currentThread().getName()); //获取主函数线程的引用,并获取名字 多线程-休眠线程 Thread.sleep(毫秒,纳秒), 控制当前线程休眠若干毫秒1秒= 1000毫秒 1秒 = 1000 1000 1000纳秒 1000000000 12345678910111213141516171819202122232425new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + \"...aaaaaaaaaaaaaaaaaaaaaa\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;.start();new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + \"...bb\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;.start(); 多线程-守护线程 setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Thread t1 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 50; i++) &#123; System.out.println(getName() + \"...aaaaaaaaaaaaaaaaaaaaaa\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 5; i++) &#123; System.out.println(getName() + \"...bb\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; t1.setDaemon(true); //将t1设置为守护线程 t1.start(); t2.start();### 多线程-加入线程* join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续* join(int), 可以等待指定的毫秒之后继续 * final Thread t1 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 50; i++) &#123; System.out.println(getName() + \"...aaaaaaaaaaaaaaaaaaaaaa\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 50; i++) &#123; if(i == 2) &#123; try &#123; //t1.join(); //插队,加入 t1.join(30); //加入,有固定的时间,过了固定时间,继续交替执行 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(getName() + \"...bb\"); &#125; &#125; &#125;; t1.start(); t2.start(); 多线程-礼让线程 yield让出cpu 多线程-设置线程的优先级 setPriority()设置线程的优先级","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"github.com:cnAJun/cnAJun.github.io/tags/多线程/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}]},{"title":"java基础巩固之设计模式(3)","slug":"Java基础巩固之设计模式-3","date":"2014-12-03T15:59:00.000Z","updated":"2018-12-02T17:29:03.000Z","comments":true,"path":"2014/12/03/Java基础巩固之设计模式-3/","link":"","permalink":"github.com:cnAJun/cnAJun.github.io/2014/12/03/Java基础巩固之设计模式-3/","excerpt":"设计模式-模版(Template)设计模式概述和使用 A:模版设计模式概述 模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现 B:优点和缺点 a:优点 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求 b:缺点 如果算法骨架有修改的话，则需要修改抽象类","text":"设计模式-模版(Template)设计模式概述和使用 A:模版设计模式概述 模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现 B:优点和缺点 a:优点 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求 b:缺点 如果算法骨架有修改的话，则需要修改抽象类 1,装饰2,单例 多线程-单例 单例设计模式：保证类在内存中只有一个对象。 如何保证类在内存中只有一个对象呢？ (1)控制类的创建，不让其他类来创建本类的对象。private (2)在本类中定义一个本类的对象。Singleton s; (3)提供公共的访问方式。 public static Singleton getInstance(){return s} 单例写法两种： (1)饿汉式 开发用这种方式。 123456789101112131415//饿汉式class Singleton &#123; //1,私有构造函数 private Singleton()&#123;&#125; //2,创建本类对象 private static Singleton s = new Singleton(); //3,对外提供公共的访问方法 public static Singleton getInstance() &#123; return s; &#125; public static void print() &#123; System.out.println(\"11111111111\"); &#125;&#125; (2)懒汉式 面试写这种方式。多线程的问题？ 123456789101112131415161718//懒汉式,单例的延迟加载模式class Singleton &#123; //1,私有构造函数 private Singleton()&#123;&#125; //2,声明一个本类的引用 private static Singleton s; //3,对外提供公共的访问方法 public static Singleton getInstance() &#123; if(s == null) //线程1,线程2 s = new Singleton(); return s; &#125; public static void print() &#123; System.out.println(\"11111111111\"); &#125;&#125; (3)第三种格式1234567891011 class Singleton &#123; private Singleton() &#123;&#125; public static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改 &#125;###25.02_多线程(Runtime类)* Runtime类是一个单例类 * Runtime r = Runtime.getRuntime(); //r.exec(\"shutdown -s -t 300\"); //300秒后关机 r.exec(\"shutdown -a\"); //取消关机 3,简单工厂4,工厂方法 设计模式-工厂方法模式的概述和使用 A:工厂方法模式概述 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。 B:优点 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性 C:缺点 需要额外的编写代码，增加了工作量 D:案例演示 动物抽象类：public abstract Animal { public abstract void eat(); } 工厂接口：public interface Factory {public abstract Animal createAnimal();} 具体狗类：public class Dog extends Animal {} 具体猫类：public class Cat extends Animal {} 开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。 狗工厂：public class DogFactory implements Factory { public Animal createAnimal() {…} } 猫工厂：public class CatFactory implements Factory { public Animal createAnimal() {…} } 5,适配器6,模版","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"github.com:cnAJun/cnAJun.github.io/tags/JAVA/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}]},{"title":"java基础巩固之代理(2)","slug":"Java基础巩固之动态代理-2","date":"2014-12-03T15:53:00.000Z","updated":"2018-12-03T06:37:34.000Z","comments":true,"path":"2014/12/03/Java基础巩固之动态代理-2/","link":"","permalink":"github.com:cnAJun/cnAJun.github.io/2014/12/03/Java基础巩固之动态代理-2/","excerpt":"什么是代理？代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法 现实生活中例子就是老板与管理之间的关系,他只要负责公司的大方向,而其他的事情就交给他的代理人(管理)来解决.这就是代理思想在现实中的一个例子","text":"什么是代理？代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法 现实生活中例子就是老板与管理之间的关系,他只要负责公司的大方向,而其他的事情就交给他的代理人(管理)来解决.这就是代理思想在现实中的一个例子 静态代理 在使用时,需要定义接口或者父类 被代理对象与代理对象一起实现相同的接口或者是继承相同父类 举个例子: 123456789101112131415/** * 接口 */interface IUserDao &#123; void save();&#125;/** * 接口实现 * 目标对象 */class UserDao implements IUserDao &#123; public void save() &#123; System.out.println(\"----UserDao 输出!----\"); &#125;&#125; 创建静态代理类 1234567891011121314151617/** * 代理对象,静态代理 */class StaticUserDaoProxy implements IUserDao &#123; //接收保存目标对象 private IUserDao target; public StaticUserDaoProxy(IUserDao target) &#123; this.target = target; &#125; public void save() &#123; System.out.println(\"before StaticUserDaoProxy...\"); target.save();//执行目标对象的方法 System.out.println(\"after StaticUserDaoProxy...\"); &#125;&#125; 测试代码: 1234UserDao target = new UserDao(); //静态代理 StaticUserDaoProxy staticUserDaoProxy = new StaticUserDaoProxy(target); staticUserDaoProxy.save(); 静态代理缺点: 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护. JDK动态代理 动态代理对象特点: 代理对象,不需要实现接口 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型) 动态代理也叫做:JDK代理,接口代理s JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是: 1newProxyInstance(ClassLoader loader, Class&lt;&gt;[] interfaces,InvocationHandler h ) newProxyInstance方法用来返回一个代理对象，这个方法总共有3个参数，ClassLoader loader用来指明生成代理对象使用哪个类装载器，Class&lt;？&gt;[] interfaces用来指明生成哪个对象的代理对象，通过接口指定，InvocationHandler h用来指明产生的这个代理对象要做什么事情。所以我们只需要调用newProxyInstance方法就可以得到某一个对象的代理对象了。 创建JDK代理类 123456789101112131415161718192021222324252627282930/** * JDK 代理对象 */class JDKProxyFactory &#123; //维护一个目标对象 private Object target; public JDKProxyFactory(Object target) &#123; this.target = target; &#125; //给目标对象生成代理对象 public Object getProxyInstance() &#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"before JDKProxyFactory\"); //执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println(\"after JDKProxyFactory\"); return returnValue; &#125; &#125; ); &#125;&#125; 测试代码: 12345678 //jdk动态代理 JDKProxyFactory jdkProxyFactory = new JDKProxyFactory(target); IUserDao iTarget = (IUserDao) jdkProxyFactory.getProxyInstance(); iTarget.save(); //注意,只能返回接口而不是具体实现类,否让报如下错误 // java.lang.ClassCastException: XXXX.$Proxy0 cannot be cast to XXXX.UserDao// UserDao dao = (UserDao) jdkProxyFactory.getProxyInstance(); JDK动态代理局限性 通过反射类Proxy和InvocationHandler回调接口实现的jdk动态代理，要求委托类必须实现一个接口，但事实上并不是所有类都有接口，对于没有实现接口的类，便无法使用该方方式实现动态代理。 Cglib动态代理 上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象, Cglib代理,也叫作子类代理,是基于asm框架，实现了无反射机制进行代理，利用空间来换取了时间，代理效率高于jdk ,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展. 它有如下特点: JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现. Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截) Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉. 注意 需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入pring-core-3.2.5.jar即可. 引入功能包后,就可以在内存中动态构建子类 代理的类不能为final,否则报错 目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法. 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839class UserDaoWithoutInterFace &#123; public void save() &#123; System.out.println(\"----UserDaoWithoutInterFace 输出!----\"); &#125;&#125;class CGlibProxyFactory implements MethodInterceptor &#123; //维护目标对象 private Object target; public CGlibProxyFactory(Object target) &#123; this.target = target; &#125; //给目标对象创建一个代理对象 public Object getProxyInstance() &#123; //1.工具类 Enhancer en = new Enhancer(); //2.设置父类 en.setSuperclass(target.getClass()); //3.设置回调函数 en.setCallback(this); //4.创建子类(代理对象) return en.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(\"before CGlibProxyFactory...\"); //执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(\"after CGlibProxyFactory...\"); return returnValue; &#125;&#125; 调用代码 1234UserDaoWithoutInterFace target2 = new UserDaoWithoutInterFace(); CGlibProxyFactory cGlibProxyFactory = new CGlibProxyFactory(target2); UserDaoWithoutInterFace dao = (UserDaoWithoutInterFace) cGlibProxyFactory.getProxyInstance(); dao.save(); 其他 使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的 CGLIB的核心类： net.sf.cglib.proxy.Enhancer – 主要的增强类 net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现 net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"github.com:cnAJun/cnAJun.github.io/tags/JAVA/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}]},{"title":"java基础巩固之类加载器(3)","slug":"java基础巩固之类加载器-2","date":"2014-12-03T06:29:00.000Z","updated":"2018-12-03T06:54:14.000Z","comments":true,"path":"2014/12/03/java基础巩固之类加载器-2/","link":"","permalink":"github.com:cnAJun/cnAJun.github.io/2014/12/03/java基础巩固之类加载器-2/","excerpt":"","text":"类加载器是 Java 语言的一个创新，也是 Java 语言流行的重要原因之一。它使得 Java 类可以被动态加载到 Java 虚拟机中并执行。类加载器从 JDK 1.0 就出现了，最初是为了满足 Java Applet 的需要而开发出来的。Java Applet 需要从远程下载 Java 类文件到浏览器中并执行。现在类加载器在 Web 容器和 OSGi 中得到了广泛的使用。一般来说，Java 应用的开发人员不需要直接同类加载器进行交互。Java 虚拟机默认的行为就已经足够满足大多数情况的需求了。不过如果遇到了需要与类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就很容易花大量的时间去调试 ClassNotFoundException和 NoClassDefFoundError等异常。本文将详细介绍 Java 的类加载器，帮助读者深刻理解 Java 语言中的这个重要概念。下面首先介绍一些相关的基本概念。 类加载器基本概念 顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。 基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。下面详细介绍这个 Java 类。 java.lang.ClassLoader类介绍 java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。不过本文只讨论其加载类的功能。为了完成加载类的这个职责，ClassLoader提供了一系列的方法，比较重要的方法如 表 1所示。关于这些方法的细节会在下面进行介绍。 表 1. ClassLoader 中与加载类相关的方法 方法 说明 getParent() 返回该类加载器的父类加载器。 loadClass(String name) 加载名称为 name的类，返回的结果是 java.lang.Class类的实例。 findClass(String name) 查找名称为 name的类，返回的结果是 java.lang.Class类的实例。 findLoadedClass(String name) 查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。 defineClass(String name, byte[] b, int off, int len) 把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。 resolveClass(Class&lt;?&gt; c) 链接指定的 Java 类。 对于 表 1中给出的方法，表示类名称的 name参数的值是类的二进制名称。需要注意的是内部类的表示，如com.example.Sample$1和 com.example.Sample$Inner等表示方式。这些方法会在下面介绍类加载器的工作机制时，做进一步的说明。下面介绍类加载器的树状组织结构。 类加载器的树状组织结构 Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个： 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自java.lang.ClassLoader。 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。 除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 表 1中给出的 getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器。图 1中给出了一个典型的类加载器树状组织结构示意图，其中的箭头指向的是父类加载器。 图 1. 类加载器树状组织结构示意图 代码清单 1演示了类加载器的树状组织结构。 清单 1. 演示类加载器的树状组织结构 12345678910public class ClassLoaderTree &#123; public static void main(String[] args) &#123; ClassLoader loader = ClassLoaderTree.class.getClassLoader(); while (loader != null) &#123; System.out.println(loader.toString()); loader = loader.getParent(); &#125; &#125; &#125; 每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 getClassLoader()方法就可以获取到此引用。代码清单 1中通过递归调用 getParent()方法来输出全部的父类加载器。代码清单 1的运行结果如 代码清单 2所示。 清单 2. 演示类加载器的树状组织结构的运行结果 12sun.misc.Launcher$AppClassLoader@9304b1 sun.misc.Launcher$ExtClassLoader@190d11 如 代码清单 2所示，第一个输出的是 ClassLoaderTree类的类加载器，即系统类加载器。它是sun.misc.Launcher$AppClassLoader类的实例；第二个输出的是扩展类加载器，是 sun.misc.Launcher$ExtClassLoader类的实例。需要注意的是这里并没有输出引导类加载器，这是由于有些 JDK 的实现对于父类加载器是引导类加载器的情况，getParent()方法返回 null。 在了解了类加载器的树状组织结构之后，下面介绍类加载器的代理模式。 类加载器的代理模式 类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常ClassCastException。下面通过示例来具体说明。代码清单 3中给出了 Java 类 com.example.Sample。 清单 3. com.example.Sample 类 123456789package com.example; public class Sample &#123; private Sample instance; public void setSample(Object instance) &#123; this.instance = (Sample) instance; &#125; &#125; 如 代码清单 3所示，com.example.Sample类的方法 setSample接受一个 java.lang.Object类型的参数，并且会把该参数强制转换成 com.example.Sample类型。测试 Java 类是否相同的代码如 代码清单 4所示。 清单 4. 测试 Java 类是否相同 12345678910111213141516public void testClassIdentity() &#123; String classDataRootPath = \"C:\\\\workspace\\\\Classloader\\\\classData\"; FileSystemClassLoader fscl1 = new FileSystemClassLoader(classDataRootPath); FileSystemClassLoader fscl2 = new FileSystemClassLoader(classDataRootPath); String className = \"com.example.Sample\"; try &#123; Class&lt;?&gt; class1 = fscl1.loadClass(className); Object obj1 = class1.newInstance(); Class&lt;?&gt; class2 = fscl2.loadClass(className); Object obj2 = class2.newInstance(); Method setSampleMethod = class1.getMethod(\"setSample\", java.lang.Object.class); setSampleMethod.invoke(obj1, obj2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 代码清单 4中使用了类 FileSystemClassLoader的两个不同实例来分别加载类 com.example.Sample，得到了两个不同的java.lang.Class的实例，接着通过 newInstance()方法分别生成了两个类的对象 obj1和 obj2，最后通过 Java 的反射 API 在对象 obj1上调用方法 setSample，试图把对象 obj2赋值给 obj1内部的 instance对象。代码清单 4的运行结果如 代码清单 5所示。 清单 5. 测试 Java 类是否相同的运行结果 1234567891011java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)at java.lang.reflect.Method.invoke(Method.java:597) at classloader.ClassIdentity.testClassIdentity(ClassIdentity.java:26) at classloader.ClassIdentity.main(ClassIdentity.java:9) Caused by: java.lang.ClassCastException: com.example.Sample cannot be cast to com.example.Sample at com.example.Sample.setSample(Sample.java:7) ... 6 more 从 代码清单 5给出的运行结果可以看到，运行时抛出了 java.lang.ClassCastException异常。虽然两个对象 obj1和obj2的类的名字相同，但是这两个类是由不同的类加载器实例来加载的，因此不被 Java 虚拟机认为是相同的。 了解了这一点之后，就可以理解代理模式的设计动机了。代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。 不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。这种技术在许多框架中都被用到，后面会详细介绍。 下面具体介绍类加载器加载类的详细过程。 加载类的过程 在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 defineClass来实现的；而启动类的加载过程是通过调用 loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。 方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是java.lang.NoClassDefFoundError异常。 类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。 下面讨论另外一种类加载器：线程上下文类加载器。 线程上下文类加载器 线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。 前面提到的类加载器的代理模式并不能解决 Java 应用开发中会遇到的类加载器的全部问题。Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 javax.xml.parsers包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 javax.xml.parsers.DocumentBuilderFactory类中的 newInstance()方法用来生成一个新的DocumentBuilderFactory的实例。这里的实例的真正的类是继承自 javax.xml.parsers.DocumentBuilderFactory，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl。而问题在于，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。 线程上下文类加载器正好解决了这个问题。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。 下面介绍另外一种加载类的方法：Class.forName。 Class.forName Class.forName是一个静态方法，同样可以用来加载类。该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。第一种形式的参数 name表示的是类的全名；initialize表示是否初始化类；loader表示加载时使用的类加载器。第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。Class.forName的一个很常见的用法是在加载数据库驱动的时候。如Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”).newInstance()用来加载 Apache Derby 数据库的驱动。 在介绍完类加载器相关的基本概念之后，下面介绍如何开发自己的类加载器。 开发自己的类加载器 虽然在绝大多数情况下，系统默认提供的类加载器实现已经可以满足需求。但是在某些情况下，您还是需要为应用开发出自己的类加载器。比如您的应用通过网络来传输 Java 类的字节代码，为了保证安全性，这些字节代码经过了加密处理。这个时候您就需要自己的类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出要在 Java 虚拟机中运行的类来。下面将通过两个具体的实例来说明类加载器的开发。 文件系统类加载器 第一个类加载器用来加载存储在文件系统上的 Java 字节代码。完整的实现如 代码清单 6所示。 清单 6. 文件系统类加载器 1234567891011121314151617181920212223242526272829303132333435363738394041public class FileSystemClassLoader extends ClassLoader &#123; private String rootDir; public FileSystemClassLoader(String rootDir) &#123; this.rootDir = rootDir; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = getClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] getClassData(String className) &#123; String path = classNameToPath(className); try &#123; InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead = 0; while ((bytesNumRead = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, bytesNumRead); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private String classNameToPath(String className) &#123; return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; &#125; &#125; 如 代码清单 6所示，类 FileSystemClassLoader继承自类 java.lang.ClassLoader。在 表 1中列出的java.lang.ClassLoader类的常用方法中，一般来说，自己开发的类加载器只需要覆写 findClass(String name)方法即可。java.lang.ClassLoader类的方法 loadClass()封装了前面提到的代理模式的实现。该方法会首先调用findLoadedClass()方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的 loadClass()方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用 findClass()方法来查找该类。因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法。 类 FileSystemClassLoader的 findClass()方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass()方法来把这些字节代码转换成 java.lang.Class类的实例。 网络类加载器 下面将通过一个网络类加载器来说明如何通过类加载器来实现组件的动态更新。即基本的场景是：Java 字节代码（.class）文件存放在服务器上，客户端通过网络的方式获取字节代码并执行。当有版本更新的时候，只需要替换掉服务器上保存的文件即可。通过类加载器可以比较简单的实现这种需求。 类 NetworkClassLoader负责通过网络下载 Java 类字节代码并定义出 Java 类。它的实现与 FileSystemClassLoader类似。在通过 NetworkClassLoader加载了某个版本的类之后，一般有两种做法来使用它。第一种做法是使用 Java 反射 API。另外一种做法是使用接口。需要注意的是，并不能直接在客户端代码中引用从服务器上下载的类，因为客户端代码的类加载器找不到这些类。使用 Java 反射 API 可以直接调用 Java 类的方法。而使用接口的做法则是把接口的类放在客户端中，从服务器上加载实现此接口的不同版本的类。在客户端通过相同的接口来使用这些实现类。网络类加载器的具体代码见 下载。 在介绍完如何开发自己的类加载器之后，下面说明类加载器和 Web 容器的关系。 类加载器与 Web 容器 对于运行在 Java EE™容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。 绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则： 每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。 多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。 当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。在介绍完类加载器与 Web 容器的关系之后，下面介绍它与 OSGi 的关系。 类加载器与 OSGi OSGi™是 Java 上的动态模块系统。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方式用来管理软件的生命周期。OSGi 已经被实现和部署在很多产品上，在开源社区也得到了广泛的支持。Eclipse 就是基于 OSGi 技术来构建的。 OSGi 中的每个模块（bundle）都包含 Java 包和类。模块可以声明它所依赖的需要导入（import）的其它模块的 Java 包和类（通过 Import-Package），也可以声明导出（export）自己的包和类，供其它模块使用（通过 Export-Package）。也就是说需要能够隐藏和共享一个模块中的某些 Java 包和类。这是通过 OSGi 特有的类加载器机制来实现的。OSGi 中的每个模块都有对应的一个类加载器。它负责加载模块自己包含的 Java 包和类。当它需要加载 Java 核心库的类时（以 java开头的包和类），它会代理给父类加载器（通常是启动类加载器）来完成。当它需要加载所导入的 Java 类时，它会代理给导出此 Java 类的模块来完成加载。模块也可以显式的声明某些 Java 包和类，必须由父类加载器来加载。只需要设置系统属性 org.osgi.framework.bootdelegation的值即可。 假设有两个模块 bundleA 和 bundleB，它们都有自己对应的类加载器 classLoaderA 和 classLoaderB。在 bundleA 中包含类 com.bundleA.Sample，并且该类被声明为导出的，也就是说可以被其它模块所使用的。bundleB 声明了导入 bundleA 提供的类 com.bundleA.Sample，并包含一个类 com.bundleB.NewSample继承自 com.bundleA.Sample。在 bundleB 启动的时候，其类加载器 classLoaderB 需要加载类 com.bundleB.NewSample，进而需要加载类com.bundleA.Sample。由于 bundleB 声明了类 com.bundleA.Sample是导入的，classLoaderB 把加载类com.bundleA.Sample的工作代理给导出该类的 bundleA 的类加载器 classLoaderA。classLoaderA 在其模块内部查找类com.bundleA.Sample并定义它，所得到的类 com.bundleA.Sample实例就可以被所有声明导入了此类的模块使用。对于以java开头的类，都是由父类加载器来加载的。如果声明了系统属性org.osgi.framework.bootdelegation=com.example.core.*，那么对于包 com.example.core中的类，都是由父类加载器来完成的。 OSGi 模块的这种类加载器结构，使得一个类的不同版本可以共存在 Java 虚拟机中，带来了很大的灵活性。不过它的这种不同，也会给开发人员带来一些麻烦，尤其当模块需要使用第三方提供的库的时候。下面提供几条比较好的建议： 如果一个类库只有一个模块使用，把该类库的 jar 包放在模块中，在 Bundle-ClassPath中指明即可。 如果一个类库被多个模块共用，可以为这个类库单独的创建一个模块，把其它模块需要用到的 Java 包声明为导出的。其它模块声明导入这些类。 如果类库提供了 SPI 接口，并且利用线程上下文类加载器来加载 SPI 实现的 Java 类，有可能会找不到 Java 类。如果出现了 NoClassDefFoundError异常，首先检查当前线程的上下文类加载器是否正确。通过Thread.currentThread().getContextClassLoader()就可以得到该类加载器。该类加载器应该是该模块对应的类加载器。如果不是的话，可以首先通过 class.getClassLoader()来得到模块对应的类加载器，再通过Thread.currentThread().setContextClassLoader()来设置当前线程的上下文类加载器。 总结 类加载器是 Java 语言的一个创新。它使得动态安装和更新软件组件成为可能。本文详细介绍了类加载器的相关话题，包括基本概念、代理模式、线程上下文类加载器、与 Web 容器和 OSGi 的关系等。开发人员在遇到ClassNotFoundException和 NoClassDefFoundError等异常的时候，应该检查抛出异常的类的类加载器和当前线程的上下文类加载器，从中可以发现问题的所在。在开发自己的类加载器的时候，需要注意与已有的类加载器组织结构的协调。 参考资料 java类加载机制工作原理 Java类加载器总结 - 寂静大海 - 博客频道 - CSDN.NET","categories":[],"tags":[],"keywords":[]},{"title":"java基础巩固之反射(1)","slug":"Untitled","date":"2014-12-02T15:20:00.000Z","updated":"2018-12-03T02:37:24.000Z","comments":true,"path":"2014/12/02/Untitled/","link":"","permalink":"github.com:cnAJun/cnAJun.github.io/2014/12/02/Untitled/","excerpt":"反射-类的加载概述和加载时机 A:类的加载概述 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。 加载 就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。 连接 验证 是否有正确的内部结构，并和其他类协调一致 准备 负责为类的静态成员分配内存，并设置默认初始化值 解析 将类的二进制数据中的符号引用替换为直接引用 初始化 就是我们以前讲过的初始化步骤","text":"反射-类的加载概述和加载时机 A:类的加载概述 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。 加载 就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。 连接 验证 是否有正确的内部结构，并和其他类协调一致 准备 负责为类的静态成员分配内存，并设置默认初始化值 解析 将类的二进制数据中的符号引用替换为直接引用 初始化 就是我们以前讲过的初始化步骤 B:加载时机 创建类的实例 访问类的静态变量，或者为静态变量赋值 调用类的静态方法 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 ###27.02_反射(类加载器的概述和分类) A:类加载器的概述 负责将.class文件加载到内存中，并为之生成对应的Class对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。 B:类加载器的分类 Bootstrap ClassLoader 根类加载器 Extension ClassLoader 扩展类加载器 Sysetm ClassLoader 系统类加载器 C:类加载器的作用 Bootstrap ClassLoader 根类加载器 也被称为引导类加载器，负责Java核心类的加载 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中 Extension ClassLoader 扩展类加载器 负责JRE的扩展目录中jar包的加载。 在JDK中JRE的lib目录下ext目录 Sysetm ClassLoader 系统类加载器 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径 ###27.03_反射(反射概述) A:反射概述 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性； 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 要想解剖一个类,必须先要获取到该类的字节码文件对象。 而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。 B:三种方式 a:Object类的getClass()方法,判断两个对象是否是同一个字节码文件 b:静态属性class,锁对象 c:Class类中静态方法forName(),读取配置文件 C:案例演示 获取class文件对象的三种方式 反射-Class.forName()读取配置文件举例 榨汁机(Juicer)榨汁的案例 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze) 1234567891011121314151617181920212223242526272829303132333435363738394041public class Demo2_Reflect &#123; /** * 榨汁机(Juicer)榨汁的案例 * 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze) * @throws Exception */ public static void main(String[] args) throws Exception &#123; /*Juicer j = new Juicer(); //j.run(new Apple()); j.run(new Orange());*/ BufferedReader br = new BufferedReader(new FileReader(\"config.properties\")); //创建输入流对象,关联配置文件 Class&lt;?&gt; clazz = Class.forName(br.readLine()); //读取配置文件一行内容,获取该类的字节码对象 Fruit f = (Fruit) clazz.newInstance(); //通过字节码对象创建实例对象 Juicer j = new Juicer(); j.run(f); &#125;&#125;interface Fruit &#123; public void squeeze();&#125;class Apple implements Fruit &#123; public void squeeze() &#123; System.out.println(\"榨出一杯苹果汁儿\"); &#125;&#125;class Orange implements Fruit &#123; public void squeeze() &#123; System.out.println(\"榨出一杯桔子汁儿\"); &#125;&#125;class Juicer &#123; public void run(Fruit f) &#123; f.squeeze(); &#125;&#125; 反射-通过反射获取带参构造方法并使用 Constructor Class类的newInstance()方法是使用该类无参的构造函数创建对象, 如果一个类没有无参的构造函数, 就不能这样创建了,可以调用Class类的getConstructor(String.class,int.class)方法获取一个指定的构造函数然后再调用Constructor类的newInstance(“张三”,20)方法创建对象 反射-通过反射获取成员变量并使用 Field Class.getField(String)方法可以获取类中的指定字段(可见的), 如果是私有的可以用getDeclaedField(“name”)方法获取,通过set(obj, “李四”)方法可以设置指定对象上该字段的值, 如果是私有的需要先调用setAccessible(true)设置访问权限,用获取的指定的字段调用get(obj)可以获取指定对象中该字段的值 反射-通过反射获取方法并使用 Method Class.getMethod(String, Class…) 和 Class.getDeclaredMethod(String, Class…)方法可以获取类中的指定方法,调用invoke(Object, Object…)可以调用该方法,Class.getMethod(“eat”) invoke(obj) Class.getMethod(“eat”,int.class) invoke(obj,10) 反射-通过反射越过泛型检查 A:案例演示 ArrayList的一个对象，在这个集合中添加一个字符串数据，如何实现呢？ 反射-通过反射写一个通用的设置某个对象的某个属性为指定的值 public void setProperty(Object obj, String propertyName, Object value){}，此方法可将obj对象中名为propertyName的属性的值设置为value。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"github.com:cnAJun/cnAJun.github.io/tags/JAVA/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"github.com:cnAJun/cnAJun.github.io/categories/编程语言/"}]}]}