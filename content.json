{"meta":{"title":"阿俊的博客","subtitle":"bug终结者","description":null,"author":"ChinaArJun","url":"github.com:ChinaArJun/ChinaArJun.github.io.git"},"pages":[{"title":"关于","date":"2018-11-29T14:33:06.000Z","updated":"2018-11-29T14:34:53.221Z","comments":true,"path":"about/index.html","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/about/index.html","excerpt":"","text":"AJiOS and Java Developer GitHub: https://github.com/ChinaArJun"},{"title":"categories","date":"2018-11-22T02:22:00.000Z","updated":"2018-11-29T14:30:57.003Z","comments":false,"path":"categories/index.html","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-29T14:27:03.000Z","updated":"2018-11-29T14:27:26.252Z","comments":true,"path":"tags/index.html","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MAC【解决Mac版本 Sublime text3安装Package Control问题】","slug":"02web解决Mac版本 Sublime text3安装Package Control问题","date":"2018-11-29T14:12:14.000Z","updated":"2018-11-29T14:12:23.083Z","comments":true,"path":"2018/11/29/02web解决Mac版本 Sublime text3安装Package Control问题/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/02web解决Mac版本 Sublime text3安装Package Control问题/","excerpt":"","text":"准备学习Weex开发，因为使用sublime比较方便轻量，就在这个上面安装些插件吧。其实自己遇到了较多的坑，还是不仔细哈哈1.下载Sublime3https://www.sublimetext.com/3 2.安装Package Control在线安装： https://packagecontrol.io/installation 因为网络原因可能失败。 离线安装： 下载地址： https://github.com/wbond/package_control 1.把下载好的zip包解压，重命名为Package Control。 2.打开Sublime3 菜单-&gt;Preferences-&gt;Browse Packages...然后复制Package Control文件夹到该目录、 MAC版本注意： Mac位置:/Users/用户名/Library/Application Support/Sublime Text 3/Installed Packages 3.重启Sublime3,如果菜单-&gt;Preferences有Package Setting和Package Control就说明安装成功。 4.Ctrl+Shift+p输入install选中Install Package回车就可以安装插件。 然后，你会发现遇到问题，也许是“There Are No Packages Available For Installation” 不要慌张 网上说了挺多原因，简单例举一下： 1、IPV6的问题 2、无法打开网址[https://packagecontrol.io/channel_v3.json](https://packagecontrol.io/channel_v3.json)导致访问不了 简单试一下都不行，最后我经过实验得出原因是：官方提供的Package Control就是不能用。将官方的那个Package Control删除了，自己进行添加Package Control便可以了！ 具体步骤： 1、Package Control下载网址：[Package Control下载链接](https://github.com/wbond/sublime_package_control) 下载之后将其解压后，将解压文件重新命名为：Package Control 严格按照上面明明，首字母记住要大些！！！ 2、打开Sublime，点击：首选项-&gt;浏览程序包，便会打开一个文件夹！ 然后删除这个文件夹中已有的”Package Control文件夹”，将刚才自己下载好的并且重新命名的Package Control复制到该文件夹下，然后重新启动Sublime，这样便可以使用Package Control来安装其他插件了！ 这样就能解决问题了。然后安装自己想要的插件。各种高亮都没有问题","categories":[],"tags":[],"keywords":[]},{"title":"APP【移动动态化方案在蜂鸟的架构演进（含React Native与Weex对比）】","slug":"APP【移动动态化方案在蜂鸟的架构演进（含React-Native与Weex对比）】","date":"2018-11-29T14:07:44.000Z","updated":"2018-11-29T14:07:45.386Z","comments":true,"path":"2018/11/29/APP【移动动态化方案在蜂鸟的架构演进（含React-Native与Weex对比）】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/APP【移动动态化方案在蜂鸟的架构演进（含React-Native与Weex对比）】/","excerpt":"","text":"最近在准备学习一门跨平台语言时候表示很纠结，学习一门语言时间紧迫， 必须学到有用又适应市场的一门语言 直到看到这篇文章后就恍然大悟了，刚好饿了么也是一路采坑过来的，必须借鉴学习一下，说明最值得学习的还是阿里系Weex，体验什么的也比RN要好不少 当下，移动动态化已经成为各大公司都回避不了的问题，产品的快速迭代对技术提出了更高的要求，而移动端的动态化方案也是层出不穷：Hypid、结构化 Native View、React Native、Weex，什么样的方案才是适合自己团队的呢？本文将分享饿了么蜂鸟团队在过去两年多业务快速增长过程中，移动动态化方面的实践和探索。 什么是移动动态化？移动指的是移动端，包括安卓、iOS。动态化则是动态部署和逻辑下发到客户端的能力。移动动态最好的状态就是让移动应用和 Web 一样，想发就发！ 为什么移动端要强调动态化的能力？ 原因有如下三大点： 业务迭代太快。当下大部分团队都是敏捷开发的模式，即使两周做一次迭代，产品周期还是会觉得长，有些应用不能及时上线。 应用市场审核慢。安卓基本当天发应用市场，当天就能够有更新。但 iOS 需要约 3-4 天来审核。假设有些功能需要定时上线，iOS 审核时间必须要考虑进去。 用户升级周期长。统计表明，每一个安卓版本发布，一周内会有 70% 的用户更新，一个月其余用户才能陆续完成更新。 移动动态化方案共性，有如下三点： 跨平台。 布局。约定 DSL，保证渲染性能。 逻辑。Android 和 iOS 必须共用解释器。 蜂鸟团队的现状与业务特点蜂鸟团队现状 蜂鸟团队于 2014 年成立，初衷是为了承接饿了么的物流业务。随着时间推移，订单量从每日几千单到百万单，配速员也达到百万数量，服务品类涉及外卖、商超、鲜花、蛋糕、文件等，蜂鸟提供全时段配送，配送服务覆盖全国 1200 多个城市。 蜂鸟团队的业务特点 蜂鸟团队的业务主要有离散性和突发性两大特点，如下图： [图片上传中…(image-bdf201-1522679509307-23)] 从业务曲线可以看到两个很明显的波峰，这是午、晚用餐时间。同时，如果运营方面配置一些活动，会导致这两个波峰徒增。所以，动态方案要想把这两个时间段服务好，必须要考虑流量陡增下的性能压力。 蜂鸟团队的技术特点和挑战蜂鸟团队的技术特点和挑战，我主要分享重度依赖、网络环境复杂、重度使用和 28 定律这四个方面。 重度依赖 当前蜂鸟有众包、团队和送送三部分业务，右侧是一些功能展示，如下图： [图片上传中…(image-a9c71a-1522679509305-22)] 这样的工具型应用，需要对 APP 有更强的控制、监控等能力。必要时还要做到强制更新。 对应到动态方案的话，控制能力就需要动态方案必须具备动态降级的能力、监控能力，实时的性能监控和业务埋点监控。强制更新方面，动态方案必须做到用户无感知的热更新。 网络环境复杂 饿了么小哥，每天穿梭在大街小巷、地下商超，他们的网络环境非常不稳定。据统计，有近 25% 的用户请求还来自非 4G 环境。 整体来说的网络环境复杂、信号差和 DNS 污染，那么动态方案就要解决 DNS 拦截、弱网环境下资源下发等问题。 重度使用 无论是下雨、下雪，还是发洪水大家都会叫饿了么。 配送员在高峰期的运动曲线，如下图： 面对这样争分夺秒的准时达压力，如果动态方案不给力，会导致应用出现崩溃或卡顿，骑手必定不会有好的体验，甚至影响送餐时间。所以我们的动态方案一定要保证性能和稳定性。 28定律 相信很多公司的应用都符合类似 28 定律，蜂鸟也不例外。 如下图，蜂鸟的 28 定律： 可以从图中看出，大部分骑手日常使用的主流层面，可以采用 Native 来开发，这部分重度使用的占比约 20%，其余 80% 的功能都可以考虑动态化方案（H5）。 蜂鸟团队的动态化架构演进蜂鸟的动态方案经过 Hypid、React Native 和 Weex 三个主要阶段。 第一阶段：Hypid 在 Hypid 方案上，以 H5 的动态性为基础，通过 Jspidge 做桥梁，与 Native 进行通信，之后通过 URL Router 进行跳转，架构如下图： 这套动态方案的优点显而易见，这里主要介绍开发效率、更新体验和跨平台三方面： 开发效率。Web 经过多年的应用实践，已经拥有完整的开发流程和开发工具，开发一个 H5 页面非常快速。开发效率这一因素不能忽略，因为初期产品的想法和落地速度会直接影响产品的命运。 如蜂鸟送送，初期没有原生的资源去支撑，就用原生包壳，内部全部用 H5，这样的情况坚持了两月左右，为蜂鸟送送前期的方案验证做了很大的贡献。 更新体验。因 H5 和原生耦合只有扩展的 Native API，只要把这些 API 维护足够全，开发的业务功能就可以在完全不用更新 APK 的情况下，做到热更新。且用户下一次打开应用是最新的，这和 Native 的升级体验相比简直是一天一地。 跨平台。之前安卓和 iOS 代码需要开发两次，现在一个功能决定用 H5 后，由一个工程师来开发一套代码即可。 这套动态方案很大的缺点就是用户体验差，当用 H5 做一些复杂的功能或动画时，可能会卡顿的和 PPT 一样。因为 H5 的体验问题，蜂鸟的原则是经常更新的且功能不复杂的页面会选择用 H5。 第二阶段：React Native 这个动态方案完全脱离了以 H5 为基础的 Hypid 方案，通过自定义 DSL 将 UI 渲染成原生控件，这样一来， RN 的页面就保证了原生的体验和 Web 的效率。 除了上一点，还有组件化开发、复用率高、Android 和 iOS 95% 的代码共用和测试效率高等优点。 鉴于这些优点，蜂鸟在 React Native 上做了很多事情，如 Crash 优化、基础控件沉淀、Bundle+ 图片热更新、首屏加载优化和 Redux 单项数据流等。 正当享受 React Native 带来的开发体验和应用体验提升时，蜂鸟遇到 RN 的一些痛点，如 ScrollView 性能、Bundle 包过大、很多优化都需要修改源码和 peaking change 等。 第三阶段：WEEX 面对如上这些痛点，不知如何应对时，WEEX 来了。官方宣传的轻量、可扩展和高性能等特点，让蜂鸟团队眼前一亮。 经深入研究后，蜂鸟发现 WEEX 和 React Native 如出一辙，那么为什么要选择类似的方案呢？ 我们队 WEEX 和 React Native 两者基于 JS 引擎、语法、数据流、性能、开发体验及热更新等维度进行了对比。 如下图，是 WEEX 和 React Native JS 引擎对比： React Native 在安卓和 iOS 使用的都是 JsCore，WEEX 在安卓端使用的是 UC 精简版 V8。如上图中的图表可以看出，V8 相比 JsCore 要胜一筹。 WEEX 和 React Native 语法对比。语法方面，React Native 使用的是 React，WEEX 使用的是 Vue。虽然两套方案都实现了如响应式，组件化、状态管理等功能。 如下图，是两者简单 Demo 的实践： 实践发现，WEEX 相比 React Native 要优雅一些，是因为 Vue 有很多自定义标签，当在做一些 UI 和逻辑交杂在一起时，会让代码简洁很多。 WEEX 和 React Native 的数据流对比，React Native 使用 Redux，而 WEEX 使用 Vuex，不是 WEEX 不能使用 Redux，而是 Vuex 更适合 WEEX。 如下图，是两者的数据流，大同小异： 但 Vuex 在实现一些计算属性时，能在更细的颗粒度去更新 UI，而 Redux 只能实现到组件的级别，这样的点很多的话会带来性能上的差异。 如下图，是 WEEX 和 React Native 的性能对比，左侧是 WEEX 官方给出的与 React Native 在性能方面的对比图： 在渲染时间和内存占用方面 WEEX 要优于 React Native，在 CPU 占用方面两者相差不大，FPS 上 WEEX 要稍逊于 React Native。 在 ListView Android 方面，React Native 目前采用 ScrollView，WEEX 使用 Recyclerview 实现，性能稍好。 同时 WEEX 在增强开发、指定线程、首屏渲染和性能监控等方面也做了优化。 如下图，是 WEEX 和 React Native 的开发体验对比： 和 React Native 相比，WEEX 在打包、监控性能、跨平台等方面都有一定优势。总体来说，React Native 更像是一个技术框架，WEEX 更像是一个业务框架。 如下图，是 WEEX 和 React Native 的热更新对比： React Native 与 WEEX 官方都表示支持热更新，但他们的实现方式不同。在 React Native 上可通过把图片打包下发到本地来实现更新。 WEEX 有两个方法，一是选择本地资源加载，二是像网页一样直接加载页面。 如下图，是 React Native 与 WEEX 的对比总结： React Native 更像一个先驱者，拥有超强的社区人气，但也因开源社区维护代码的原因处于一个野蛮生长的状态。而 WEEX 是站在 React Native 的肩膀上，做了各种微创新，实现更多贴心的小细节。 基于 WEEX 性能、稳定性等方面都比 React Native 高，蜂鸟决定把动态化方案往 WEEX 上迁移，虽然它现在还有不足，有些轮子还是要自己去做。 蜂鸟团队 WEEX 实践凭借之前 React Native 相关的实践经验，基于 WEEX 做了一套更完整的动态方案。涉及以下几个方面，如下图： 统一的pidge 在 Android &amp; iOS 端，约定相同的方法名、参数，在 JS 层抹平平台差异以及统一分类管理暴露给业务的 API。 把这样的统一 pidge 方案提供给业务部门，他们只需关心暴露的 API，而不需要关心下一层平台的兼容，大大提升开发效率。 加载更新策略 加载更新方面，我们约定了一套自有协议，有 Page、URL 和 Tag，通过封装的 Router，就可以做到页面级的跳转。 这样一来，我们很轻松地做到了页面的跳转、解耦和页面的降级。当页面出现问题，只需要把 URL 改成降级之后的 H5 页面下发即可，用户触及到的就是修复之后的 H5 页面了。 如下图，是预加载策略： 当 H5 页面下发到客户端之后，会对本地资源进行检查，如果有 JS 文件，就忽略，没有的话就把页面下载。当用户打开页面，再去看本地，存在资源的话直接加载，不存在的话就即时下载再运行，与传统的 Web 流程相似。 性能监控 性能监控用来判断线上服务是否正常，是整套方案最重要的部分。 WEEX 可以很方便地将所有的参数全部拿到且通过反射拿到所有的性能数据传到云端。 基于这些数据，我们就可以知道线上有了哪些页面，它的渲染是否有问题。基于这些问题，就可做相应的优化。 如下图，是线上的数据情况： 监控三个指标，分别是 JS 引擎的初始化时间、页面打开时间和网络时间。因大部分 WEEX 页面都是业务，所以说业务埋点必不可少。饿了么也实现了一套框架，将业务埋点传给服务端，然后方便产品去制定一些产品方面的策略。 JS 的错误统计 可以捕捉 JS 端抛出的错误，如果所处团队是前端主导，可传给前端。如果是 Native 主导，可通过搜集平台将这些崩溃上传，在后台看到这些错误之后，找到相应的代码去修复。 Native 的错误 有了 JS 错误，Native 错误也不能忽略。 如下图，是 WEEX 动态方案上线一周之后线上抛的错误： 从图中可以看到都是个位数，这一点其实当时也很惊讶，WEEX 确实做得很稳定，这一点超出预料。 共用组件和 API 之前蜂鸟在 React Native 上面的一些实践，积累了一些很常用的组件和 API。WEEX 和 React Native 都是使用 JS 实现，所以我们很方便的将 RN 的控件转化为 WEEX 控件。 如下图，是实现的组件和 API，几乎可以满足中小团队的日常使用： 调试工具 这方面 WEEX 做的很贴心，虽然没有整合到整个初始化的项目中，但开源了几个库，可把代码拷贝到业务中进行使用。 WEEX 还可支持 Debug 模式显示调试工具、支持 hot reload、方便的查看性能指标和 Shell 脚本一键打包等功能。 综上所述，基于这些维度实现的框架，可以方便的让业务来使用。 如下，是饿了么和蜂鸟用 WEEX 实现的两个页面： 饿了么的第二个发现页面，就是基于 WEEX。蜂鸟 APP 可能大家接触不到，上图是当前通知的活动界面，还有大量的新功能正在接入。 如果你正在考虑 WEEX 与 React Native 方案，或是正在接入 React Native。看到这篇文章，你可以去调研以下 WEEX 方案，可能你会有另一种选择。 以上内容根据许锦洋老师在 WOTA2017 “移动端架构演进”专场的演讲内容整理。 负责饿了么蜂鸟 APP 的架构、研发等工作。拥有饿了么商家、风行者、蜂鸟众包等多款 APP 开发工作经历，并从 0 开始架构和开发了整个蜂鸟团队 APP。目前关注的技术方向为移动跨平台技术方案、移动端架构、移动端性能优化等。 【转载 51CTO原创稿件】","categories":[],"tags":[],"keywords":[]},{"title":"JAVA【老司机专属 Lombok超便捷工具介绍及使用方法】","slug":"JAVA【老司机专属-Lombok超便捷工具介绍及使用方法】","date":"2018-11-29T14:06:43.000Z","updated":"2018-11-29T14:06:44.207Z","comments":true,"path":"2018/11/29/JAVA【老司机专属-Lombok超便捷工具介绍及使用方法】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【老司机专属-Lombok超便捷工具介绍及使用方法】/","excerpt":"","text":"Lombok介绍及使用方法 lombok简介lombok是一个非常好用的小工具，刚见到的时候就感觉非常惊艳，有一种相见恨晚的感觉，用了一段时间之后感觉的确挺不错，所以特此来推荐一下。lombok的官方地址：https://projectlombok.org/lombok的Github地址：https://github.com/rzwitserloot/lombok那么lombok到底是个什么呢，lombok是一个可以通过简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 Java 代码的工具，简单来说，比如我们新建了一个类，然后在其中写了几个字段，然后通常情况下我们需要手动去建立getter和setter方法啊，构造函数啊之类的，lombok的作用就是为了省去我们手动创建这些代码的麻烦，它能够在我们编译源码的时候自动帮我们生成这些方法。lombok能够达到的效果就是在源码中不需要写一些通用的方法，但是在编译生成的字节码文件中会帮我们生成这些方法，这就是lombok的神奇作用。虽然有人可能会说IDE里面都自带自动生成这些方法的功能，但是使用lombok会使你的代码看起来更加简洁，写起来也更加方便。lombok安装lombok的安装跟一般引用jar包没有什么区别，可以到官网上下载最新的jar包，然后导入到项目里面就好啦。Maven添加依赖 org.projectlomboklombok1.16.10 Intellij idea开发的话需要安装Lombok plugin，同时设置 Setting -&gt; Compiler -&gt; Annotation Processors -&gt; Enable annotation processing勾选。lombok使用lombok使用过程中主要是靠注解起作用的，官网上的文档里面有所有的注解，这里不一一罗列，只说明其中几个比较常用的。@NonNull: 可以帮助我们避免空指针。使用lombok：import lombok.NonNull; public class NonNullExample extends Something {private String name; public NonNullExample(@NonNull Person person) {super(“Hello”); this.name = person.getName();}} 不使用lombok：public class NonNullExample extends Something { private String name; public NonNullExample(@NonNull Person person){ super(“Hello”);if (person == null) { throw new NullPointerException(“person”); } this.name = person.getName();}} @Cleanup: 自动帮我们调用close()方法。使用lombok：import lombok.Cleanup;import java.io.*;public class CleanupExample {public static void main(String[] args) throws IOException {@Cleanup InputStream in = new FileInputStream(args[0]); @Cleanup OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[10000];while (true) { int r = in.read(b); if (r == -1) break; out.write(b, 0, r);} }} 不使用lombok：import java.io.*; public class CleanupExample {public static void main(String[] args) throws IOException {InputStream in = new FileInputStream(args[0]); try {OutputStream out = new FileOutputStream(args[1]); try { byte[] b = new byte[10000]; while (true) {int r = in.read(b); if (r == -1) break; out.write(b, 0, r);} } finally { if (out != null) {out.close();} } } finally {if (in != null) { in.close();} } }} @Getter / @Setter: 自动生成Getter/Setter方法使用lombok：import lombok.AccessLevel; import lombok.Getter; import lombok.Setter; public class GetterSetterExample {@Getter @Setter private int age = 10; @Setter(AccessLevel.PROTECTED) private String name; } 不使用lombok：public class GetterSetterExample { private int age = 10; private String name; public int getAge() { return age;} public void setAge(int age) {this.age = age; }protected void setName(String name) { this.name = name; }} @NoArgsConstructor: 自动生成无参数构造函数。@AllArgsConstructor: 自动生成全参数构造函数。@Data: [自动为所有字段添加@ToString] @Test public void test1() { // 自动生成日志对象 log.debug(“sss”); } 还有其他一些比如自动生成日志对象等等之类的注解可以到官方网站去了解，就不一一列举了。官方文档https://projectlombok.org/features/index.html","categories":[],"tags":[],"keywords":[]},{"title":"JAVA【手把手教你整合最简洁的SSM框架：SpringMVC + Spring + MyBatis】","slug":"JAVA【Java-—-手把手教你整合最简洁的SSM框架：SpringMVC-Spring-MyBatis】","date":"2018-11-29T14:06:19.000Z","updated":"2018-11-29T14:06:21.823Z","comments":true,"path":"2018/11/29/JAVA【Java-—-手把手教你整合最简洁的SSM框架：SpringMVC-Spring-MyBatis】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【Java-—-手把手教你整合最简洁的SSM框架：SpringMVC-Spring-MyBatis】/","excerpt":"","text":"手把手教你整合最简洁的SSM框架：SpringMVC + Spring + MyBatis快速预览地址：http://120.24.96.44/AJ-crm/customer/list.actionGitHub地址: https://github.com/ChinaArJun/Online-CRM121.介绍 ~ Project introduction项目整体使用SSM框架：SpringMVC + Spring + MyBatis WEB层加入了bootstrap框架，视觉效果非常棒 1232.下载项目 ~ Download projectgit clone [https://github.com/ChinaArJun/Online-CRM.git](https://github.com/ChinaArJun/Online-CRM.git) 下载项目后需要导入sql文件,更改MySql用户名和密码即可 3.预览 ~ Preview picture","categories":[],"tags":[],"keywords":[]},{"title":"JAVA【使用Mybatis-Generator自动生成Dao、Model、Mapping相关文件】","slug":"JAVA【使用Mybatis-Generator自动生成Dao、Model、Mapping相关文件】","date":"2018-11-29T14:06:01.000Z","updated":"2018-11-29T14:06:01.195Z","comments":true,"path":"2018/11/29/JAVA【使用Mybatis-Generator自动生成Dao、Model、Mapping相关文件】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【使用Mybatis-Generator自动生成Dao、Model、Mapping相关文件】/","excerpt":"","text":"用generatorsqlmapcustom对数据库进行逆向工程，生成接口和xml，还有实体 1 首先下载generatorsqlmapcustom 2 导入工程 3 配置用户名密码 4 配置映射信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/taotao&quot; userId=&quot;root&quot; password=&quot;123&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.taotao.pojo&quot;&lt;!-- 指定位置 ：最好直接指定根目录,以免出现生成不出文件的情况 --&gt; &lt;targetProject=&quot;/Users/pro/Desktop/Java/javaEE28/generatorSqlmapCustom/src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.taotao.mapper&quot; &lt;!-- 指定位置 ：最好直接指定根目录,以免出现生成不出文件的情况 --&gt;&lt;targetProject=&quot;/Users/pro/Desktop/Java/javaEE28/generatorSqlmapCustom/src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.taotao.mapper&quot; &lt;!-- 指定位置 ：最好直接指定根目录,以免出现生成不出文件的情况 --&gt; &lt;targetProject=&quot;/Users/pro/Desktop/Java/javaEE28/generatorSqlmapCustom/src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_content&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_content_category&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_cat&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_desc&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_param&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_param_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order_shipping&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_user&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 5 运行生成 Mybatis属于半自动ORM，在使用这个框架中，工作量最大的就是书写Mapping的映射文件，由于手动书写很容易出错，我们可以利用Mybatis-Generator来帮我们自动生成文件。","categories":[],"tags":[],"keywords":[]},{"title":"JAVA【SpringMVC+Swagger UI生成可视图的API文档（详细图解）】","slug":"JAVA【SpringMVC-Swagger-UI生成可视图的API文档（详细图解）】","date":"2018-11-29T14:05:44.000Z","updated":"2018-11-29T14:05:45.031Z","comments":true,"path":"2018/11/29/JAVA【SpringMVC-Swagger-UI生成可视图的API文档（详细图解）】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【SpringMVC-Swagger-UI生成可视图的API文档（详细图解）】/","excerpt":"","text":"Swagger UI关于Swagger UI官方解释是这样的：The Swagger UI is an open source project to visually render documentation for a Swagger defined API directly from the API’s Swagger specifcation 官网地址 下面是官方的效果图： 我将上图分成了两部分文档地址：从改地址请求数据，获取JSON格式数据，交给第二步显示API文档显示：将JSON数据转化成可视图的效果 Swagger可以将某种固定格式的JSON数据生成可以视图的在线API文档，支持在线测试，可以清楚的观察到IO数据。SpringMVC + Swagger目的：在原有的SpringMVC系统中添加Swagger，通过在接口上添加注解实现，接口文档的同步效果。 下图为我实现之后的效果： 项目搭建我的工具：Eclipse开发工具（安装spring插件，当然也可以不要，就是麻烦点）,Maven，Tomcat，Internet访问，Chrome浏览器 1.创建Simple Spring Web Maven工程 右键New-&gt;Spring Project，选择对应类型，finish, 如下图：[图片上传中。。。（3）] 我的工程的结构，注意那两个配置文件，名称不重要，可以随便改，注意要对应好web.xml中的名称就行。[图片上传中。。。（4）] 想了想还是把三个配置文件贴出来吧。 web.xml&lt;?xml version=”1.0” encoding=”ISO-8859-1”?&gt; SwaggerDemo contextConfigLocation classpath:spring/application-config.xml org.springframework.web.context.ContextLoaderListener dispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/mvc-config.xml 1 dispatcherServlet / 12345678910111213141516171819202122232425262728293031323334353637383940414243 12345678910111213141516171819202122232425262728293031323334353637383940414243 application-config.xml&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 12345678910111213 12345678910111213 mvc-config.xml&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;mvc:annotation-driven /&gt; 1234567891011121314151617181920212223 1234567891011121314151617181920212223 这样配置到后面配置Swagger会出现无法自动注入的问题，后面再说，以上为工具自动生成的代码。2.添加Swagger-Spring MVC包、JSON和jackson pom.xml文件中 properties标签里面添加jackson版本号 &lt;version.jackson&gt;2.4.4&lt;/version.jackson&gt; 1 1 dependencies标签中添加 com.mangofactory swagger-springmvc 0.9.5 net.sf.json-lib json-lib 2.4 jdk15 com.fasterxml.jackson.core jackson-annotations ${version.jackson} com.fasterxml.jackson.core jackson-databind ${version.jackson} com.fasterxml.jackson.core jackson-core ${version.jackson} 1234567891011121314151617181920212223242526272829 1234567891011121314151617181920212223242526272829 3.下面是重点，Swagger所有API文档都在这里存储，添加Swagger配置类 创建一个配置类MySwaggerConfig，添加私有成员SpringSwaggerConfig，set方法使用@Autowired注解自动注入，使用@Bean注解添加SwaggerSpringMvcPlugin，并使用自定义的ApiInfo，SwaggerConfig类需要添加@Configuration以及@EnableSwaggerpackage com.edu.xk;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import com.mangofactory.swagger.configuration.SpringSwaggerConfig;import com.mangofactory.swagger.models.dto.ApiInfo;import com.mangofactory.swagger.plugin.EnableSwagger;import com.mangofactory.swagger.plugin.SwaggerSpringMvcPlugin;@Configuration@EnableSwagger@EnableWebMvcpublic class MySwaggerConfig { private SpringSwaggerConfig springSwaggerConfig; / Required to autowire SpringSwaggerConfig / @Autowired public void setSpringSwaggerConfig(SpringSwaggerConfig springSwaggerConfig) { this.springSwaggerConfig = springSwaggerConfig; } / Every SwaggerSpringMvcPlugin bean is picked up by the swagger-mvc framework - allowing for multiple swagger groups i.e. same code base multiple swagger resource listings. / @Bean public SwaggerSpringMvcPlugin customImplementation() { // 暂时不用过滤 /return new SwaggerSpringMvcPlugin(this.springSwaggerConfig).apiInfo(apiInfo()).includePatterns(“.pet.“);/ return new SwaggerSpringMvcPlugin(this.springSwaggerConfig).apiInfo(apiInfo()); } private ApiInfo apiInfo() { ApiInfo apiInfo = new ApiInfo( “My Apps API Title”, “My Apps API Description”, “My Apps API terms of service”, “My Apps API Contact Email”, “My Apps API Licence Type”, “My Apps API License URL” ); return apiInfo; }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 官方原话： The @EnableSwagger annotation, in this example, enables swagger-springmvc out of the box. The generated swagger json Resource Listing is available at /api-docs 4.添加Controller:WebServiceForCSS，Swagger文档在此处添加package com.edu.xk.webservice;import javax.servlet.http.HttpServletRequest;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import com.edu.xk.model.User;import com.wordnik.swagger.annotations.ApiOperation;import com.wordnik.swagger.annotations.ApiParam;import net.sf.json.JSONObject;/* @moudle: WebServiceForCSS @version:v1.0 @Description: TODO @author: xukai @date: 2016年12月1日 下午5:37:30 /@Controllerpublic class WebServiceForCSS { @ResponseBody @RequestMapping(value = “getUserById”, method = RequestMethod.GET, produces = {“application/json; charset=utf-8”,”application/xml”}) @ApiOperation(value = “通过ID查询USER信息”, httpMethod = “GET”, notes = “暂无”) public String getUserById( @ApiParam(required = true, name = “id”, value = “ID”) @RequestParam(value = “id”) String id,HttpServletRequest request) { User user = new User(); user.setId(id); user.setName(“测试人员”); user.setAge(25); JSONObject object = JSONObject.fromObject(user); return object.toString(); }} 123456789101112131415161718192021222324252627282930313233343536373839404142 123456789101112131415161718192021222324252627282930313233343536373839404142 5.配置文件修改 context加载的时候需要配置的文件，此处配置文件为application-config.xml&lt;mvc:annotation-driven /&gt; &lt;context:component-scan base-package=”com.edu”/&gt; 123 123 6.下载Swagger UI组件 去官网下载Zip包，或者在github上下载也可以，需要将dist文件夹下的所有文件的复制到webapp目录下。7.修改Project Properties 将jdk1.5换成最新的本地的jdk,对应的Java complier也改为对应的，还有maven包依赖也需要添加，不然启动的时候会找不到ContextLoader.class。8.添加拦截器，不然无法访问.html后缀文件，在web.xml中添加 default .jpg default .png default .gif default .ico default .js default .css default .html default .xls default .doc default .json default .eot default .svg default .ttf default .woff default *.woff2 index.html index.htm index.jsp default.html default.htm default.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 运行项目，可以看到效果图： [图片上传中。。。（5）]可以看到，现在效果还是和官网上一样的。改为自己的API文档可以通过修改index.html中的url = “http://petstore.swagger.io/v2/swagger.json&quot;;或者直接修改访问的地址栏为：http://localhost:8080/SwaggerDemo/api-docs原理分析SpringMVC+Swagger其实就是在系统加载的时候，Swagger配置类去扫描所有添加注释的接口，并且储存起来通过下面地址进行访问，返回JSON数据，在前端界面显示出来 [图片上传中。。。（6）] 这里我在网上看到一个汉化的版本（原效果），下载了他工程，将他生成demo.json放入的我的工程中的webapp目录下，下面是效果图 [图片上传中。。。（7）]遇到的问题问题1：下载maven的jar包中途失败，工程会出错maven missing 解决方法：选中Project-&gt;右键maven-&gt;update project-&gt;选中Force update 如果此时依然有 missing的jar，按照 buildpath 提示的 jar包missing 路径，去 maven 本地仓库中对应位置（jar包后面有路径），删掉 该 jar 包的 xxx.lastUpdated 文件，之后，再重新执行 项目右键maven-&gt;update project问题2：缺失jackson包会导致出现异常java.lang.NoClassDefFoundError: com/fasterxml/jackson/databind/ObjectMapper)问题3：java.lang.ClassNotFoundException: org.springframework.web.util.Log4jConfigListen，因为工程没有引入maven中的jar包，解决办法：选中工程右键-&gt;Properties-&gt;Deployment Assembly-&gt;add-&gt;Java Build Path Entries-&gt;Maven Dependencies-&gt;OK问题4：org.springframework.beans.factory.BeanCreationException，出现这个异常是因为SpringSwaggerConfig的私有成员RequestMappingHandlerMapping造成的，将&lt;mvc:annotation-driven /&gt;放入到web.xml的context-param标签对应的配置文件application-config.xml中，完美解决，官网解释该标签作用为： Required so swagger-springmvc can access spring’s RequestMappingHandlerMapping 。org.springframework.beans.factory.NoSuchBeanDefinitionException: Noqualifying bean of type[org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping]found for dependency [collection oforg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping]:expected at least 1 bean which qualifies as autowire candidate forthis dependency. Dependency annotations:{@org.springframework.beans.factory.annotation.Autowired(required=true)} 12345678 12345678 Swagger UI开发帮助 Swagger Editor 反正顺路，顺便的Editor也写完，Editor个人感觉就是一个文档编辑器，感觉SosoApi还是好些。试着在Swagger官网下载了一个Swagger Editor跑着玩了玩.下载swagger-editor.zip，解压到Tomcat的webapps文件夹中，来看一下效果图 [图片上传中。。。（8）]Swagger UI结合Swagger Editor更好用，但是在线编辑那个太卡了，备份一个本地的，以备不时只需。Swagger UI关于Swagger UI官方解释是这样的：The Swagger UI is an open source project to visually render documentation for a Swagger defined API directly from the API’s Swagger specifcation 官网地址 下面是官方的效果图：","categories":[],"tags":[],"keywords":[]},{"title":"Mac【用OracleSQLDeveloper连接Windows虚拟机的Oracle数据库】","slug":"Mac【下用OracleSQLDeveloper连接Windows虚拟机的Oracle数据库】","date":"2018-11-29T14:04:34.000Z","updated":"2018-11-29T14:04:42.503Z","comments":true,"path":"2018/11/29/Mac【下用OracleSQLDeveloper连接Windows虚拟机的Oracle数据库】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/Mac【下用OracleSQLDeveloper连接Windows虚拟机的Oracle数据库】/","excerpt":"","text":"因为在OS X中无法安装Oracle数据库（除了雪豹系统）所以只能用虚拟机安装Oracle来替代。Mac OS X 10.6 Snow Leopard x64 (雪豹) 安装 oracle 虚拟机数据库和OS X之间的连接也没有说的很详细或者非常可行的教程，本文旨在帮助后继者来正确连接，免其麻烦。你需要的东西有：OracleSQLDeveloper For OS X以及已经安装好的Windows虚拟机和虚拟机上的Oracle数据库我使用的是PD11来装的Win8.1以及Oracle 11gR2 便捷版。 我们需要提前明白为什么我们尝试的经常失败：1、虚拟机和主机间的连接网络连接模式最好为桥接，侨接之后IP会发生改变，在这里必须要细心和清楚 2、虚拟机(Win)防火墙要关闭 3、监听程序默认的是localhost，需要配置才能监听远程接入的程序， 而我使用的便捷版数据库没有Oracle Net Manager，只能在listener.ora文件当中配置。 4、需要添加一个有远程登陆权限的用户 其中需要指明的是，主机名最好用IP地址来表示，而这个IP地址为数据库那个机器的IP地址，端口号一般都是1521 或者在listener.ora中有，其中地址和示例配置代码如下：C:\\oraclexe\\app\\oracle\\product\\11.2.0\\server\\network\\ADMIN\\listener.ora (记得更改读写权限，参照我上一篇博客) LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1)) (ADDRESS = (PROTOCOL = TCP)(HOST = MAC7F25)(PORT = 1521)) (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.100.103)(PORT = 1521)) ) ) MAC7F25是我的虚拟机名称，而192.168.100.103为虚拟机在桥接后的IP添加这行代码：(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.100.103)(PORT = 1521))","categories":[],"tags":[],"keywords":[]},{"title":"JAVA【在Eclipse中用JDBC连接MySQL数据库】","slug":"JAVA【在Eclipse中用JDBC连接MySQL数据库】","date":"2018-11-29T14:04:16.000Z","updated":"2018-11-29T14:04:16.842Z","comments":true,"path":"2018/11/29/JAVA【在Eclipse中用JDBC连接MySQL数据库】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【在Eclipse中用JDBC连接MySQL数据库】/","excerpt":"","text":"1.准备工作: 准备相关的软件 .MySQL 6.0下载地址:http://dev.mysql.com/downloads/mysql/6.0.html .mysql-connector-java-5.1.6.zip下载地址:http://dev.mysql.com/downloads/connector/j/5.1.html .SQLyog MySQL GUI - Enterprise 6.54 (Stable)(官网地址，不过需注册，也可以直接百度一下)下载地址:http://www.webyog.com/en/downloads.php 2.下载完之后开始进行安装 ,第一个是属于数据库软件,正常安装即可(端口默认3306，用户名root，当然也可以自己设置，建议默认安装) 将JDBC解压缩到任意位置,找出mysql-connector-java-5.1.6-bin.jar文件，放在一个固定目录下，后面进行MySQL数据库连接需要加载它，其它文件都可删除。 安装SQLyog6.54软件，这是一款非常好的可视化操作MySQL的工具。（当然你也可以使用自己最习惯的方式在MySQL中建立建立一个测试数据库）。打开刚刚安装好的 SQLyog6.54,点continue,再NEW一个新连接，这里需要用到刚才所说的用户名密码，默认用户名root，密码是自己设置，这里暂且用1234，端口号为3306（默认），如做修改就输入你修改后的端口。点连接，之后的操作就相对容易，再可视化的窗口下，右键新建一个数据库，这里建一个mydb数据库。 打开Eclipse a.新建工程-&gt; java -&gt; java project,起名为Test b.右键单击目录窗口中的Test, 选择Build Path -&gt;Configure Build Path…, 添加扩展jar文件,即把mysql-connector-java-5.1.6-bin.jar添加到其中,确定。 编写java代码来测试连接数据库程序代码:import java.sql.*;public class Test {public static void main(String[] srg) {String driverName = “com.mysql.jdbc.Driver”; //加载JDBC驱动String dbURL = “jdbc:mysql://localhost:3306/mydb”; //连接服务器和数据库sampleString userName = “root”; //默认用户名String userPwd = “1234”; //密码Connection dbConn;try {Class.forName(driverName);dbConn = DriverManager.getConnection(dbURL, userName, userPwd);System.out.println(“Connection Successful!”); //如果连接成功控制台输出Connection Successful!} catch (Exception e) {e.printStackTrace();}}}总结MySQL数据库的连接相对还是比较简单的，即使刚接触这方面的应用的，只要遵循这六步，半个小时内差不多都能搞定。以前在这方面走过不少弯路，今天特别高兴能跟大家分享我的经验，希望对您数据库连接方面的快速入门会有所帮助！","categories":[],"tags":[],"keywords":[]},{"title":"JAVA【有哪些适合新手练手的Java项目？】","slug":"JAVA【有哪些适合新手练手的Java项目？】","date":"2018-11-29T14:03:16.000Z","updated":"2018-11-29T14:03:16.652Z","comments":true,"path":"2018/11/29/JAVA【有哪些适合新手练手的Java项目？】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【有哪些适合新手练手的Java项目？】/","excerpt":"","text":"Java作为一门古老的语言，已有20年左右的历史，这在发展日新月异的技术圈可以说是一个神话。虽然不少人曾抱怨Java语言就像老太太的裹脚布，又臭又长，有时写了500行都不能表达程序员的意图。但从市场上的招聘现状看，Java工程师依然有着其他语言不可取代的竞争优势。招聘情况请参考：为 看到了这里，恭喜正式开始进入主题：适合新手练手的Java项目？ 源码下载（实例一）：jsp开发完整的博研图书馆后台管理系统，不使用框架开发的，太完美了源码下载（实例二）：javaWeb图书馆管理系统源码mysql版本源码下载（实例三）GitHub - uboger/LibraryManager: JAVA GUI 图书馆管理系统源码下载（实例四）：java swing开发企业人事管理系统源代码下载 源码下载（实例一）：java swing开发网络聊天室群聊系统,基于java多线程socket编程源码下载（实例二）：java swing开发大猫聊天室源码，简单易懂，适合java swing初学者源码下载（实例三）：java websocket开发简单聊天室系统，实现群聊与一对一单人聊天案例源码下载（实例四）：jsp开发简单聊天室demo-分享 源码下载（一）：java通讯录实现了添加删除和查找功能源码下载（二）：JAVA版通讯录管理系统课程设计源码源码下载（三）：Java Swing界面.完美设计通讯录..有需要的下 源码下载（一）：JAVA坦克大战+源代码（适合初学者）源码下载（二）：GitHub - wangzhengyi/TankWar: 用J2SE写的一个坦克大战小游戏，巩固一下java基础 源码下载（一）：俄罗斯方块 JAVA版源码下载（二）：GitHub - FieldSoft-HelloClyde/Tetris-Swing: Swing编写的俄罗斯方块源码下载（三）：java swing开发的俄罗斯方块游戏，包含完整代码+详细注释 源码下载（一）：Java实践（十一）——五子棋源码下载（二）：java swing开发的五子棋小游戏源码源码下载（三）：java swing开发单机版五子棋源代码下载源码下载（四）：Java五子棋算法和代码 源码下载（一）：Java实践（十二）——中国象棋 源码下载（实例一）：JAVA贪吃蛇源代码源码下载（实例二）：java swing编写的3个小游戏程序源码，俄罗斯方块，贪吃蛇和坦克大战源码下载（实例三）：java贪吃蛇源代码 、 java贪吃蛇源代码","categories":[],"tags":[],"keywords":[]},{"title":"JAVA【关于Eclipse不自动弹出提示的解决办法】","slug":"JAVA【关于Eclipse不自动弹出提示的解决办法】","date":"2018-11-29T14:03:01.000Z","updated":"2018-11-29T14:03:01.553Z","comments":true,"path":"2018/11/29/JAVA【关于Eclipse不自动弹出提示的解决办法】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【关于Eclipse不自动弹出提示的解决办法】/","excerpt":"","text":"Eclipse代码里面的代码提示功能默认是关闭的，只有输入“.”的时候才会提示功能Win配置和Mac配置基本一致. 用过其他编辑器的用户可能不太习惯这种，普遍编辑器是输入任何字母都会提示，下面说一下如何修改eclipse配置，开启代码自动提示功能打开 Eclipse -&gt; Window -&gt; Perferences -&gt; Java -&gt; Editor -&gt; Content Assist，在右边最下面一栏找到 auto-Activation ，下面有三个选项，找到第二个“Auto activation triggers for Java：”选项在其后的文本框中会看到一个“.”存在。 这表示：只有输入“.”之后才会有代码提示和自动补全，我们要修改的地方就是这。把该文本框中的“.”换掉，换成“abcdefghijklmnopqrstuvwxyz.”，这样，你在Eclipse里面写Java代码就可以做到按“abcdefghijklmnopqrstuvwxyz.”中的任意一个里字符都会有代码提示。 在编写代码时敲出几个字符的情况下就迅速地完成代码，那是一件很爽的事。可是默认情况下，eclipse只有在你打出’.’（点字符）的时候，才会弹出自动补全窗口给你选择。这在大部分时候是完全不够用的。 由于eclipse 本身有很多选项是默认关闭的，这样开发者只能自己去手动配置一下. 那么如何配置eclipse的代码自动提示功能呢？ 1、Window ——&gt; Preferences ——&gt; Java ——&gt; Editor ——&gt; Content Assist 1)将图中复选框勾上 2)将自动补全延迟的时间[auto activation delay(ms)]默认是200ms, 可以将时间缩短一些,比如我设置2ms. 3)[auto activation triggers for java]自动补全触发器,默认是”.”, 这个位置可以设置成26个字母外加’.’：.abcdefghijklmnopqrstuvwxyz(不区分大小写) 4)[auto activation triggers for javadoc]javadoc的触发器,默认是”@#”. 2、eclipse的代码自动提示功能设置成功后： #####可是eclipse不允许输入这么的字符，文本框中最多允许输入4个字符，因此要通过修改配置文件的方法实现，具体操作步骤如下 打开Eclipse，然后“window”→“Preferences” 选择“java”，展开，“Editor”，选择“Content Assist”。 3.选择“Content Assist”，然后看到右边，右边的“Auto Activation”下面的“Auto Activation triggers for java”这个选项。其实就是指触发代码提示的就是“.”这个符号。 4.“Auto Activation triggers for java”这个选项，在“.”后加abc字母，方便后面的查找修改。然后“apply”，点击“OK”。 然后，“File”→“Export”，在弹出的窗口中选择“General”→“Perferences”，点击“下一步”。 选择导出文件路径，本人导出到桌面，输入“abc”作为文件名，点击“保存”。 在桌面找到刚在保存的文件“abc.epf”,右键选择“用记事本打开”。 按“ctrl + F”快捷键，输入“.abc”，点击“查找下一个”。 查找到“.abc”的配置信息如下：如下： 把“.abc”改成“.abcdefghijklmnopqrstuvwxyz(,”，保存，关闭“test.epf”。 回到MyEclipse界面，“File”→“Import”，在弹出的窗口中选择“Perferences”，点击“下一步”，选 择刚在已经修改的“abc.epf”文件，点击“打开”，点击“Finish”。该步骤和上面 的导出步骤类似。 12.修改完毕，测试一下就行了。","categories":[],"tags":[],"keywords":[]},{"title":"JAVA【基于JAVA调用免费天气api接口示例】","slug":"JAVA","date":"2018-11-29T14:02:00.000Z","updated":"2018-11-29T14:02:39.901Z","comments":true,"path":"2018/11/29/JAVA/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA/","excerpt":"","text":"查询天气预报在APP中常用的一个常用功能，聚合数据免费天气api接口可以根据根据城市名/id查询天气、根据IP查询天气、据GPS坐标查询天气、查询城市天气三小时预报，并且支持全国不同城市天气预报查询。代码描述：基于JAVA的免费天气api接口调用示例，根据文档中注明的需求参数,调用接口返回数据。关联数据：免费天气api接口地址：https://www.juhe.cn/docs/api/id/39step1:选择本文所示例的接口”免费天气api” url:https://www.juhe.cn/docs/api/id/39/aid/87step2:每个接口都需要传入一个参数key,相当于用户的令牌,所以第一步你需要申请一个keystep3:看文档!!!学过java的同学们都知道,当我们对一个类或者方法不明白其意图和思想时,我们可以去查看文档,这里也不例外,而且对于英文不是特别好的同学来说很幸运的是,聚合网站上的文档都是中文版本的,比起阅读java源码里的英文文档应该轻松很多.全国天气预报接口下面有六个子接口,打开第一个接口链接,看文档发现需要传入一个城市名或者城市ID参数,这个参数我们可以通过第六个子接口获取(接口之间参数的调用类似于java中方法之间的调用),即支持城市列表获取.所以示例中我们先调用这个接口.调用接口涉及到请求网络资源的问题,这里我封装了一个工具类,包含GET和POST两种方法step4:上代码 Demo1:网络访问工具类(封装get和post方法)Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package juheAPI; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.net.HttpURLConnection; import java.net.URL; import java.util.Map; /** * 网络访问工具类 * @author silk * */ public class PureNetUtil &#123; /** * get方法直接调用post方法 * @param url 网络地址 * @return 返回网络数据 */ public static String get(String url)&#123; return post(url,null); &#125; /** * 设定post方法获取网络资源,如果参数为null,实际上设定为get方法 * @param url 网络地址 * @param param 请求参数键值对 * @return 返回读取数据 */ public static &lt;K, V&gt; String post(String url,Map&lt;K,V&gt; param)&#123; HttpURLConnection conn=null; try &#123; URL u=new URL(url); conn=(HttpURLConnection) u.openConnection(); StringBuffer sb=null; if(param!=null)&#123;//如果请求参数不为空 sb=new StringBuffer(); /*A URL connection can be used for input and/or output. Set the DoOutput * flag to true if you intend to use the URL connection for output, * false if not. The default is false.*/ //默认为false,post方法需要写入参数,设定true conn.setDoOutput(true); //设定post方法,默认get conn.setRequestMethod(&quot;POST&quot;); //获得输出流 OutputStream out=conn.getOutputStream(); //对输出流封装成高级输出流 BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out)); //将参数封装成键值对的形式 for(Map.Entry s:param.entrySet())&#123; sb.append(s.getKey()).append(&quot;=&quot;).append(s.getValue()).append(&quot;&amp;&quot;); &#125; //将参数通过输出流写入 writer.write(sb.deleteCharAt(sb.toString().length()-1).toString()); writer.close();//一定要关闭,不然可能出现参数不全的错误 sb=null; &#125; conn.connect();//建立连接 sb=new StringBuffer(); //获取连接状态码 int recode=conn.getResponseCode(); BufferedReader reader=null; if(recode==200)&#123; //Returns an input stream that reads from this open connection //从连接中获取输入流 InputStream in=conn.getInputStream(); //对输入流进行封装 reader=new BufferedReader(new InputStreamReader(in)); String str=null; sb=new StringBuffer(); //从输入流中读取数据 while((str=reader.readLine())!=null)&#123; sb.append(str).append(System.getProperty(&quot;line.separator&quot;)); &#125; //关闭输入流 reader.close(); if (sb.toString().length() == 0) &#123; return null; &#125; return sb.toString().substring(0, sb.toString().length() - System.getProperty(&quot;line.separator&quot;).length()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125;finally&#123; if(conn!=null)//关闭连接 conn.disconnect(); &#125; return null; &#125; &#125; Demo2:调用获取城市列表接口示例Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package juheAPI; import net.sf.json.JSONArray; import net.sf.json.JSONObject; /** * 获取城市列表 * 全国天气预报接口调用JAVA示例 * dtype string N 返回数据格式：json或xml,默认json * key string Y 你申请的key * @author silk * */ public class GetCityList &#123; /** * 调用获取城市列表接口,返回所有数据 * @return 返回接口数据 */ public static String excute()&#123; String url=&quot;http://v.juhe.cn/weather/citys?key=***a7558b2e0bedaa19673f74a6809ce&quot;;//接口URL //PureNetUtil是一个封装了get和post方法获取网络请求数据的工具类 return PureNetUtil.get(url);//使用get方法 &#125; /** * 调用接口返回数据后,解析数据,根据输入城市名得到对应ID * @param cityName 城市名称 * @return 返回对应ID */ public static String getIDBycityName(String cityName) &#123; String result=excute();//返回接口结果,得到json格式数据 if(result!=null)&#123; JSONObject obj=JSONObject.fromObject(result); result=obj.getString(&quot;resultcode&quot;);//得到返回状态码 if(result!=null&amp;&amp;result.equals(&quot;200&quot;))&#123;//200表示成功返回数据 result=obj.getString(&quot;result&quot;);//得到城市列表的json格式字符串数组 JSONArray arr=JSONArray.fromObject(result); for(Object o:arr)&#123;//对arr进行遍历 //将数组中的一个json个数字符串进行解析 obj=JSONObject.fromObject(o.toString()); /*此时obj如 &#123;&quot;id&quot;:&quot;2&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;city&quot;:&quot;北京&quot;,&quot;district&quot;:&quot;海淀&quot;&#125;*/ //以city这个key为线索判断所需要寻找的这条记录 result=obj.getString(&quot;district&quot;); //防止输入城市名不全,如苏州市输入为苏州,类似与模糊查询 if(result.equals(cityName)||result.contains(cityName))&#123; result=obj.getString(&quot;id&quot;);//得到ID return result; &#125; &#125; &#125; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(getIDBycityName(&quot;香港&quot;)); &#125; &#125; Demo3:调用根据城市名/id查询天气Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package juheAPI; import net.sf.json.JSONObject; /** * 根据城市名/id查询天气 * @author silk * */ public class WeatherReportByCity &#123; /** * 根据城市名获取 * @param cityName * @return */ public static String excute(String cityName)&#123; String url=//此处以返回json格式数据示例,所以format=2,以根据城市名称为例,cityName传入中文 &quot;http://v.juhe.cn/weather/index?cityname=&quot;+cityName+&quot;&amp;key=***a7558b2e0bedaa19673f74a6809ce&quot;; return PureNetUtil.get(url);//通过工具类获取返回数据 &#125; /** * 获取返回数据中的一个属性示例,此处以获取今日温度为例 * &quot;temperature&quot;: &quot;8℃~20℃&quot; 今日温度 * @param args * @return */ public static String GetTodayTemperatureByCity(String city) &#123; String result=excute(city); if(result!=null)&#123; JSONObject obj=JSONObject.fromObject(result); /*获取返回状态码*/ result=obj.getString(&quot;resultcode&quot;); /*如果状态码是200说明返回数据成功*/ if(result!=null&amp;&amp;result.equals(&quot;200&quot;))&#123; result=obj.getString(&quot;result&quot;); //此时result中数据有多个key,可以对其key进行遍历,得到对个属性 obj=JSONObject.fromObject(result); //今日温度对应的key是today result=obj.getString(&quot;today&quot;); obj=JSONObject.fromObject(result); //今日温度对应当key是temperature result=obj.getString(&quot;temperature&quot;); return result; &#125; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(GetTodayTemperatureByCity(&quot;苏州&quot;)); &#125; &#125; Demo4:调用天气种类及表示列表接口示例Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package juheAPI; import net.sf.json.JSONArray; import net.sf.json.JSONObject; /** * 天气种类及标识列表接口调用JAVA示例 * @author silk */ public class GetWeatherSignAndTypeList &#123; //接口地址,因为只需要传入一个固定的key为参数,所以设为常量 private static final String URL= &quot;http://v.juhe.cn/weather/uni?key=***a7558b2e0bedaa19673f74a6809ce&quot;; /** * 通过工具类获取数据 * @return */ public static String excute()&#123; return PureNetUtil.get(URL);//调用工具类获取接口数据 &#125; /** * 利用遍历数组的方式获取 * @param wid天气对应id * @return 天气名称 */ public static String getWeatherByWid(String wid) &#123; String result=excute();//获取接口数据 if(result!=null)&#123; JSONObject obj=JSONObject.fromObject(result); result=obj.getString(&quot;resultcode&quot;); /*获取返回状态码*/ if(result!=null&amp;&amp;result.equals(&quot;200&quot;))&#123; /*获取数组数据*/ result=obj.getString(&quot;result&quot;); JSONArray arr=JSONArray.fromObject(result); for(Object o:arr)&#123;//遍历数组 obj=JSONObject.fromObject(o.toString()); //如果遍历到需要的数据后直接返回结果,根据key(wid)得到value判断是否等于传入参数 if(obj.getString(&quot;wid&quot;).equals(wid))&#123; result=obj.getString(&quot;weather&quot;); return result; &#125; &#125; &#125; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(getWeatherByWid(&quot;10&quot;)); &#125; &#125; step5:调用接口时候如果状态码不是200,仔细参考文档说明!","categories":[{"name":"JAVA","slug":"JAVA","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/tags/JAVA/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/JAVA/"}]},{"title":"IOS【加载微信文章注入JS实现交互 浏览图片及保存】","slug":"IOS【加载微信文章注入JS实现交互-浏览图片及保存】","date":"2018-11-29T14:01:58.000Z","updated":"2018-11-29T14:01:59.087Z","comments":true,"path":"2018/11/29/IOS【加载微信文章注入JS实现交互-浏览图片及保存】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【加载微信文章注入JS实现交互-浏览图片及保存】/","excerpt":"","text":"最近项目某个模块中要求可以实现对网页中图片的查看，并要求在多张图片的情况下可以实现滑动浏览。所以，问题的集中点就是如何获取所有的图片地址及添加图片的点击事件。不多说，直接上码！ 在网页加载完成时，通过js获取图片和添加点击的识别方式12345678910111213141516171819202122232425262728293031323334- (void)webViewDidFinishLoad:(UIWebView *)webView &#123; [IDProgressHUD IDPlaceViewHideDirect:self.view]; //这里是js，主要目的实现对url的获取 static NSString * const jsGetImages = @&quot;function getImages()&#123;\\ var objs = document.getElementsByTagName(\\&quot;img\\&quot;);\\ var imgScr = &apos;&apos;;\\ for(var i=0;i&lt;objs.length;i++)&#123;\\ imgScr = imgScr + objs[i].src + &apos;+&apos;;\\ &#125;;\\ return imgScr;\\ &#125;;&quot;; [webView stringByEvaluatingJavaScriptFromString:jsGetImages];//注入js方法 NSString *urlResurlt = [webView stringByEvaluatingJavaScriptFromString:@&quot;getImages()&quot;]; mUrlArray = [NSMutableArray arrayWithArray:[urlResurlt componentsSeparatedByString:@&quot;+&quot;]]; if (mUrlArray.count &gt;= 2) &#123; [mUrlArray removeLastObject]; &#125; //urlResurlt 就是获取到得所有图片的url的拼接；mUrlArray就是所有Url的数组 //添加图片可点击js [mWebView stringByEvaluatingJavaScriptFromString:@&quot;function registerImageClickAction()&#123;\\ var imgs=document.getElementsByTagName(&apos;img&apos;);\\ var length=imgs.length;\\ for(var i=0;i&lt;length;i++)&#123;\\ img=imgs[i];\\ img.onclick=function()&#123;\\ window.location.href=&apos;image-preview:&apos;+this.src&#125;\\ &#125;\\ &#125;&quot;]; [mWebView stringByEvaluatingJavaScriptFromString:@&quot;registerImageClickAction();&quot;];&#125; //在这个方法中捕获到图片的点击事件和被点击图片的url1234567891011- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; //预览图片 if ([request.URL.scheme isEqualToString:@&quot;image-preview&quot;]) &#123; NSString* path = [request.URL.absoluteString substringFromIndex:[@&quot;image-preview:&quot; length]]; path = [path stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; //path 就是被点击图片的url return NO; &#125; return YES;&#125; #以下是保存所在作用域的图片12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 //添加长按事件 UILongPressGestureRecognizer *longPressed = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressed:)]; longPressed.minimumPressDuration = 0.3; longPressed.delegate = self; [webView addGestureRecognizer:longPressed]; /** 获取长按事件所在的位置图片 */- (void)longPressed:(UILongPressGestureRecognizer*)recognizer&#123; if (recognizer.state != UIGestureRecognizerStateBegan) &#123; return; &#125; CGPoint touchPoint = [recognizer locationInView:_webView]; NSString *imgURL = [NSString stringWithFormat:@&quot;document.elementFromPoint(%f, %f).src&quot;, touchPoint.x, touchPoint.y]; NSString *webImage = [_webView stringByEvaluatingJavaScriptFromString:imgURL]; if([webImage rangeOfString:@&quot;player&quot;].location !=NSNotFound || webImage.length == 0)&#123; return; &#125; [self showImageOptionsWithUrl:webImage];&#125;- (void)showImageOptionsWithUrl:(NSString *)imageUrl&#123; _webImageURL = imageUrl; IBActionSheet *standardIBAS = [[IBActionSheet alloc] initWithTitle:nil delegate:self cancelButtonTitle:@&quot;取消&quot; destructiveButtonTitle:@&quot;保存图片&quot; otherButtonTitles:nil]; [standardIBAS setFont:FontWithSize(SIZE_FONT_CONTENT)]; [standardIBAS setTitleFont:FontWithSize(SIZE_FONT_SUBCONTENT)]; [standardIBAS setButtonTextColor:[UIColor blackColor]]; [standardIBAS showInView:self.navigationController.view];&#125;#pragma mark - IBActionSheetDelegate-(void)actionSheet:(IBActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex&#123; if (buttonIndex == 0) &#123; NSURL *url = [NSURL URLWithString:_webImageURL]; NSURLSessionConfiguration * configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:[NSOperationQueue new]]; NSURLRequest *imgRequest = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:30.0]; NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (error) &#123; return ; &#125; NSData * imageData = [NSData dataWithContentsOfURL:location]; dispatch_async(dispatch_get_main_queue(), ^&#123; UIImage * image = [UIImage imageWithData:imageData]; UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL); &#125;); &#125;]; [task resume]; &#125;&#125; 后记：js挺好玩，我相信以后还会去多接触它。","categories":[],"tags":[],"keywords":[]},{"title":"IOS【关于iOS开发中比较常见的优化】","slug":"IOS【关于iOS开发中比较常见的优化】","date":"2018-11-29T14:01:20.000Z","updated":"2018-11-29T14:01:23.714Z","comments":true,"path":"2018/11/29/IOS【关于iOS开发中比较常见的优化】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【关于iOS开发中比较常见的优化】/","excerpt":"","text":"一. 如何让你的应用程序更加省电？答：(1). 如果程序用到定位，需要在定位完毕之后关闭定位，或者降低定位的频率，不停的定位会消耗电量。(2). 如果用到了蓝牙，需要使用蓝牙时候开启蓝牙，蓝牙用完之后关闭蓝牙，蓝牙也很耗电。(3). 优化算法，减少循环次数，大量循环会让CPU一直处于忙碌状态，特别费电。(4). 尽量不要使用网络轮询（心跳包、定时器），使用推送。(5). timer的时间间隔不宜太短，满足需求即可。(6). 不要频繁刷新页面，能刷新1行cell的最好刷新一行，尽量不要reloadData。(7). 线程适量，不宜过多。 二、简单描述一下你在开发的过程中，如何实现程序的性能优化？ 答：我在开发的过程中会注意一下几点来优化程序性能：1234561）.避免庞大的XIB、Storyboard，尽量多用纯代码开发2）.使用懒加载的方式延迟加载界面3）.避免反复处理数据4）.避免使用NSDateFormatter和NSCalendar。5）.图片缓存的取舍UIImage加载图片方式一般有两种:A：imagedNamed初始化B：imageWithContentsOfFile初始化二者不同之处在于,imageNamed默认加载图片成功后会内存中缓存图片,这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象.如果缓存中没有找到相应的图片对象,则从指定地方加载图片然后缓存对象，并返回这个图片对象.而imageWithContentsOfFile则仅只加载图片,不缓存.大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间来做这件事.当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片的，用imageWithContentsOfFile是最为经济的方式,这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间.使用场景需要编程时，应该根据实际应用场景加以区分，UIImage虽小，但使用元素较多问题会有所凸显. 三、tableView的重用机制？（简单了解即可） 查看UITableView头文件，会找到NSMutableArray visiableCells，和NSMutableDictneryreusableTableCells两个结构。visiableCells内保存当前显示的cells，reusableTableCells保存可重用的cells。TableView显示之初，reusableTableCells为空，那么tableViewdequeueReusableCellWithIdentifier:CellIdentifier返回nil。开始的cell都是通过[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]来创建，而且cellForRowAtIndexPath只是调用最大显示cell数的次数。比如：有100条数据，iPhone一屏最多显示10个cell。程序最开始显示TableView的情况是：1.用[[UITableViewCellalloc] initWithStyle:UITableViewCellStyleDefaultreuseIdentifier:CellIdentifier] 创建10次cell，并给cell指定同样的重用标识(当然，可以为不同显示类型的cell指定不同的标识)。并且10个cell全部都加入到visiableCells数组，reusableTableCells为空。2.向下拖动tableView，当cell1完全移出屏幕，并且cell11(它也是alloc出来的，原因同上)完全显示出来的时候。cell11加入到visiableCells，cell1移出visiableCells，cell1加入到reusableTableCells。3.接着向下拖动tableView，因为reusableTableCells中已经有值，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用的时候，tableViewdequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。cell1加入到visiableCells，cell1移出reusableTableCells；cell2移出visiableCells，cell2加入到reusableTableCells。之后再需要显示的Cell就可以正常重用了。 四、如何减小一个应用程序占用存储空间？ 检查程序 去掉多余的xib。iOS App Store相关因素作为提交到App Store中app里的可执行文件是被加过密的。加密的副作用是可执行文件的压缩效果没有之前的好了。Build Settings编译选项，将build setting中的Optimization Level设置为Fastest, Smallest [-Os];将build setting中的Strip Debug Symbols During Copy设置为YES(COPY_PHASE_STRIP = YES)，这样可以减小编译出二进制文件的尺寸。Target针对较少的CPUs对程序指定的特定CPU类型做优化处理，以生成相对于的可执行文件。不同的硬件，将运行不同的可执行代码。虽然这样优化后的程序，只能针对某些设备运行，但是这大大减小可执行程序的大小。要想只设定特定类型的CPUs，可以修改build setting中的Architectures，将其从Standard $(ARCHS_STANDARD)修改为你希望支持的列表中对应的特定类型CPU。有效的CPU名称列在Valid Architectures (VALID_ARCHS) build setting中。请不要修改Valid Architectures设置项，最好由Xcode管理。尽量使用8-bit图片。使用8-bit的PNG图片，比32-bit的图片能减少4倍的压缩率。由于8-bit的图片支持最多256种不同的颜色，所以8-bit的图片一般只应该用于一小部分的颜色图片。例如灰度图片最好使用8-bit 五、如何提高一个应用程序的性能？ 1、使用ARC减少内存失误，dealloc需要重写并对属性置nil。2、重用。3、尽量少使用透明或半透明。会产生额外的运算。4、少用运算获得圆角，不论view.maskToBounds还是layer.clipToBounds都会有很大资源开销，必须要用圆角的话不如图片本身就做成圆角。5、不要阻塞主线程。6、使用正确的容器类型。7、图片与imageView相同大小避免多余运算。8、使用懒加载。9、使用绘制。 六、如何优化内存？ （1）.用ARC管理内存ARC(Automatic ReferenceCounting,自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存。（2）.在正确的地方使用reuseIdentifier一个开发中常见的错误就是没有给UITableViewCells，UICollectionViewCells，甚至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。（3）.尽量把views设置为透明如果你有透明的Views你应该设置它们的opaque属性为YES。原因是这会使系统用一个最优的方式渲染这些views。如果设为YES，渲染系统就认为这个view是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是YES。（4）.避免过于庞大的XIB当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。（5）.不要阻塞主线程永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。一直使用主线程的风险就是如果你的代码真的block了主线程，你的app会失去反应。大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。（6）.在Image Views中调整图片大小如果要在UIImageView中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。（7）.选择正确的Collection学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理collections时这句话尤其正确。一些常见collection的总结：·Arrays:有序的一组值。使用index来lookup很快，使用value lookup很慢，插入/删除很慢。·Dictionaries:存储键值对。用键来查找比较快。·Sets:无序的一组值。用值来查找很快，插入/删除很快。（8）.打开gzip压缩大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。好消息是，iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经支持了压缩输出。（9）.重用和延迟加载(lazy load) Views更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。这里我们用到的技巧就是模仿UITableView和UICollectionView的操作:不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。创建views的能效问题也适用于你app的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个view的场景。有两种实现方法：1.创建并隐藏这个view当这个screen加载的时候，当需要时显示它；2.当需要时才创建并展示。每个方案都有其优缺点。用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。（10）. Cache, Cache,还是Cache!一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。NSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。（11）.权衡渲染方法在iOS中可以有很多方法做出漂亮的按钮。你可以用整幅的图片，可调大小的图片，uozhe可以用CALayer，CoreGraphics甚至OpenGL来画它们。当然每个不同的解决方法都有不同的复杂程度和相应的性能。简单来说，就是用事先渲染好的图片更快一些，因为如此一来iOS就免去了创建一个图片再画东西上去然后显示在屏幕上的程序。问题是你需要把所有你需要用到的图片放到app的bundle里面，这样就增加了体积–这就是使用可变大小的图片更好的地方了:你可以省去一些不必要的空间，也不需要再为不同的元素(比如按钮)来做不同的图。然而，使用图片也意味着你失去了使用代码调整图片的机动性，你需要一遍又一遍不断地重做他们，这样就很浪费时间了，而且你如果要做一个动画效果，虽然每幅图只是一些细节的变化你就需要很多的图片造成bundle大小的不断增大。总得来说，你需要权衡一下利弊，到底是要性能能还是要bundle保持合适的大小。（12）.处理内存警告一旦系统内存过低，iOS会通知所有运行中app。如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.幸运的是，UIKit提供了几种收集低内存警告的方法:· 在app delegate中使用applicationDidReceiveMemoryWarning:的方法· 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning· 注册并接收UIApplicationDidReceiveMemoryWarningNotification的通知一旦收到这类通知，你就需要释放任何不必要的内存使用。例如，UIViewController的默认行为是移除一些不可见的view，它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。（13）.重用大开销对象一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。（14）.减少使用Web特性UIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。但是你可能有注意到UIWebView并不像不像驱动Safari的那么快。这是由于以JIT compilation为特色的Webkit的Nitro Engine的限制。所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。（15）.优化Table ViewTable view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。为了保证table view平滑滚动，确保你采取了以下的措施:· 正确使用reuseIdentifier来重用cells· 尽量使所有的view opaque，包括cell自身· 避免渐变，图片缩放，后台选人· 缓存行高· 如果cell内现实的内容来自web，使用异步加载，缓存请求结果· 使用shadowPath来画阴影· 减少subviews的数量·尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果· 使用正确的数据结构来存储数据· 使用rowHeight,sectionFooterHeight和sectionHeaderHeight来设定固定的高，不要请求delegate（16）.使用Autorelease PoolNSAutoreleasePool负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为：NSArray urls = &lt;# An array of file URLs #&gt;;for(NSURL url in urls) {@autoreleasepool {NSError error;NSString fileContents = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];/ Process the string, creating and autoreleasing more objects. /}} 这段代码在每次遍历后释放所有autorelease对象（17）.选择是否缓存图片常见的从bundle中加载图片的方式有两种，一个是用imageNamed，二是用imageWithContentsOfFile，第一种比较常见一点。既然有两种类似的方法来实现相同的目的，那么他们之间的差别是什么呢？imageNamed的优点是当加载时会缓存图片。imageNamed的文档中这么说:这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。相反的，imageWithContentsOfFile仅加载图片。如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用imageWithContentsOfFile足矣，这样不会浪费内存来缓存它。然而，在图片反复重用的情况下imageNamed是一个好得多的选择。 七、如何加强iOS里的列表滚动时的顺畅感？ 1、UITableViewCell里不要添加太多subview，最好只添加一个cellview。2、UITableViewCell上的子View的opaque属性设为YES。其实默认也是不透明。UITableViewCell尽量不要包含透明的子View。3、在cellview里，重写drawRect函数绘制UITableViewCell的内容。4、在绘制字符串时，尽可能使用drawAtPoint: withFont:，而不要使用更复杂的drawAtPoint:(CGPoint)point forWidth:(CGFloat)width withFont:(UIFont )font lineBreakMode:(UILineBreakMode)lineBreakMode;如果要绘制过长的字符串，建议自己先截断，然后使用drawAtPoint: withFont:方法绘制。5、在绘制图片时，尽量使用drawAtPoint，而不要使用drawInRect。drawInRect如果在绘制过程中对图片进行放缩，会特别消耗CPU。6、如果绘制cell过程中，需要下载cell中的图片，建议在绘制cell一段时间后再开启图片下载任务。譬如先画一个默认图片，然后在0.5S后开始下载本cell的图片。7、即使下载cell图片是在子线程中进行，在绘制cell过程中，也不能开启过多的子线程。最好只有一个下载图片的子线程在活动。否则也会影响UITableViewCell的绘制，因而影响了UITableViewCell的滑动速度。(建议结合使用NSOpeartion和NSOperationQueue来下载图片，如果想尽可能找的下载图片，可以把[self.queuesetMaxConcurrentOperationCount:4];)8、最好自己写一个cache，用来缓存UITableView中的UITableViewCell，这样在整个UITableView的生命周期里，一个cell只需绘制一次，并且如果发生内存不足，也可以有效的释放掉缓存的cell。9、不要将tableview的背景颜色设置成一个图片。这回严重影响UITableView的滑动速度。在限时免费搜索里，我曾经翻过一个错误：self.tableView_.backgroundColor = [UIColorcolorWithPatternImage:[UIImageimageNamed:@”background.png”]];通过这种方式设置UITableView的背景颜色会严重影响UTIableView的滑动流畅性。修改成self.tableView_.backgroundColor = [UIColor clearColor];之后，fps从43上升到60左右。滑动比较流畅。10、cell的行高不是固定值，需要计算，则要尽可能缓存行高值，避免重复计算行高。这里指的是UITableViewDelegate里的行高函数。八、怎么解决缓存池满的问题（cell）ios中不存在缓存池满的情况，因为通常我们ios中开发，对象都是在需要的时候才会创建，有种常用的说话叫做懒加载，还有在UITableView中一般只会创建刚开始出现在屏幕中的cell，之后都是从缓存池里取，不会在创建新对象。缓存池里最多也就一两个对象，缓存池满的这种情况一般在开发java中比较常见，java中一般把最近最少使用的对象先释放。//清楚cell的缓存NSArray subviews = [[NSArray alloc] initWithArray:cell.contentView.subviews];for (UIView *subview in subviews) {[subview removeFromSuperview]; 九、TableView是怎么优化的？tableView下拉加载数据的时候为什么会出现卡顿，如何解决？ (1)使用不透明视图（2）不要重复创建不必要的table cell。（3）减少视图的数目。（4）不要做多余的绘制工作。（5）预渲染图像。（6）不要阻塞主线程。 十、正常使用应用时，按HOME键退出。稍后再次打开，界面出现卡顿现象，尝试分析一下可能原因。 这是由iOS系统管理决定的，但APP退出在后台后，只有10秒的持续运行时间，然后暂停。但该APP还在内存中，当出现内存警告，也就是别的APP要运行，而此时内存又不足的情况下，系统会回收停在后台APP所占用的内存。如果出现这种情况，那么你再次打开你的APP，就会重新启动。不知道你是为什么要让APP在后台还要继续运行，如果非得这样，那可以使用多线程技术中的gcd，可以让APP退出后继续运行很长一段时间（大概10分钟）iOS APP类型：1.保存现场。按下Home键10秒内直接杀死进程，并释放内存。iOS支持的“多任务”。按下Home键转入多任务状态，保留在内存中，但只能系统允许的动作：比如GPS，比如VoIP，比如音乐等等。3.真正的桌面级别的多任务。只有Safari/Mail是，苹果嫡系大都都不是。这个级别的app在后台没有任何限制动作。无限制动作的程序，一会在用户无察觉的情况下耗光电力，二会有安全上面的问题(那些在后台依旧默默发送你的个人消息程序)顺便提一句，后两种占用内存的app，也会在任意时间从内存中被砍掉，取决于你是否动用了其它app而导致内存不足。真正不会被砍掉的后台，只有苹果那个通知系统。 .什么时候会用到懒加载？如果需要展示大量图片的时候还要一个个去加载么？1懒加载，又称为延迟加载。说的通俗一点，就是在开发中，程序启动的时候不加载资源，只有在运行当需要一些资源时，再去加载这些资源。我们知道iOS设备的内存有限，如果在程序在启动后就一次性加载将来会用到的所有资源，那么就有可能会耗尽iOS设备的内存。这些资源例如大量数据，图片，音频等等 工程中的图片存在哪里，如何保证刷新后内存不断增加问题，以及节约用户流量？1工程中使用的图片可以自己创建个文件夹进行存放你需要用的图片,也可以在你工程中的Images.xcassets文件中存放你的图片.解决刷新内存不断增加的问题,需要把你创建的控件布局写成对应类的属性,在ViewDidLoad中初始化一次.不要在其他的类方法里创建控件.刷新节约用户流量的方法就是在一定时间段中判断当前的请求时间和上次刷新的时间并限定一个时间范围在某个范围内刷新不重新请求数据.","categories":[],"tags":[],"keywords":[]},{"title":"IOS【Runtime】","slug":"IOS【Runtime】","date":"2018-11-29T13:57:00.000Z","updated":"2018-11-29T14:32:20.171Z","comments":true,"path":"2018/11/29/IOS【Runtime】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【Runtime】/","excerpt":"","text":"一、runtime简介RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。对于C语言，函数的调用在编译的时候会决定调用哪个函数。对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。事实证明：在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。在编译阶段，C语言调用未实现的函数就会报错。二、runtime作用1.发送消息方法调用的本质，就是让对象发送消息。objc_msgSend,只有对象才能发送消息，因此以objc开头.使用消息机制前提，必须导入#import &lt;objc/message.h&gt;消息机制简单使用clang -rewrite-objc main.m 查看最终生成代码123456789101112131415161718// 创建person对象Person *p = [[Person alloc] init];// 调用对象方法[p eat];// 本质：让对象发送消息objc_msgSend(p, @selector(eat));// 调用类方法的方式：两种// 第一种通过类名调用[Person eat];// 第二种通过类对象调用[[Person class] eat];// 用类名调用类方法，底层会自动把类名转换成类对象调用// 本质：让类对象发送消息objc_msgSend([Person class], @selector(eat)); 消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现 2.交换方法开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。方式一:继承系统的类，重写方法.方式二:使用runtime,交换方法.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。 // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name; // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。 UIImage *image = [UIImage imageNamed:@&quot;123&quot;];&#125;@end@implementation UIImage (Image)// 加载分类到内存的时候调用+ (void)load&#123; // 交换方法 // 获取imageWithName方法地址 Method imageWithName = class_getClassMethod(self, @selector(imageWithName:)); // 获取imageWithName方法地址 Method imageName = class_getClassMethod(self, @selector(imageNamed:)); // 交换方法地址，相当于交换实现方式 method_exchangeImplementations(imageWithName, imageName);&#125;// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.// 既能加载图片又能打印+ (instancetype)imageWithName:(NSString *)name&#123; // 这里调用imageWithName，相当于调用imageName UIImage *image = [self imageWithName:name]; if (image == nil) &#123; NSLog(@&quot;加载空的图片&quot;); &#125; return image;&#125;@end 交换原理：交换之前： 交换之后： 3.动态添加方法开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。简单使用123456789101112131415161718192021222324252627282930313233343536373839404142434445@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. Person *p = [[Person alloc] init]; // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。 // 动态添加方法就不会报错 [p performSelector:@selector(eat)];&#125;@end@implementation Person// void(*)()// 默认方法都有两个隐式参数，void eat(id self,SEL sel)&#123; NSLog(@&quot;%@ %@&quot;,self,NSStringFromSelector(sel));&#125;// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(eat)) &#123; // 动态添加eat方法 // 第一个参数：给哪个类添加方法 // 第二个参数：添加方法的方法编号 // 第三个参数：添加方法的函数实现（函数地址） // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd class_addMethod(self, @selector(eat), eat, &quot;v@:&quot;); &#125; return [super resolveInstanceMethod:sel];&#125;@end 4.给分类添加属性原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。123456789101112131415161718192021222324252627282930313233343536373839@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 给系统NSObject类动态添加属性name NSObject *objc = [[NSObject alloc] init]; objc.name = @&quot;小码哥&quot;; NSLog(@&quot;%@&quot;,objc.name);&#125;@end// 定义关联的keystatic const char *key = &quot;name&quot;;@implementation NSObject (Property)- (NSString *)name&#123; // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key);&#125;- (void)setName:(NSString *)name&#123; // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 5.字典转模型设计模型：字典转模型的第一步模型属性，通常需要跟字典中的key一一对应问题：一个一个的生成模型属性，很慢？需求：能不能自动根据一个字典，生成对应的属性。解决：提供一个分类，专门根据字典生成对应的属性字符串。12345678910111213141516171819202122232425262728293031323334353637383940414243444546 @implementation NSObject (Log)// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123; // 拼接属性字符串代码 NSMutableString *strM = [NSMutableString string]; // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 类型经常变，抽出来 NSString *type; if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123; type = @&quot;NSString&quot;; &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)])&#123; type = @&quot;NSArray&quot;; &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)])&#123; type = @&quot;int&quot;; &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)])&#123; type = @&quot;NSDictionary&quot;; &#125; // 属性字符串 NSString *str; if ([type containsString:@&quot;NS&quot;]) &#123; str = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) %@ *%@;&quot;,type,key]; &#125;else&#123; str = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) %@ %@;&quot;,type,key]; &#125; // 每生成属性字符串，就自动换行。 [strM appendFormat:@&quot;\\n%@\\n&quot;,str]; &#125;]; // 把拼接好的字符串打印出来，就好了。 NSLog(@&quot;%@&quot;,strM);&#125;@end 字典转模型的方式一：KVC1234567891011121314@implementation Status+ (instancetype)statusWithDict:(NSDictionary *)dict&#123; Status *status = [[self alloc] init]; [status setValuesForKeysWithDictionary:dict]; return status;&#125;@end KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。如果不一致，就会调用[ setValue:forUndefinedKey:] 报key找不到的错。分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖， 就能继续使用KVC，字典转模型了。1234- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;&#125; 字典转模型的方式二：Runtime思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 解析Plist文件 NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil]; NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; // 获取字典数组 NSArray *dictArr = statusDict[@&quot;statuses&quot;]; // 自动生成模型的属性字符串// [NSObject resolveDict:dictArr[0][@&quot;user&quot;]]; _statuses = [NSMutableArray array]; // 遍历字典数组 for (NSDictionary *dict in dictArr) &#123; Status *status = [Status modelWithDict:dict]; [_statuses addObject:status]; &#125; // 测试数据 NSLog(@&quot;%@ %@&quot;,_statuses,[_statuses[0] user]);&#125;@end@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 思路：遍历模型中所有属性-》使用运行时 // 0.创建对应的对象 id objc = [[self alloc] init]; // 1.利用runtime给对象中的成员属性赋值 // class_copyIvarList:获取类中的所有成员属性 // Ivar：成员属性的意思 // 第一个参数：表示获取哪个类中的成员属性 // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值 // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 /* 类似下面这种写法 Ivar ivar; Ivar ivar1; Ivar ivar2; // 定义一个ivar的数组a Ivar a[] = &#123;ivar,ivar1,ivar2&#125;; // 用一个Ivar *指针指向数组第一个元素 Ivar *ivarList = a; // 根据指针访问数组第一个元素 ivarList[0]; */ unsigned int count; // 获取类中的所有成员属性 Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名-&gt;字典中的key // 从第一个角标开始截取 NSString *key = [name substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]]) &#123; // 字典转模型 // 获取模型的类对象，调用modelWithDict // 模型的类名已知，就是成员属性的类型 // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 生成的是这种@&quot;@\\&quot;User\\&quot;&quot; 类型 -》 @&quot;User&quot; 在OC字符串中 \\&quot; -&gt; &quot;，\\是转义的意思，不占用字符 // 裁剪类型字符串 NSRange range = [type rangeOfString:@&quot;\\&quot;&quot;]; type = [type substringFromIndex:range.location + range.length]; range = [type rangeOfString:@&quot;\\&quot;&quot;]; // 裁剪到哪个角标，不包括当前角标 type = [type substringToIndex:range.location]; // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(type); if (modelClass) &#123; // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict:value]; &#125; &#125; // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) &#123; // 字典转模型 id model = [classModel modelWithDict:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; if (value) &#123; // 有值，才需要给模型的属性赋值 // 利用KVC给模型中的属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/tags/iOS/"}],"keywords":[{"name":"iOS","slug":"iOS","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/categories/iOS/"}]},{"title":"IOS【使用tableView制作轮播图】","slug":"IOS【使用tableView制作轮播图】","date":"2018-11-29T13:55:08.000Z","updated":"2018-11-29T13:55:08.709Z","comments":true,"path":"2018/11/29/IOS【使用tableView制作轮播图】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【使用tableView制作轮播图】/","excerpt":"","text":"转载请注明出处：http://www.jianshu.com/p/01d5aba5dd68 在实际开发中,或许也有人有我这样的疑惑，想利用tableView Cell的重用机制,去更佳优化app的内存，就会想到这方面的性能优化。在网上查询了下，很少看到关于tableView轮播器的相关资料，干脆的自己写了一个希望大家喜欢1234tableScrollViewPageUse a table view do the picture carousel device, the use of infinite loops and cell multiplexing and better performance, like please point star, thank you 使用tableView表格视图 做的 图片轮播器 ， 使用了无限循环 和 cell复用，tableView性能大家都知道，已经进行了封装，只需根据需求进行简单改动，喜欢请点星，谢谢 github地址 https://github.com/ChinaArJun/TableScrollViewPage","categories":[],"tags":[],"keywords":[]},{"title":"IOS【电商项目: 高仿<爱鲜蜂> OC版】","slug":"IOS【电商项目-高仿-爱鲜蜂-OC版】","date":"2018-11-29T13:54:39.000Z","updated":"2018-11-29T13:54:40.505Z","comments":true,"path":"2018/11/29/IOS【电商项目-高仿-爱鲜蜂-OC版】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【电商项目-高仿-爱鲜蜂-OC版】/","excerpt":"","text":"最近在做抽出一点空余时间仿了一款爱鲜蜂项目 效果图 github : https://github.com/ChinaArJun/loveFreshPeakApp_oc","categories":[],"tags":[],"keywords":[]},{"title":"IOS【webSocket- socket.io_ios使用指南】","slug":"IOS【webSocket-socket-io-ios使用指南】","date":"2018-11-29T13:54:19.000Z","updated":"2018-11-29T13:54:22.407Z","comments":true,"path":"2018/11/29/IOS【webSocket-socket-io-ios使用指南】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【webSocket-socket-io-ios使用指南】/","excerpt":"","text":"要指定https在你的socketURL参数中. convenience init(socketURL: NSURL, options: NSDictionary?) 同上, 但是为了ObjC准备,使用字典. Options 所有关于SocketIOClientOption的设置.如果是ObjC,转换名字lowerCamelCase.12345678910111213141516171819case ConnectParams([String: AnyObject]) // 通过字典内容连接case Cookies([NSHTTPCookie]) // An array of NSHTTPCookies. Passed during the handshake. Default is nil.case DoubleEncodeUTF8(Bool) // Whether or not to double encode utf8. If using the node based server this should be true. Default is true.case ExtraHeaders([String: String]) // 添加自定义请求头初始化来请求, 默认为nilcase ForcePolling(Bool) // 是否使用 xhr-polling. Default is `false`case ForceNew(Bool) // 将为每个连接创建一个新的connect, 如果你在重新连接时有bug时使用.case ForceWebsockets(Bool) // 是否使用 WebSockets. Default is `false`case HandleQueue(dispatch_queue_t) // 调度handle的运行队列. Default is the main queue.case Log(Bool) // 是否打印调试信息. Default is false.case Logger(SocketLogger) // 可自定义SocketLogger调试日志.默认是系统的.case Nsp(String) // 如果使用命名空间连接. Must begin with /. Default is `/`case Path(String) // 如果服务器使用一个自定义路径. 例如: `&quot;/swift/&quot;`. Default is `&quot;&quot;`case Reconnects(Bool) // 是否重新连接服务器失败. Default is `true`case ReconnectAttempts(Int) // 重新连接多少次. Default is `-1` (无限次)case ReconnectWait(Int) // 等待重连时间. Default is `10`case SessionDelegate(NSURLSessionDelegate) // NSURLSessionDelegate 底层引擎设置. 如果你需要处理自签名证书. Default is nil.case Secure(Bool) // 如果连接要使用TLS. Default is false.case SelfSigned(Bool) // WebSocket.selfSignedSSL设置 (Don&apos;t do this, iOS will yell at you)case VoipEnabled(Bool) // 如果你的客户端使用VoIP服务,只有用这个选项,Default is false 方法12345678910111213141516on(event: String, callback: NormalCallback) -&gt; NSUUID // 给一个事件添加一个句柄. Items are passed by an array. 可以发送ack请求. 例如,返回一个唯一ID.once(event: String, callback: NormalCallback) -&gt; NSUUID // 同上,但只执行一次.onAny(callback:((event: String, items: AnyObject?)) -&gt; Void) //可以给所有事件添加一个句柄. event可以接收任何事件.emit(event: String, _ items: AnyObject...) // 发送一个或多条消息.emit(event: String, withItems items: [AnyObject]) // emit for Objective-CemitWithAck(event: String, _ items: AnyObject...) -&gt; (timeoutAfter: UInt64, callback: (NSArray?) -&gt; Void) -&gt; Void // 给服务器发送一个ack确认请求. 返回一个函数,你可以用它添加一个句柄. 注意: 直到你调用这个返回函数,才会发送消息emitWithAck(event: String, withItems items: [AnyObject]) -&gt; (UInt64, (NSArray?) -&gt; Void) -&gt; Void // 同上,为Objective-C准备的 connect() // 建立一个连接到服务器. 连接成功会触发 &quot;connect&quot;事件connect(timeoutAfter timeoutAfter: Int, withTimeoutHandler handler: (() -&gt; Void)?) // 连接到服务器. 如果连接超时,会调用handledisconnect() // Closes the socket. 重开一个断开连接的socket还没完全测试.reconnect() // Causes the client to reconnect to the server.joinNamespace(namespace: String) - Causes the client to join namespace. 不应该被调用,除非你手动改变命名空间.leaveNamespace() // Causes the client to leave the nsp and go back to &apos;/&apos;off(event: String) - Removes all event handlers for event.off(id id: NSUUID) - Removes the event that corresponds to id.removeAllHandlers() - Removes all handlers. 客户端的事件12345connect – 当成功连接时Emitteddisconnect – 当连接断开Emittederror – 发送错误时Emittedreconnect – 当开始重连时EmittedreconnectAttempt – 当尝试重连时Emitted","categories":[],"tags":[],"keywords":[]},{"title":"IOS【开发经验之谈—正则表达式实现图文混排】","slug":"IOS【开发经验之谈—正则表达式实现图文混排】","date":"2018-11-29T13:53:44.000Z","updated":"2018-11-29T13:53:47.025Z","comments":true,"path":"2018/11/29/IOS【开发经验之谈—正则表达式实现图文混排】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【开发经验之谈—正则表达式实现图文混排】/","excerpt":"","text":"在项目中，我们经常需要发表情，以及经常需要将表情字符转换成表情。因为表情是一个图片，所以我们发给服务器的时候，实际上是发一段特殊的文字给服务器，然后转换成表情。以免浪费用户过多的流量。那接下来，我们就来介绍一下，如何使用正则表达式实现图文混排呢？为了以后的代码的管理方便，我们抽取出两个类：1234567891011 NSString+Regular.h中，我们暴露两个方法出来： /** * 返回正则表达式匹配的第一个结果 * * @param pattern 正则表达式 * * @return 匹配的第一个结果 是NSTextCheckingResult类型 */-(NSTextCheckingResult *)firstMacthWithPattern:(NSString *)pattern;-(NSArray &lt;NSTextCheckingResult *&gt; *)machesWithPattern:(NSString *)pattern; NSString+Regular.m中，我们实现一下这两个方法: 12345678910111213141516171819202122232425262728293031323334353637- (NSTextCheckingResult *)firstMacthWithPattern:(NSString *)pattern&#123; //正则表达式的创建很容易失败，注意捕获错误 NSError *error = nil; //根据正则表达式创建实例 NSRegularExpression *regular = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:&amp;error]; if ( error) &#123; NSLog(@&quot;正则表达式创建失败&quot;); return nil; &#125; //匹配出结果 NSTextCheckingResult *result = [regular firstMatchInString:self options:0 range:NSMakeRange(0, self.length)]; if ( result) &#123; NSLog(@&quot;匹配&quot;); return result; &#125;else &#123; NSLog(@&quot;不匹配&quot;); return nil; &#125;&#125;- (NSArray &lt;NSTextCheckingResult *&gt; *)machesWithPattern:(NSString *)pattern&#123; NSError *error = nil; NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:&amp;error]; if (error) &#123; NSLog(@&quot;正则表达式创建失败&quot;); return nil; &#125; return [expression matchesInString:self options:0 range:NSMakeRange(0, self.length)];&#125; 我们进而对NSTextAttachment写一个子类 ZYTextAttachment.h 中 我们暴露一个方法出来：123@interface ZYTextAttachment : NSTextAttachment- (instancetype)initWithImage:(UIImage *)image;@end ZYTextAttachment.m中，我们实现一下：123456789101112131415161718#import &quot;ZYTextAttachment.h&quot;@implementation ZYTextAttachment- (instancetype)initWithImage:(UIImage *)image&#123; if (self = [super init]) &#123; self.image = image; &#125; return self;&#125;- (CGRect)attachmentBoundsForTextContainer:(NSTextContainer *)textContainer proposedLineFragment:(CGRect)lineFrag glyphPosition:(CGPoint)position characterIndex:(NSUInteger)charIndex&#123; return CGRectMake(0, -lineFrag.size.height * 0.2, lineFrag.size.height, lineFrag.size.height);&#125; 这样就能解决图片大写跟文字大小不一致的情况。 接下来，我们在viewController中，123456- (void)viewDidLoad &#123; [super viewDidLoad]; self.label.text = @&quot;二货[smiley_2], 你在干嘛呢[smiley_6] 一起吃饭？[smiley_44]!&quot;;&#125; 然后在下面的方法中：1234567891011121314151617181920212223242526272829303132- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSString *content = self.label.text; //匹配表情文字 NSString *pattern = @&quot;\\\\[\\\\w+\\\\]&quot;; NSArray *resultArr = [content machesWithPattern:pattern]; if (!resultArr) return; NSMutableAttributedString *attrContent = [[NSMutableAttributedString alloc]initWithString:content]; NSUInteger lengthDetail = 0; //遍历所有的result 取出range for (NSTextCheckingResult *result in resultArr) &#123; //取出图片名 NSString *imageName = [content substringWithRange:NSMakeRange(result.range.location + 1, result.range.length - 2)]; // 创建AttributeString, 来包装图片 ZYTextAttachment *attachment = [[ZYTextAttachment alloc]initWithImage:[UIImage imageNamed:imageName]]; // 将附近包装到NSAttributedString中 NSAttributedString *imageString = [NSAttributedString attributedStringWithAttachment:attachment]; //图片附件的文本长度是1 NSLog(@&quot;%zd&quot;,imageString.length); NSUInteger length = attrContent.length; NSRange newRange = NSMakeRange(result.range.location - lengthDetail, result.range.length); [attrContent replaceCharactersInRange:newRange withAttributedString:imageString]; lengthDetail += length - attrContent.length; &#125; //更新到label上 self.label.attributedText = attrContent;&#125; 看一下效果：","categories":[],"tags":[],"keywords":[]},{"title":"IOS【tabBar框架之 tabbar动画 TabBarsAnimationDemo】","slug":"IOS【tabBar框架之-tabbar动画-TabBarsAnimationDemo】","date":"2018-11-29T13:53:19.000Z","updated":"2018-11-29T13:53:23.500Z","comments":true,"path":"2018/11/29/IOS【tabBar框架之-tabbar动画-TabBarsAnimationDemo】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【tabBar框架之-tabbar动画-TabBarsAnimationDemo】/","excerpt":"","text":"在iOS原生的tabBar中，能够实现按钮的点击事件，能够实现视图控制器的切换等，但是在实际工程中，对于tabBar的要求的功能往往是系统自己实现不了的，所以我们这里就需要用到自定义的tabBar了。对于tabBar上展示视图控制器，我们会采用的是在把几个视图控制直接加载到tabBarController上去。这里新建三个视图控制器，由于在一、系统样式ViewController会有其他代码，所以我们这里另一写一个类，在这里只设置一个背景颜色就可以了。所以我们先新建一个类叫做ViewController，让它继承自UIViewController。这里设置视图的背景颜色，这里可以设置为随机色。 TabBarsAnimationDemo — 底部菜单push隐藏菜单栏动画（仿IOS京东效果） git - https://github.com/ChinaArJun/TabBarsAnimationDemo","categories":[],"tags":[],"keywords":[]},{"title":"IOS【视频直播:高仿腾讯旗下<NOW直播>映客直播类型】","slug":"IOS【视频直播-高仿腾讯旗下-NOW直播-映客直播类型】","date":"2018-11-29T13:52:53.000Z","updated":"2018-11-29T13:52:55.015Z","comments":true,"path":"2018/11/29/IOS【视频直播-高仿腾讯旗下-NOW直播-映客直播类型】/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【视频直播-高仿腾讯旗下-NOW直播-映客直播类型】/","excerpt":"","text":"效果图如下 处理了对IPad版本的适配 随着直播市场的火热，市场大军都逐步进入直播市场 ，腾讯旗下的NOW直播也不例外先说说直播设计底层 一 、流媒体1 - 伪流媒体 1.1 扫盲:边下载边播放 1.2 伪流媒体:视频不是实时播放的,先把视频放在数据库,再供客户端访问,比如:优酷,爱奇艺等 1.3 特点: 边下边存,文件会保存.遵守了 HTTP 协议,但是没有遵守 RTMP 和 HLS 协议能够实现快进和快退的功能实现简单,成本低 ######2 实时流媒体 2.1 真正的流媒体,边下边播,但不会保存下载的文件 2.2 特点: 下载的文件不会保存遵守了 RTMP 或者 HLS 协议只能实现实时播放,不能快进或者快退实现成本比较高,实现复杂 3 常见的流媒体协议: HLS(苹果基于 HTTP 开发的流媒体协议),RTMP(Adobe 的私有协议),MMS (微软). HLS协议 1 HLS: HTTP Live Streaming 是苹果公司实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在iOS系统，为iOS设备提供音视频直播和点播方案. 2 直播原理:通过相关设备采集摄像头的视频和麦克风的音频,并实时进行 H264视频编码和 AAC 音频音频编码,并按照 HLS协议规范,转换为标准的 TS文件以及m3u8(是一个地址,里面记录了服务器多对应的文件)索引文件. 3 HLS 点播:就是对 HTTP 进行分段播放,不同的就是在于对 HTTP 进行的分段非常小,因此可以说, HLS 点播的重点就是对 HTTP 进行分段.(现在的分段技术比较常见不在赘述) 4 HLS 直播原理:和其他的常见的直播协议(如: RTMP,RTSP,MMS)不同, 遵守HLS 协议的直播在客户端接收到的并不是完整的数据流. 即HLS 协议的服务器将最新获取到的片段进行分割为小片段,客户端获取服务器刚编好的最新的片段进行播放.这样服务器端不断的获取新的数据进行分割成新的片段,客户端不断的从服务器端获取最近的片段进行播放.由此可以说 HLS 是以点播的形式实现的直播. 5 HLS 的特点：由于数据是通过 HTTP 传输的,所以不用考虑防火墙和代理的问题，由于分割的时长很短,所以客户端可以很快的实现码率切换,以适应不同的带宽.HLS 协议的延迟一般会高于其他协议的流媒体直播. 6 HLS 实现步骤采取视频源和音频源数据对原始数据尽心 H264和 ACC 编码视频和音频数据封装为 MPEG-TS 包 HLS 分段生成策略以及 m3u8索引文件 HTTP 传输协议注:需要说明的是 HLS 分段策略的分段时长以10S 为最好. 二 、RTMP 协议1234567891011121314151617181920212223242526272829303132333435361 RTMP 实时消息传输协议,是现在比较常用的协议2 RTMP使用原理:首先推流到 RTMP 服务器,然后再有 RTMP 服务器提供 RTMP 视频服务.注:需啊说明的是:RTMP 也提供 HLS, 将音视频切位 ts 流,然后用户可以直接播放 m3u8流媒体.3 RTMP协议规定3.1 建立一个网络连接3.2 建立一个网络流(发送多媒体的通道)注:只能建立一个网络连接,但是可以建立多个网络流4 RTMP 协议使用步骤4.1 握手:RTMP 协议都是以握手开始的客户端先发送 C0,C1两个数据块,服务器收到 C1或者 C2块的时候开始发送 S0和 S1客户端收齐 S0和 S1的时候开始发送 C2,当服务器收齐 C0和 C1的时候开始发送 S2当客户端收到 S2同时服务器收到 C2 的时候,握手完成4.2 建立连接:建立客户端和服务器端的网络连接&gt; 客户端发送命令消息中的”connect”,到服务器,请求与一个服务器应用实例建立连接&gt; 服务器接收到请求后,发送确认消息,同时连接到请求中的连接实例&gt; 服务器发送设置带宽协议消息到客户端&gt; 客户端接收到 设置带宽 消息之后,发送确认消息到服务器&gt; 服务器发送用户控制消息中的”stream”消息到客户端&gt; 服务器发送消息命令中的”结果”消息到客户端4.3 建立流:建立客户端和服务器端的”流连接”&gt; 客户端发送消息命令中的”创建流”到服务器&gt; 服务器接收到”创建流”命令后,发送”结果”命令到客户端4.4 播放传输音视频数据&gt; 客户端发送”播放”命令到服务器&gt; 服务器收到消息后,发送 设置消息大小协议消息&gt; 服务器发送” streambegin”,告知客户端流 ID&gt; 若播放成功的话,服务器发送”响应状态”到客户端.告知客户端播放成功&gt; 服务器发送客户端要播放是数据 流媒体的播放 1 HLS 的流媒体通过AVPlayer/AVPlayerViewController 和 MPMviePlayerController/MPMoviePlayerViewController 来实现.2 RTMP 的流媒体要用第三方框架实现 如 FFMpeg ,IJKPlayer和 VLC 等3 常用的流媒体框架:百度/阿里/腾讯/网易/斗鱼直播伴侣/七牛云等 -项目主要是基于ijkplayer 的. 最好是打包成framework. 我也准备好了一份打包好的分享给大家-百度云盘链接:https://pan.baidu.com/s/1smNcwsX 密码:xpsq 打开项目记得用真机测试哦，不然模拟器会有音频跟不上失真的现象哦github -&gt; https://github.com/ChinaArJun/Tencent-NOW","categories":[],"tags":[],"keywords":[]},{"title":"面试【Socket网络编程，TCP/IP和Http等网络协议理解】","slug":"01ios-Job-interview","date":"2018-11-29T13:50:13.000Z","updated":"2018-11-29T13:52:26.901Z","comments":true,"path":"2018/11/29/01ios-Job-interview/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/01ios-Job-interview/","excerpt":"","text":"面试之 - Socket网络编程，TCP/IP和Http等网络协议理解 一、网络各个协议：TCP/IP、SOCKET、HTTP等网络七层由下往上分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。其中物理层、数据链路层和网络层通常被称作媒体层，是网络工程师所研究的对象；传输层、会话层、表示层和应用层则被称作主机层，是用户所面向和关心的内容。 http协议 对应于应用层 tcp协议 对应于传输层 ip协议 对应于网络层 三者本质上没有可比性。 何况HTTP协议是基于TCP连接的。 TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。 我 们在传输数据时，可以只使用传输层（TCP/IP），但是那样的话，由于没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用应用层 协议，应用层协议很多，有HTTP、FTP、TELNET等等，也可以自己定义应用层协议。WEB使用HTTP作传输层协议，以封装HTTP文本信息，然 后使用TCP/IP做传输层协议将它发送到网络上。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。 二、Http和Socket连接区别 相信不少学习手机联网开发的朋友都接触过Http与Socket连接,究竟他们有什么区别,这边浅谈下个人理解。 2.1、TCP连接Socket是对TCP/IP协议的封装,要想明白Socket连接，先要明白TCP连接。手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。建立起一个TCP连接需要经过“三次握手”：第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。握 手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客 户端交互，最终确定断开） 2.1.1 TCP 连接的建立步骤典型的 TCP 客户端要经过下面三步操作：• 创建一个 Socket 实例：构造函数向指定的远程主机和端口建立一个 TCP 连接；• 通过套接字的 I/O 流与服务端通信；• 使用 Socket 类的 close 方法关闭连接。服务端的工作是建立一个通信终端，并被动地等待客户端的连接。典型的 TCP 服务端执行如下两步操作： 创建一个 ServerSocket 实例并指定本地端口，用来监听客户端在该端口发送的 TCP 连接请求； 重复执行：• 调用 ServerSocket 的 accept（）方法以获取客户端连接，并通过其返回值创建一个 Socket 实例；• 为返回的 Socket 实例开启新的线程，并使用返回的 Socket 实例的 I/O 流与客户端通信； 通信完成后，使用 Socket 类的 close（）方法关闭该客户端的套接字连接。 2.2、HTTP连接HTTP协议即超文本传送协议(HypertextTransfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。3) 在 HTTP 2.0中,多路复用,Http2连接可以承载数十或数百个流的复用，多路复用意味著来自很多流的数据包能够混合在一起通过同样连接传输，两列不同火车被混合在一起传输，当到达终点时，它们又被拆开组成两列不同的火车。由 于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。三、SOCKET原理 3.1、套接字（socket）概念套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。应 用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。 3.2 、建立socket连接建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。连 接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户 端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 3.3、SOCKET连接与TCP连接协议相当于相互通信的程序间达成的一种约定，它规定了分组报文的结构、交换方式、包含的意义以及怎样对报文所包含的信息进行解析TCP/IP 协议族有 IP 协议、TCP 协议和 UDP 协议。现在 TCP/IP 协议族中的主要 socket 类型为流套接字（使用 TCP 协议）和数据报套接字（使用 UDP 协议）。TCP 协议提供面向连接的服务，通过它建立的是可靠地连接。Java 为 TCP 协议提供了两个类：Socke 类和 ServerSocket 类。一个 Socket 实例代表了 TCP 连接的一个客户端，而一个 ServerSocket 实例代表了 TCP连接的一个服务器端，一般在 TCP Socket 编程中，客户端有多个，而服务器端只有一个，客户端 TCP 向服务器端 TCP 发送连接请求，服务器端的 ServerSocket 实例则监听来自客户端的 TCP 连接请求，并为每个请求创建新的 Socket 实例，由于服务端在调用 accept（）等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码，因此要为每个 Socket 连接开启一个线程。服务器端要同时处理 ServerSocket 实例和 Socket 实例，而客户端只需要使用 Socket 实例。另外，每个 Socket 实例会关联一个 InputStream和 OutputStream 对象，我们通过将字节写入套接字的 OutputStream 来发送数据，并通过从 InputStream 来接收数据。客户端向服务器端发送连接请求后，就被动地等待服务器的响应。","categories":[],"tags":[],"keywords":[]},{"title":"IOS【 即时通讯 SocketIO - 使用篇】","slug":"ios","date":"2018-11-29T08:56:13.000Z","updated":"2018-11-29T13:52:04.053Z","comments":true,"path":"2018/11/29/ios/","link":"","permalink":"github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/ios/","excerpt":"","text":"项目正好用到了即时通讯功能，于是研究到了webSocket技术，后来发现了可以在web、[Android]、[iOS]上同时使用的解决方案，那就是SocketIO。其实现原理啥的不做介绍了，直接贴上IOS项目可能会用到的一些资源。 首先是官网：http://socket.io/ 这个大家都不会陌生吧~~ 1、官方推荐的Android项目：http://socket.io/blog/native-socket-io-and-android/ github上的相应地址为：https://github.com/nkzawa/socket.io-android-chat 2、官方推荐的IOS–Swift项目：http://socket.io/blog/socket-io-on-ios/ github上的相应地址为：https://github.com/socketio/socket.io-client-swift 另外如果你需要oc版本的，可以参考这里：socket.io v0.7.2 — 0.9.x for iOS and OS X https://github.com/pkyeck/socket.IO-objc 3、官方推荐的C++项目：http://socket.io/blog/socket-io-cpp/ github上的相应地址为：https://github.com/socketio/socket.io-client-cpp 另外还有一个匿名的聊天室可以让你测试用：http://chat.socket.io/// 关于配置的那些坑 及 WebSocket开发的原理 由于IOS端官网只有介绍Swift的代码，如果需要使用到OC版就需要在github下载非官方的版本，在与后台的各种折腾中，终于发现非官方的OC版本配置不兼容后台的需求，重新换了Swift官方版本才行，在OC项目中桥接Swift文件即可。 后台采用workman开源推送机制，将消息即时发送到客户端，原理和WebViewJavascriptBridge类似，据了解微信也是使用这种机制，只是框架可能有所不同，由于后台是开源服务器，所开发的难度并不大，只是时间成本的问题； // 在使用key值时，需要与后台进行对应配置， // 如下是指发送消息 根据“group chat” key值去指向服务器所对应的方法，将数据传递过去 123456789101112131415161718socket.on(&quot;group chat&quot;) &#123; (dataArray, socketAck) -&gt; Void invar messageDictionary = [String: AnyObject]()print(&quot;group chat dataArray = %@&quot;,dataArray)let messageDict = dataArray[0];messageDictionary[&quot;username&quot;] = messageDict[&quot;username&quot;]messageDictionary[&quot;message&quot;] = messageDict[&quot;message&quot;]print(&quot;messageDictionary = %@&quot;,messageDictionary)completionHandler(messageInfo: messageDictionary)&#125; // 如下是监测服务器的通知 根据“disconnect” key值去调用所需要处理的对应方法即可 在配置的使用过程中，采用统一形式的回调Block形式即可，方法非常简洁，有问题欢迎留言","categories":[],"tags":[],"keywords":[]}]}