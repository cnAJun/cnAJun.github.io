<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.png?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="阿俊的博客">
<meta property="og:url" content="github.com:ChinaArJun/ChinaArJun.github.io.git/page/2/index.html">
<meta property="og:site_name" content="阿俊的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阿俊的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="github.com:ChinaArJun/ChinaArJun.github.io.git/page/2/"/>





  <title>阿俊的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">阿俊的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">bug终结者</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ChinaArJun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿俊的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/JAVA/" itemprop="url">JAVA【基于JAVA调用免费天气api接口示例】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T22:02:00+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>查询天气预报在APP中常用的一个常用功能，聚合数据免费天气api接口可以根据根据城市名/id查询天气、根据IP查询天气、据GPS坐标查询天气、查询城市天气三小时预报，并且支持全国不同城市天气预报查询。<br>代码描述：基于JAVA的免费天气api接口调用示例，根据文档中注明的需求参数,调用接口返回数据。<br>关联数据：免费天气api<br>接口地址：<a href="https://www.juhe.cn/docs/api/id/39" target="_blank" rel="noopener">https://www.juhe.cn/docs/api/id/39</a><br>step1:选择本文所示例的接口”免费天气api” url:<a href="https://www.juhe.cn/docs/api/id/39/aid/87" target="_blank" rel="noopener">https://www.juhe.cn/docs/api/id/39/aid/87</a><br>step2:每个接口都需要传入一个参数key,相当于用户的令牌,所以第一步你需要申请一个key<br>step3:看文档!!!学过java的同学们都知道,当我们对一个类或者方法不明白其意图和思想时,我们可以去查看文档,这里也不例外,而且对于英文不是特别好的同学来说很幸运的是,聚合网站上的文档都是中文版本的,比起阅读java源码里的英文文档应该轻松很多.<br>全国天气预报接口下面有六个子接口,打开第一个接口链接,看文档发现需要传入一个城市名或者城市ID参数,这个参数我们可以通过第六个子接口获取(接口之间参数的调用类似于java中方法之间的调用),即支持城市列表获取.所以示例中我们先调用这个接口.调用接口涉及到请求网络资源的问题,这里我封装了一个工具类,包含GET和POST两种方法<br>step4:上代码</p>
<h4 id="Demo1-网络访问工具类-封装get和post方法"><a href="#Demo1-网络访问工具类-封装get和post方法" class="headerlink" title="Demo1:网络访问工具类(封装get和post方法)"></a>Demo1:网络访问工具类(封装get和post方法)</h4><h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package juheAPI;  </span><br><span class="line">    </span><br><span class="line">import java.io.BufferedReader;  </span><br><span class="line">import java.io.BufferedWriter;  </span><br><span class="line">import java.io.InputStream;  </span><br><span class="line">import java.io.InputStreamReader;  </span><br><span class="line">import java.io.OutputStream;  </span><br><span class="line">import java.io.OutputStreamWriter;  </span><br><span class="line">import java.net.HttpURLConnection;  </span><br><span class="line">import java.net.URL;  </span><br><span class="line">import java.util.Map;  </span><br><span class="line">/** </span><br><span class="line"> * 网络访问工具类 </span><br><span class="line"> * @author silk </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">public class PureNetUtil &#123;  </span><br><span class="line">    /** </span><br><span class="line">     * get方法直接调用post方法 </span><br><span class="line">     * @param url 网络地址 </span><br><span class="line">     * @return 返回网络数据 </span><br><span class="line">     */  </span><br><span class="line">    public static String get(String url)&#123;  </span><br><span class="line">        return post(url,null);  </span><br><span class="line">    &#125;  </span><br><span class="line">    /** </span><br><span class="line">     * 设定post方法获取网络资源,如果参数为null,实际上设定为get方法 </span><br><span class="line">     * @param url 网络地址 </span><br><span class="line">     * @param param 请求参数键值对 </span><br><span class="line">     * @return 返回读取数据 </span><br><span class="line">     */  </span><br><span class="line">   public static &lt;K, V&gt; String post(String  url,Map&lt;K,V&gt;   param)&#123;  </span><br><span class="line">        HttpURLConnection conn=null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            URL u=new URL(url);  </span><br><span class="line">            conn=(HttpURLConnection) u.openConnection();  </span><br><span class="line">            StringBuffer sb=null;  </span><br><span class="line">            if(param!=null)&#123;//如果请求参数不为空  </span><br><span class="line">                sb=new StringBuffer();  </span><br><span class="line">                /*A URL connection can be used for input and/or output.  Set the DoOutput </span><br><span class="line">                 * flag to true if you intend to use the URL connection for output, </span><br><span class="line">                 * false if not.  The default is false.*/  </span><br><span class="line">                //默认为false,post方法需要写入参数,设定true  </span><br><span class="line">                conn.setDoOutput(true);  </span><br><span class="line">                //设定post方法,默认get  </span><br><span class="line">                conn.setRequestMethod(&quot;POST&quot;);  </span><br><span class="line">                //获得输出流  </span><br><span class="line">                OutputStream out=conn.getOutputStream();  </span><br><span class="line">                //对输出流封装成高级输出流  </span><br><span class="line">                BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out));  </span><br><span class="line">                //将参数封装成键值对的形式  </span><br><span class="line">                for(Map.Entry s:param.entrySet())&#123;  </span><br><span class="line">                    sb.append(s.getKey()).append(&quot;=&quot;).append(s.getValue()).append(&quot;&amp;&quot;);  </span><br><span class="line">                &#125;  </span><br><span class="line">                //将参数通过输出流写入  </span><br><span class="line">                writer.write(sb.deleteCharAt(sb.toString().length()-1).toString());  </span><br><span class="line">                writer.close();//一定要关闭,不然可能出现参数不全的错误  </span><br><span class="line">                sb=null;  </span><br><span class="line">            &#125;  </span><br><span class="line">            conn.connect();//建立连接  </span><br><span class="line">            sb=new StringBuffer();  </span><br><span class="line">            //获取连接状态码  </span><br><span class="line">            int recode=conn.getResponseCode();  </span><br><span class="line">            BufferedReader reader=null;  </span><br><span class="line">            if(recode==200)&#123;  </span><br><span class="line">                //Returns an input stream that reads from this open connection  </span><br><span class="line">                //从连接中获取输入流  </span><br><span class="line">                InputStream in=conn.getInputStream();  </span><br><span class="line">                //对输入流进行封装  </span><br><span class="line">                reader=new BufferedReader(new InputStreamReader(in));  </span><br><span class="line">                String str=null;  </span><br><span class="line">                sb=new StringBuffer();  </span><br><span class="line">                //从输入流中读取数据  </span><br><span class="line">                while((str=reader.readLine())!=null)&#123;  </span><br><span class="line">                    sb.append(str).append(System.getProperty(&quot;line.separator&quot;));  </span><br><span class="line">                &#125;  </span><br><span class="line">                //关闭输入流  </span><br><span class="line">                reader.close();  </span><br><span class="line">                if (sb.toString().length() == 0) &#123;  </span><br><span class="line">                    return null;  </span><br><span class="line">                &#125;  </span><br><span class="line">                return sb.toString().substring(0,  </span><br><span class="line">                        sb.toString().length() - System.getProperty(&quot;line.separator&quot;).length());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            return null;  </span><br><span class="line">        &#125;finally&#123;  </span><br><span class="line">            if(conn!=null)//关闭连接  </span><br><span class="line">                conn.disconnect();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Demo2-调用获取城市列表接口示例"><a href="#Demo2-调用获取城市列表接口示例" class="headerlink" title="Demo2:调用获取城市列表接口示例"></a>Demo2:调用获取城市列表接口示例</h4><h4 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package juheAPI;  </span><br><span class="line">   </span><br><span class="line">import net.sf.json.JSONArray;  </span><br><span class="line">import net.sf.json.JSONObject;  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">/** </span><br><span class="line"> * 获取城市列表 </span><br><span class="line"> * 全国天气预报接口调用JAVA示例 </span><br><span class="line"> *     dtype     string    N    返回数据格式：json或xml,默认json     </span><br><span class="line"> *     key        string     Y    你申请的key     </span><br><span class="line"> * @author silk </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">public class GetCityList &#123;  </span><br><span class="line">    /** </span><br><span class="line">     * 调用获取城市列表接口,返回所有数据 </span><br><span class="line">     * @return 返回接口数据 </span><br><span class="line">     */  </span><br><span class="line">    public static String excute()&#123;  </span><br><span class="line">        String url=&quot;http://v.juhe.cn/weather/citys?key=***a7558b2e0bedaa19673f74a6809ce&quot;;//接口URL  </span><br><span class="line">        //PureNetUtil是一个封装了get和post方法获取网络请求数据的工具类  </span><br><span class="line">        return PureNetUtil.get(url);//使用get方法  </span><br><span class="line">    &#125;  </span><br><span class="line">    /** </span><br><span class="line">     * 调用接口返回数据后,解析数据,根据输入城市名得到对应ID </span><br><span class="line">     * @param cityName 城市名称 </span><br><span class="line">     * @return 返回对应ID </span><br><span class="line">     */  </span><br><span class="line">    public static String getIDBycityName(String cityName) &#123;  </span><br><span class="line">        String result=excute();//返回接口结果,得到json格式数据  </span><br><span class="line">        if(result!=null)&#123;  </span><br><span class="line">            JSONObject obj=JSONObject.fromObject(result);  </span><br><span class="line">            result=obj.getString(&quot;resultcode&quot;);//得到返回状态码  </span><br><span class="line">            if(result!=null&amp;&amp;result.equals(&quot;200&quot;))&#123;//200表示成功返回数据  </span><br><span class="line">                result=obj.getString(&quot;result&quot;);//得到城市列表的json格式字符串数组  </span><br><span class="line">                JSONArray arr=JSONArray.fromObject(result);  </span><br><span class="line">                for(Object o:arr)&#123;//对arr进行遍历  </span><br><span class="line">                    //将数组中的一个json个数字符串进行解析  </span><br><span class="line">                    obj=JSONObject.fromObject(o.toString());  </span><br><span class="line">                    /*此时obj如 &#123;&quot;id&quot;:&quot;2&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;city&quot;:&quot;北京&quot;,&quot;district&quot;:&quot;海淀&quot;&#125;*/  </span><br><span class="line">                    //以city这个key为线索判断所需要寻找的这条记录  </span><br><span class="line">                    result=obj.getString(&quot;district&quot;);  </span><br><span class="line">                    //防止输入城市名不全,如苏州市输入为苏州,类似与模糊查询  </span><br><span class="line">                    if(result.equals(cityName)||result.contains(cityName))&#123;  </span><br><span class="line">                        result=obj.getString(&quot;id&quot;);//得到ID  </span><br><span class="line">                        return result;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        System.out.println(getIDBycityName(&quot;香港&quot;));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Demo3-调用根据城市名-id查询天气"><a href="#Demo3-调用根据城市名-id查询天气" class="headerlink" title="Demo3:调用根据城市名/id查询天气"></a>Demo3:调用根据城市名/id查询天气</h4><h4 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package juheAPI;  </span><br><span class="line">   </span><br><span class="line">import net.sf.json.JSONObject;  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">/** </span><br><span class="line"> * 根据城市名/id查询天气 </span><br><span class="line"> * @author silk </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">public class WeatherReportByCity &#123;  </span><br><span class="line">    /** </span><br><span class="line">     * 根据城市名获取 </span><br><span class="line">     * @param cityName </span><br><span class="line">     * @return </span><br><span class="line">     */  </span><br><span class="line">    public static String excute(String cityName)&#123;  </span><br><span class="line">        String url=//此处以返回json格式数据示例,所以format=2,以根据城市名称为例,cityName传入中文  </span><br><span class="line">                &quot;http://v.juhe.cn/weather/index?cityname=&quot;+cityName+&quot;&amp;key=***a7558b2e0bedaa19673f74a6809ce&quot;;  </span><br><span class="line">        return PureNetUtil.get(url);//通过工具类获取返回数据  </span><br><span class="line">    &#125;  </span><br><span class="line">    /** </span><br><span class="line">     * 获取返回数据中的一个属性示例,此处以获取今日温度为例 </span><br><span class="line">     * &quot;temperature&quot;: &quot;8℃~20℃&quot;     今日温度 </span><br><span class="line">     * @param args </span><br><span class="line">     * @return  </span><br><span class="line">     */  </span><br><span class="line">    public static String GetTodayTemperatureByCity(String city) &#123;  </span><br><span class="line">        String result=excute(city);  </span><br><span class="line">        if(result!=null)&#123;  </span><br><span class="line">            JSONObject obj=JSONObject.fromObject(result);  </span><br><span class="line">            /*获取返回状态码*/  </span><br><span class="line">            result=obj.getString(&quot;resultcode&quot;);  </span><br><span class="line">            /*如果状态码是200说明返回数据成功*/  </span><br><span class="line">            if(result!=null&amp;&amp;result.equals(&quot;200&quot;))&#123;  </span><br><span class="line">                result=obj.getString(&quot;result&quot;);  </span><br><span class="line">                //此时result中数据有多个key,可以对其key进行遍历,得到对个属性  </span><br><span class="line">                obj=JSONObject.fromObject(result);  </span><br><span class="line">                //今日温度对应的key是today  </span><br><span class="line">                result=obj.getString(&quot;today&quot;);  </span><br><span class="line">                obj=JSONObject.fromObject(result);  </span><br><span class="line">                //今日温度对应当key是temperature  </span><br><span class="line">                result=obj.getString(&quot;temperature&quot;);  </span><br><span class="line">                return result;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        System.out.println(GetTodayTemperatureByCity(&quot;苏州&quot;));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Demo4-调用天气种类及表示列表接口示例"><a href="#Demo4-调用天气种类及表示列表接口示例" class="headerlink" title="Demo4:调用天气种类及表示列表接口示例"></a>Demo4:调用天气种类及表示列表接口示例</h4><h4 id="Java代码-3"><a href="#Java代码-3" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package juheAPI;  </span><br><span class="line">   </span><br><span class="line">import net.sf.json.JSONArray;  </span><br><span class="line">import net.sf.json.JSONObject;  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">/** </span><br><span class="line"> * 天气种类及标识列表接口调用JAVA示例 </span><br><span class="line"> * @author silk </span><br><span class="line"> */  </span><br><span class="line">public class GetWeatherSignAndTypeList &#123;  </span><br><span class="line">    //接口地址,因为只需要传入一个固定的key为参数,所以设为常量  </span><br><span class="line">    private static final String URL= &quot;http://v.juhe.cn/weather/uni?key=***a7558b2e0bedaa19673f74a6809ce&quot;;  </span><br><span class="line">    /** </span><br><span class="line">     * 通过工具类获取数据 </span><br><span class="line">     * @return </span><br><span class="line">     */  </span><br><span class="line">    public static String excute()&#123;  </span><br><span class="line">        return PureNetUtil.get(URL);//调用工具类获取接口数据  </span><br><span class="line">    &#125;  </span><br><span class="line">    /** </span><br><span class="line">     * 利用遍历数组的方式获取 </span><br><span class="line">     * @param wid天气对应id </span><br><span class="line">     * @return 天气名称 </span><br><span class="line">     */  </span><br><span class="line">    public static String getWeatherByWid(String wid) &#123;  </span><br><span class="line">        String result=excute();//获取接口数据  </span><br><span class="line">        if(result!=null)&#123;  </span><br><span class="line">            JSONObject obj=JSONObject.fromObject(result);  </span><br><span class="line">            result=obj.getString(&quot;resultcode&quot;);  </span><br><span class="line">            /*获取返回状态码*/  </span><br><span class="line">            if(result!=null&amp;&amp;result.equals(&quot;200&quot;))&#123;  </span><br><span class="line">                /*获取数组数据*/  </span><br><span class="line">                result=obj.getString(&quot;result&quot;);  </span><br><span class="line">                JSONArray arr=JSONArray.fromObject(result);  </span><br><span class="line">                for(Object o:arr)&#123;//遍历数组  </span><br><span class="line">                    obj=JSONObject.fromObject(o.toString());  </span><br><span class="line">                    //如果遍历到需要的数据后直接返回结果,根据key(wid)得到value判断是否等于传入参数  </span><br><span class="line">                    if(obj.getString(&quot;wid&quot;).equals(wid))&#123;  </span><br><span class="line">                        result=obj.getString(&quot;weather&quot;);  </span><br><span class="line">                        return result;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        System.out.println(getWeatherByWid(&quot;10&quot;));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  step5:调用接口时候如果状态码不是200,仔细参考文档说明!</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【加载微信文章注入JS实现交互-浏览图片及保存】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ChinaArJun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿俊的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/IOS【加载微信文章注入JS实现交互-浏览图片及保存】/" itemprop="url">IOS【加载微信文章注入JS实现交互 浏览图片及保存】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T22:01:58+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近项目某个模块中要求可以实现对网页中图片的查看，并要求在多张图片的情况下可以实现滑动浏览。<br>所以，问题的集中点就是如何获取所有的图片地址及添加图片的点击事件。不多说，直接上码！</p>
<p>在网页加载完成时，通过js获取图片和添加点击的识别方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</span><br><span class="line">    [IDProgressHUD IDPlaceViewHideDirect:self.view];</span><br><span class="line">    </span><br><span class="line">    //这里是js，主要目的实现对url的获取</span><br><span class="line">    static  NSString * const jsGetImages =</span><br><span class="line">    @&quot;function getImages()&#123;\</span><br><span class="line">    var objs = document.getElementsByTagName(\&quot;img\&quot;);\</span><br><span class="line">    var imgScr = &apos;&apos;;\</span><br><span class="line">    for(var i=0;i&lt;objs.length;i++)&#123;\</span><br><span class="line">    imgScr = imgScr + objs[i].src + &apos;+&apos;;\</span><br><span class="line">    &#125;;\</span><br><span class="line">    return imgScr;\</span><br><span class="line">    &#125;;&quot;;</span><br><span class="line">    </span><br><span class="line">    [webView stringByEvaluatingJavaScriptFromString:jsGetImages];//注入js方法</span><br><span class="line">    NSString *urlResurlt = [webView stringByEvaluatingJavaScriptFromString:@&quot;getImages()&quot;];</span><br><span class="line">    mUrlArray = [NSMutableArray arrayWithArray:[urlResurlt componentsSeparatedByString:@&quot;+&quot;]];</span><br><span class="line">    if (mUrlArray.count &gt;= 2) &#123;</span><br><span class="line">        [mUrlArray removeLastObject];</span><br><span class="line">    &#125;</span><br><span class="line">    //urlResurlt 就是获取到得所有图片的url的拼接；mUrlArray就是所有Url的数组</span><br><span class="line">    </span><br><span class="line">    //添加图片可点击js</span><br><span class="line">    [mWebView stringByEvaluatingJavaScriptFromString:@&quot;function registerImageClickAction()&#123;\</span><br><span class="line">     var imgs=document.getElementsByTagName(&apos;img&apos;);\</span><br><span class="line">     var length=imgs.length;\</span><br><span class="line">     for(var i=0;i&lt;length;i++)&#123;\</span><br><span class="line">     img=imgs[i];\</span><br><span class="line">     img.onclick=function()&#123;\</span><br><span class="line">     window.location.href=&apos;image-preview:&apos;+this.src&#125;\</span><br><span class="line">     &#125;\</span><br><span class="line">     &#125;&quot;];</span><br><span class="line">    [mWebView stringByEvaluatingJavaScriptFromString:@&quot;registerImageClickAction();&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//在这个方法中捕获到图片的点击事件和被点击图片的url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;</span><br><span class="line">    </span><br><span class="line">    //预览图片</span><br><span class="line">    if ([request.URL.scheme isEqualToString:@&quot;image-preview&quot;]) &#123;</span><br><span class="line">        NSString* path = [request.URL.absoluteString substringFromIndex:[@&quot;image-preview:&quot; length]];</span><br><span class="line">        path = [path stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">        //path 就是被点击图片的url</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#以下是保存所在作用域的图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">    //添加长按事件</span><br><span class="line">    UILongPressGestureRecognizer *longPressed = [[UILongPressGestureRecognizer alloc]</span><br><span class="line">                                                 initWithTarget:self action:@selector(longPressed:)];</span><br><span class="line">    longPressed.minimumPressDuration = 0.3;</span><br><span class="line">    longPressed.delegate = self;</span><br><span class="line">    [webView addGestureRecognizer:longPressed];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> 获取长按事件所在的位置图片</span><br><span class="line"> */</span><br><span class="line">- (void)longPressed:(UILongPressGestureRecognizer*)recognizer</span><br><span class="line">&#123;</span><br><span class="line">    if (recognizer.state != UIGestureRecognizerStateBegan) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    CGPoint touchPoint = [recognizer locationInView:_webView];</span><br><span class="line">    NSString *imgURL = [NSString stringWithFormat:@&quot;document.elementFromPoint(%f, %f).src&quot;,</span><br><span class="line">                        touchPoint.x, touchPoint.y];</span><br><span class="line">    NSString *webImage = [_webView stringByEvaluatingJavaScriptFromString:imgURL];</span><br><span class="line">    </span><br><span class="line">    if([webImage rangeOfString:@&quot;player&quot;].location !=NSNotFound || webImage.length == 0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self showImageOptionsWithUrl:webImage];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)showImageOptionsWithUrl:(NSString *)imageUrl</span><br><span class="line">&#123;</span><br><span class="line">    _webImageURL = imageUrl;</span><br><span class="line">    IBActionSheet *standardIBAS = [[IBActionSheet alloc] initWithTitle:nil delegate:self cancelButtonTitle:@&quot;取消&quot; destructiveButtonTitle:@&quot;保存图片&quot; otherButtonTitles:nil];</span><br><span class="line">    [standardIBAS setFont:FontWithSize(SIZE_FONT_CONTENT)];</span><br><span class="line">    [standardIBAS setTitleFont:FontWithSize(SIZE_FONT_SUBCONTENT)];</span><br><span class="line">    [standardIBAS setButtonTextColor:[UIColor blackColor]];</span><br><span class="line">    [standardIBAS showInView:self.navigationController.view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - IBActionSheetDelegate</span><br><span class="line"></span><br><span class="line">-(void)actionSheet:(IBActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex&#123;</span><br><span class="line">    </span><br><span class="line">    if (buttonIndex == 0) &#123;</span><br><span class="line">        </span><br><span class="line">        NSURL *url = [NSURL URLWithString:_webImageURL];</span><br><span class="line">        NSURLSessionConfiguration * configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">        NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:[NSOperationQueue new]];</span><br><span class="line">        NSURLRequest *imgRequest = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:30.0];</span><br><span class="line">        </span><br><span class="line">        NSURLSessionDownloadTask  *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            NSData * imageData = [NSData dataWithContentsOfURL:location];</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                UIImage * image = [UIImage imageWithData:imageData];</span><br><span class="line">                UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL);</span><br><span class="line">            &#125;);   </span><br><span class="line">        &#125;];</span><br><span class="line">        [task resume];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后记：js挺好玩，我相信以后还会去多接触它。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【关于iOS开发中比较常见的优化】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ChinaArJun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿俊的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/IOS【关于iOS开发中比较常见的优化】/" itemprop="url">IOS【关于iOS开发中比较常见的优化】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T22:01:20+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一. 如何让你的应用程序更加省电？<br>答：<br>(1). 如果程序用到定位，需要在定位完毕之后关闭定位，或者降低定位的频率，不停的定位会消耗电量。(2). 如果用到了蓝牙，需要使用蓝牙时候开启蓝牙，蓝牙用完之后关闭蓝牙，蓝牙也很耗电。<br>(3). 优化算法，减少循环次数，大量循环会让CPU一直处于忙碌状态，特别费电。<br>(4). 尽量不要使用网络轮询（心跳包、定时器），使用推送。<br>(5). timer的时间间隔不宜太短，满足需求即可。<br>(6). 不要频繁刷新页面，能刷新1行cell的最好刷新一行，尽量不要reloadData。<br>(7). 线程适量，不宜过多。</p>
<p>二、简单描述一下你在开发的过程中，如何实现程序的性能优化？</p>
<p>答：我在开发的过程中会注意一下几点来优化程序性能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）.避免庞大的XIB、Storyboard，尽量多用纯代码开发</span><br><span class="line">2）.使用懒加载的方式延迟加载界面</span><br><span class="line">3）.避免反复处理数据</span><br><span class="line">4）.避免使用NSDateFormatter和NSCalendar。</span><br><span class="line"></span><br><span class="line">5）.图片缓存的取舍UIImage加载图片方式一般有两种:A：imagedNamed初始化B：imageWithContentsOfFile初始化二者不同之处在于,imageNamed默认加载图片成功后会内存中缓存图片,这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象.如果缓存中没有找到相应的图片对象,则从指定地方加载图片然后缓存对象，并返回这个图片对象.而imageWithContentsOfFile则仅只加载图片,不缓存.大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间来做这件事.当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片的，用imageWithContentsOfFile是最为经济的方式,这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间.使用场景需要编程时，应该根据实际应用场景加以区分，UIImage虽小，但使用元素较多问题会有所凸显.</span><br></pre></td></tr></table></figure></p>
<p>三、tableView的重用机制？（简单了解即可）</p>
<p>查看UITableView头文件，会找到NSMutableArray<em> visiableCells，和NSMutableDictnery</em>reusableTableCells两个结构。visiableCells内保存当前显示的cells，reusableTableCells保存可重用的cells。TableView显示之初，reusableTableCells为空，那么tableViewdequeueReusableCellWithIdentifier:CellIdentifier返回nil。开始的cell都是通过[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]来创建，而且cellForRowAtIndexPath只是调用最大显示cell数的次数。比如：有100条数据，iPhone一屏最多显示10个cell。程序最开始显示TableView的情况是：1.用<br>[[UITableViewCellalloc] initWithStyle:UITableViewCellStyleDefaultreuseIdentifier:CellIdentifier]</p>
<p>创建10次cell，并给cell指定同样的重用标识(当然，可以为不同显示类型的cell指定不同的标识)。并且10个cell全部都加入到visiableCells数组，reusableTableCells为空。2.向下拖动tableView，当cell1完全移出屏幕，并且cell11(它也是alloc出来的，原因同上)完全显示出来的时候。cell11加入到visiableCells，cell1移出visiableCells，cell1加入到reusableTableCells。3.接着向下拖动tableView，因为reusableTableCells中已经有值，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用的时候，tableViewdequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。cell1加入到visiableCells，cell1移出reusableTableCells；cell2移出visiableCells，cell2加入到reusableTableCells。之后再需要显示的Cell就可以正常重用了。</p>
<p>四、如何减小一个应用程序占用存储空间？</p>
<p>检查程序 去掉多余的xib。iOS App Store相关因素作为提交到App Store中app里的可执行文件是被加过密的。加密的副作用是可执行文件的压缩效果没有之前的好了。Build Settings编译选项，将build setting中的Optimization Level设置为Fastest, Smallest [-Os];将build setting中的Strip Debug Symbols During Copy设置为YES(COPY_PHASE_STRIP = YES)，这样可以减小编译出二进制文件的尺寸。Target针对较少的CPUs对程序指定的特定CPU类型做优化处理，以生成相对于的可执行文件。不同的硬件，将运行不同的可执行代码。虽然这样优化后的程序，只能针对某些设备运行，但是这大大减小可执行程序的大小。要想只设定特定类型的CPUs，可以修改build setting中的Architectures，将其从Standard $(ARCHS_STANDARD)修改为你希望支持的列表中对应的特定类型CPU。有效的CPU名称列在Valid Architectures (VALID_ARCHS) build setting中。请不要修改Valid Architectures设置项，最好由Xcode管理。尽量使用8-bit图片。使用8-bit的PNG图片，比32-bit的图片能减少4倍的压缩率。由于8-bit的图片支持最多256种不同的颜色，所以8-bit的图片一般只应该用于一小部分的颜色图片。例如灰度图片最好使用8-bit</p>
<p>五、如何提高一个应用程序的性能？</p>
<p>1、使用ARC减少内存失误，dealloc需要重写并对属性置nil。2、重用。3、尽量少使用透明或半透明。会产生额外的运算。4、少用运算获得圆角，不论view.maskToBounds还是layer.clipToBounds都会有很大资源开销，必须要用圆角的话不如图片本身就做成圆角。5、不要阻塞主线程。6、使用正确的容器类型。7、图片与imageView相同大小避免多余运算。8、使用懒加载。9、使用绘制。</p>
<p>六、如何优化内存？</p>
<p>（1）.用ARC管理内存ARC(Automatic ReferenceCounting,自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存。（2）.在正确的地方使用reuseIdentifier一个开发中常见的错误就是没有给UITableViewCells，UICollectionViewCells，甚至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。<br>（3）.尽量把views设置为透明如果你有透明的Views你应该设置它们的opaque属性为YES。原因是这会使系统用一个最优的方式渲染这些views。如果设为YES，渲染系统就认为这个view是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是YES。<br>（4）.避免过于庞大的XIB当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。<br>（5）.不要阻塞主线程永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。一直使用主线程的风险就是如果你的代码真的block了主线程，你的app会失去反应。大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。<br>（6）.在Image Views中调整图片大小如果要在UIImageView<br>中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是UIImageView<br>嵌套在UIScrollView<br>中的情况下。如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。<br>（7）.选择正确的Collection学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理collections时这句话尤其正确。一些常见collection的总结：·Arrays:有序的一组值。使用index来lookup很快，使用value lookup很慢，插入/删除很慢。·Dictionaries:存储键值对。用键来查找比较快。·Sets:无序的一组值。用值来查找很快，插入/删除很快。<br>（8）.打开gzip压缩大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。好消息是，iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经支持了压缩输出。<br>（9）.重用和延迟加载(lazy load) Views更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。这里我们用到的技巧就是模仿UITableView<br>和UICollectionView的操作:不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。创建views的能效问题也适用于你app的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个view的场景。有两种实现方法：1.创建并隐藏这个view当这个screen加载的时候，当需要时显示它；2.当需要时才创建并展示。每个方案都有其优缺点。用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。<br>（10）. Cache, Cache,还是Cache!一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。NSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。<br>（11）.权衡渲染方法在iOS中可以有很多方法做出漂亮的按钮。你可以用整幅的图片，可调大小的图片，uozhe可以用CALayer，CoreGraphics甚至OpenGL来画它们。当然每个不同的解决方法都有不同的复杂程度和相应的性能。简单来说，就是用事先渲染好的图片更快一些，因为如此一来iOS就免去了创建一个图片再画东西上去然后显示在屏幕上的程序。问题是你需要把所有你需要用到的图片放到app的bundle里面，这样就增加了体积–这就是使用可变大小的图片更好的地方了:你可以省去一些不必要的空间，也不需要再为不同的元素(比如按钮)来做不同的图。然而，使用图片也意味着你失去了使用代码调整图片的机动性，你需要一遍又一遍不断地重做他们，这样就很浪费时间了，而且你如果要做一个动画效果，虽然每幅图只是一些细节的变化你就需要很多的图片造成bundle大小的不断增大。总得来说，你需要权衡一下利弊，到底是要性能能还是要bundle保持合适的大小。<br>（12）.处理内存警告一旦系统内存过低，iOS会通知所有运行中app。如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.幸运的是，UIKit提供了几种收集低内存警告的方法:· 在app delegate中使用applicationDidReceiveMemoryWarning:<br>的方法· 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning<br>· 注册并接收UIApplicationDidReceiveMemoryWarningNotification的通知一旦收到这类通知，你就需要释放任何不必要的内存使用。例如，UIViewController的默认行为是移除一些不可见的view，它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。<br>（13）.重用大开销对象一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。<br>（14）.减少使用Web特性UIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。但是你可能有注意到UIWebView并不像不像驱动Safari的那么快。这是由于以JIT compilation为特色的Webkit的Nitro Engine的限制。所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。<br>（15）.优化Table ViewTable view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。为了保证table view平滑滚动，确保你采取了以下的措施:· 正确使用reuseIdentifier<br>来重用cells· 尽量使所有的view opaque，包括cell自身· 避免渐变，图片缩放，后台选人· 缓存行高· 如果cell内现实的内容来自web，使用异步加载，缓存请求结果· 使用shadowPath<br>来画阴影· 减少subviews的数量·尽量不适用cellForRowAtIndexPath:<br>，如果你需要用到它，只用一次然后缓存结果· 使用正确的数据结构来存储数据· 使用rowHeight<br>,sectionFooterHeight<br>和sectionHeaderHeight<br>来设定固定的高，不要请求delegate<br>（16）.使用Autorelease PoolNSAutoreleasePool<br>负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为：<br>NSArray <em>urls = &lt;# An array of file URLs #&gt;;for(NSURL </em>url in urls) {@autoreleasepool {NSError <em>error;NSString </em>fileContents = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];/<em> Process the string, creating and autoreleasing more objects. </em>/}}</p>
<p>这段代码在每次遍历后释放所有autorelease对象<br>（17）.选择是否缓存图片常见的从bundle中加载图片的方式有两种，一个是用imageNamed<br>，二是用imageWithContentsOfFile<br>，第一种比较常见一点。既然有两种类似的方法来实现相同的目的，那么他们之间的差别是什么呢？imageNamed<br>的优点是当加载时会缓存图片。imageNamed<br>的文档中这么说:这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。相反的，imageWithContentsOfFile<br>仅加载图片。如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用imageWithContentsOfFile<br>足矣，这样不会浪费内存来缓存它。然而，在图片反复重用的情况下imageNamed<br>是一个好得多的选择。</p>
<p>七、如何加强iOS里的列表滚动时的顺畅感？</p>
<p>1、UITableViewCell里不要添加太多subview，最好只添加一个cellview。<br>2、UITableViewCell上的子View的opaque属性设为YES。其实默认也是不透明。UITableViewCell尽量不要包含透明的子View。<br>3、在cellview里，重写drawRect函数绘制UITableViewCell的内容。<br>4、在绘制字符串时，尽可能使用drawAtPoint: withFont:，而不要使用更复杂的drawAtPoint:(CGPoint)point forWidth:(CGFloat)width withFont:(UIFont <em>)font lineBreakMode:(UILineBreakMode)lineBreakMode;如果要绘制过长的字符串，建议自己先截断，然后使用drawAtPoint: withFont:方法绘制。<br>5、在绘制图片时，尽量使用drawAtPoint，而不要使用drawInRect。drawInRect如果在绘制过程中对图片进行放缩，会特别消耗CPU。<br>6、如果绘制cell过程中，需要下载cell中的图片，建议在绘制cell一段时间后再开启图片下载任务。譬如先画一个默认图片，然后在0.5S后开始下载本cell的图片。<br>7、即使下载cell图片是在子线程中进行，在绘制cell过程中，也不能开启过多的子线程。最好只有一个下载图片的子线程在活动。否则也会影响UITableViewCell的绘制，因而影响了UITableViewCell的滑动速度。(建议结合使用NSOpeartion和NSOperationQueue来下载图片，如果想尽可能找的下载图片，可以把[self.queuesetMaxConcurrentOperationCount:4];)<br>8、最好自己写一个cache，用来缓存UITableView中的UITableViewCell，这样在整个UITableView的生命周期里，一个cell只需绘制一次，并且如果发生内存不足，也可以有效的释放掉缓存的cell。<br>9、不要将tableview的背景颜色设置成一个图片。这回严重影响UITableView的滑动速度。在限时免费搜索里，我曾经翻过一个错误：self.tableView_.backgroundColor = [UIColorcolorWithPatternImage:[UIImageimageNamed:@”background.png”]];通过这种方式设置UITableView的背景颜色会严重影响UTIableView的滑动流畅性。修改成self.tableView_.backgroundColor = [UIColor clearColor];之后，fps从43上升到60左右。滑动比较流畅。<br>10、cell的行高不是固定值，需要计算，则要尽可能缓存行高值，避免重复计算行高。这里指的是UITableViewDelegate里的行高函数。<br>八、怎么解决缓存池满的问题（cell）<br>ios中不存在缓存池满的情况，因为通常我们ios中开发，对象都是在需要的时候才会创建，有种常用的说话叫做懒加载，还有在UITableView中一般只会创建刚开始出现在屏幕中的cell，之后都是从缓存池里取，不会在创建新对象。缓存池里最多也就一两个对象，缓存池满的这种情况一般在开发java中比较常见，java中一般把最近最少使用的对象先释放。<br>//清楚cell的缓存NSArray </em>subviews = [[NSArray alloc] initWithArray:cell.contentView.subviews];for (UIView *subview in subviews) {[subview removeFromSuperview];</p>
<p>九、TableView是怎么优化的？tableView下拉加载数据的时候为什么会出现卡顿，如何解决？</p>
<p>  (1)使用不透明视图<br>（2）不要重复创建不必要的table cell。<br>（3）减少视图的数目。<br>（4）不要做多余的绘制工作。<br>（5）预渲染图像。<br>（6）不要阻塞主线程。</p>
<p>十、正常使用应用时，按HOME键退出。稍后再次打开，界面出现卡顿现象，尝试分析一下可能原因。</p>
<p>这是由iOS系统管理决定的，但APP退出在后台后，只有10秒的持续运行时间，然后暂停。但该APP还在内存中，当出现内存警告，也就是别的APP要运行，而此时内存又不足的情况下，系统会回收停在后台APP所占用的内存。如果出现这种情况，那么你再次打开你的APP，就会重新启动。不知道你是为什么要让APP在后台还要继续运行，如果非得这样，那可以使用多线程技术中的gcd，可以让APP退出后继续运行很长一段时间（大概10分钟）iOS APP类型：1.保存现场。按下Home键10秒内直接杀死进程，并释放内存。<br>iOS支持的“多任务”。按下Home键转入多任务状态，保留在内存中，但只能系统允许的动作：比如GPS，比如VoIP，比如音乐等等。3.真正的桌面级别的多任务。只有Safari/Mail是，苹果嫡系大都都不是。这个级别的app在后台没有任何限制动作。无限制动作的程序，一会在用户无察觉的情况下耗光电力，二会有安全上面的问题(那些在后台依旧默默发送你的个人消息程序)顺便提一句，后两种占用内存的app，也会在任意时间从内存中被砍掉，取决于你是否动用了其它app而导致内存不足。真正不会被砍掉的后台，只有苹果那个通知系统。</p>
<p>.什么时候会用到懒加载？如果需要展示大量图片的时候还要一个个去加载么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">懒加载，又称为延迟加载。说的通俗一点，就是在开发中，程序启动的时候不加载资源，只有在运行当需要一些资源时，再去加载这些资源。我们知道iOS设备的内存有限，如果在程序在启动后就一次性加载将来会用到的所有资源，那么就有可能会耗尽iOS设备的内存。这些资源例如大量数据，图片，音频等等</span><br></pre></td></tr></table></figure></p>
<p>工程中的图片存在哪里，如何保证刷新后内存不断增加问题，以及节约用户流量？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工程中使用的图片可以自己创建个文件夹进行存放你需要用的图片,也可以在你工程中的Images.xcassets文件中存放你的图片.解决刷新内存不断增加的问题,需要把你创建的控件布局写成对应类的属性,在ViewDidLoad中初始化一次.不要在其他的类方法里创建控件.刷新节约用户流量的方法就是在一定时间段中判断当前的请求时间和上次刷新的时间并限定一个时间范围在某个范围内刷新不重新请求数据.</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【Runtime】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ChinaArJun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿俊的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/IOS【Runtime】/" itemprop="url">IOS【Runtime】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T21:57:00+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/JAVA/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/JAVA/Python/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、runtime简介<br>RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。<br>对于C语言，函数的调用在编译的时候会决定调用哪个函数。<br>对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。<br>事实证明：<br>在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。<br>在编译阶段，C语言调用未实现的函数就会报错。<br>二、runtime作用<br>1.发送消息<br>方法调用的本质，就是让对象发送消息。<br>objc_msgSend,只有对象才能发送消息，因此以objc开头.<br>使用消息机制前提，必须导入#import &lt;objc/message.h&gt;<br>消息机制简单使用<br>clang -rewrite-objc main.m 查看最终生成代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 创建person对象</span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">// 调用对象方法</span><br><span class="line">[p eat];</span><br><span class="line"></span><br><span class="line">// 本质：让对象发送消息</span><br><span class="line">objc_msgSend(p, @selector(eat));</span><br><span class="line"></span><br><span class="line">// 调用类方法的方式：两种</span><br><span class="line">// 第一种通过类名调用</span><br><span class="line">[Person eat];</span><br><span class="line">// 第二种通过类对象调用</span><br><span class="line">[[Person class] eat];</span><br><span class="line"></span><br><span class="line">// 用类名调用类方法，底层会自动把类名转换成类对象调用</span><br><span class="line">// 本质：让类对象发送消息</span><br><span class="line">objc_msgSend([Person class], @selector(eat));</span><br></pre></td></tr></table></figure></p>
<p>消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现</p>
<p>2.交换方法<br>开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。<br>方式一:继承系统的类，重写方法.<br>方式二:使用runtime,交换方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。</span><br><span class="line">    // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;</span><br><span class="line">    // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。</span><br><span class="line">    UIImage *image = [UIImage imageNamed:@&quot;123&quot;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation UIImage (Image)</span><br><span class="line">// 加载分类到内存的时候调用</span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    // 交换方法</span><br><span class="line"></span><br><span class="line">    // 获取imageWithName方法地址</span><br><span class="line">    Method imageWithName = class_getClassMethod(self, @selector(imageWithName:));</span><br><span class="line"></span><br><span class="line">    // 获取imageWithName方法地址</span><br><span class="line">    Method imageName = class_getClassMethod(self, @selector(imageNamed:));</span><br><span class="line"></span><br><span class="line">    // 交换方法地址，相当于交换实现方式</span><br><span class="line">    method_exchangeImplementations(imageWithName, imageName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.</span><br><span class="line"></span><br><span class="line">// 既能加载图片又能打印</span><br><span class="line">+ (instancetype)imageWithName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 这里调用imageWithName，相当于调用imageName</span><br><span class="line">    UIImage *image = [self imageWithName:name];</span><br><span class="line"></span><br><span class="line">    if (image == nil) &#123;</span><br><span class="line">        NSLog(@&quot;加载空的图片&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>交换原理：<br>交换之前： </p>
<p>交换之后： </p>
<p>3.动态添加方法<br>开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。<br>经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。<br>简单使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">    // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</span><br><span class="line">    // 动态添加方法就不会报错</span><br><span class="line">    [p performSelector:@selector(eat)];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">// void(*)()</span><br><span class="line">// 默认方法都有两个隐式参数，</span><br><span class="line">void eat(id self,SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;,self,NSStringFromSelector(sel));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span><br><span class="line">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (sel == @selector(eat)) &#123;</span><br><span class="line">        // 动态添加eat方法</span><br><span class="line"></span><br><span class="line">        // 第一个参数：给哪个类添加方法</span><br><span class="line">        // 第二个参数：添加方法的方法编号</span><br><span class="line">        // 第三个参数：添加方法的函数实现（函数地址）</span><br><span class="line">        // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span><br><span class="line">        class_addMethod(self, @selector(eat), eat, &quot;v@:&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>4.给分类添加属性<br>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line">    // 给系统NSObject类动态添加属性name</span><br><span class="line"></span><br><span class="line">    NSObject *objc = [[NSObject alloc] init];</span><br><span class="line">    objc.name = @&quot;小码哥&quot;;</span><br><span class="line">    NSLog(@&quot;%@&quot;,objc.name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义关联的key</span><br><span class="line">static const char *key = &quot;name&quot;;</span><br><span class="line"></span><br><span class="line">@implementation NSObject (Property)</span><br><span class="line"></span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    // 根据关联的key，获取关联的值。</span><br><span class="line">    return objc_getAssociatedObject(self, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    // 第一个参数：给哪个对象添加关联</span><br><span class="line">    // 第二个参数：关联的key，通过这个key获取</span><br><span class="line">    // 第三个参数：关联的value</span><br><span class="line">    // 第四个参数:关联的策略</span><br><span class="line">    objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>5.字典转模型<br>设计模型：字典转模型的第一步<br>模型属性，通常需要跟字典中的key一一对应<br>问题：一个一个的生成模型属性，很慢？<br>需求：能不能自动根据一个字典，生成对应的属性。<br>解决：提供一个分类，专门根据字典生成对应的属性字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    @implementation NSObject (Log)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 自动打印属性字符串</span><br><span class="line">+ (void)resolveDict:(NSDictionary *)dict&#123;</span><br><span class="line"></span><br><span class="line">    // 拼接属性字符串代码</span><br><span class="line">    NSMutableString *strM = [NSMutableString string];</span><br><span class="line"></span><br><span class="line">    // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line"></span><br><span class="line">        // 类型经常变，抽出来</span><br><span class="line">         NSString *type;</span><br><span class="line"></span><br><span class="line">        if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123;</span><br><span class="line">            type = @&quot;NSString&quot;;</span><br><span class="line">        &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)])&#123;</span><br><span class="line">            type = @&quot;NSArray&quot;;</span><br><span class="line">        &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)])&#123;</span><br><span class="line">            type = @&quot;int&quot;;</span><br><span class="line">        &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)])&#123;</span><br><span class="line">            type = @&quot;NSDictionary&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 属性字符串</span><br><span class="line">        NSString *str;</span><br><span class="line">        if ([type containsString:@&quot;NS&quot;]) &#123;</span><br><span class="line">            str = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) %@ *%@;&quot;,type,key];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            str = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) %@ %@;&quot;,type,key];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 每生成属性字符串，就自动换行。</span><br><span class="line">        [strM appendFormat:@&quot;\n%@\n&quot;,str];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 把拼接好的字符串打印出来，就好了。</span><br><span class="line">    NSLog(@&quot;%@&quot;,strM);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>字典转模型的方式一：KVC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation Status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (instancetype)statusWithDict:(NSDictionary *)dict</span><br><span class="line">&#123;</span><br><span class="line">    Status *status = [[self alloc] init];</span><br><span class="line"></span><br><span class="line">    [status setValuesForKeysWithDictionary:dict];</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。<br>如果不一致，就会调用[<status 0x7fa74b545d60=""> setValue:forUndefinedKey:] 报key找不到的错。<br>分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。<br>解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖， 就能继续使用KVC，字典转模型了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></status></p>
<p>字典转模型的方式二：Runtime<br>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。<br>步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line">    // 解析Plist文件</span><br><span class="line">    NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil];</span><br><span class="line"></span><br><span class="line">    NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath];</span><br><span class="line"></span><br><span class="line">    // 获取字典数组</span><br><span class="line">    NSArray *dictArr = statusDict[@&quot;statuses&quot;];</span><br><span class="line"></span><br><span class="line">    // 自动生成模型的属性字符串</span><br><span class="line">//    [NSObject resolveDict:dictArr[0][@&quot;user&quot;]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _statuses = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    // 遍历字典数组</span><br><span class="line">    for (NSDictionary *dict in dictArr) &#123;</span><br><span class="line"></span><br><span class="line">        Status *status = [Status modelWithDict:dict];</span><br><span class="line"></span><br><span class="line">        [_statuses addObject:status];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试数据</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;,_statuses,[_statuses[0] user]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSObject (Model)</span><br><span class="line"></span><br><span class="line">+ (instancetype)modelWithDict:(NSDictionary *)dict</span><br><span class="line">&#123;</span><br><span class="line">    // 思路：遍历模型中所有属性-》使用运行时</span><br><span class="line"></span><br><span class="line">    // 0.创建对应的对象</span><br><span class="line">    id objc = [[self alloc] init];</span><br><span class="line"></span><br><span class="line">    // 1.利用runtime给对象中的成员属性赋值</span><br><span class="line"></span><br><span class="line">    // class_copyIvarList:获取类中的所有成员属性</span><br><span class="line">    // Ivar：成员属性的意思</span><br><span class="line">    // 第一个参数：表示获取哪个类中的成员属性</span><br><span class="line">    // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值</span><br><span class="line">    // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</span><br><span class="line">    /* 类似下面这种写法</span><br><span class="line"></span><br><span class="line">     Ivar ivar;</span><br><span class="line">     Ivar ivar1;</span><br><span class="line">     Ivar ivar2;</span><br><span class="line">     // 定义一个ivar的数组a</span><br><span class="line">     Ivar a[] = &#123;ivar,ivar1,ivar2&#125;;</span><br><span class="line"></span><br><span class="line">     // 用一个Ivar *指针指向数组第一个元素</span><br><span class="line">     Ivar *ivarList = a;</span><br><span class="line"></span><br><span class="line">     // 根据指针访问数组第一个元素</span><br><span class="line">     ivarList[0];</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line">    unsigned int count;</span><br><span class="line"></span><br><span class="line">    // 获取类中的所有成员属性</span><br><span class="line">    Ivar *ivarList = class_copyIvarList(self, &amp;count);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        // 根据角标，从数组取出对应的成员属性</span><br><span class="line">        Ivar ivar = ivarList[i];</span><br><span class="line"></span><br><span class="line">        // 获取成员属性名</span><br><span class="line">        NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line"></span><br><span class="line">        // 处理成员属性名-&gt;字典中的key</span><br><span class="line">        // 从第一个角标开始截取</span><br><span class="line">        NSString *key = [name substringFromIndex:1];</span><br><span class="line"></span><br><span class="line">        // 根据成员属性名去字典中查找对应的value</span><br><span class="line">        id value = dict[key];</span><br><span class="line"></span><br><span class="line">        // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</span><br><span class="line">        // 判断下value是否是字典</span><br><span class="line">        if ([value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">            // 字典转模型</span><br><span class="line">            // 获取模型的类对象，调用modelWithDict</span><br><span class="line">            // 模型的类名已知，就是成员属性的类型</span><br><span class="line"></span><br><span class="line">            // 获取成员属性类型</span><br><span class="line">           NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</span><br><span class="line">          // 生成的是这种@&quot;@\&quot;User\&quot;&quot; 类型 -》 @&quot;User&quot;  在OC字符串中 \&quot; -&gt; &quot;，\是转义的意思，不占用字符</span><br><span class="line">            // 裁剪类型字符串</span><br><span class="line">            NSRange range = [type rangeOfString:@&quot;\&quot;&quot;];</span><br><span class="line"></span><br><span class="line">           type = [type substringFromIndex:range.location + range.length];</span><br><span class="line"></span><br><span class="line">            range = [type rangeOfString:@&quot;\&quot;&quot;];</span><br><span class="line"></span><br><span class="line">            // 裁剪到哪个角标，不包括当前角标</span><br><span class="line">          type = [type substringToIndex:range.location];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 根据字符串类名生成类对象</span><br><span class="line">            Class modelClass = NSClassFromString(type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (modelClass) &#123; // 有对应的模型才需要转</span><br><span class="line"></span><br><span class="line">                // 把字典转模型</span><br><span class="line">                value  =  [modelClass modelWithDict:value];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</span><br><span class="line">        // 判断值是否是数组</span><br><span class="line">        if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            // 判断对应类有没有实现字典数组转模型数组的协议</span><br><span class="line">            if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;</span><br><span class="line"></span><br><span class="line">                // 转换成id类型，就能调用任何对象的方法</span><br><span class="line">                id idSelf = self;</span><br><span class="line"></span><br><span class="line">                // 获取数组中字典对应的模型</span><br><span class="line">                NSString *type =  [idSelf arrayContainModelClass][key];</span><br><span class="line"></span><br><span class="line">                // 生成模型</span><br><span class="line">               Class classModel = NSClassFromString(type);</span><br><span class="line">                NSMutableArray *arrM = [NSMutableArray array];</span><br><span class="line">                // 遍历字典数组，生成模型数组</span><br><span class="line">                for (NSDictionary *dict in value) &#123;</span><br><span class="line">                    // 字典转模型</span><br><span class="line">                  id model =  [classModel modelWithDict:dict];</span><br><span class="line">                    [arrM addObject:model];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 把模型数组赋值给value</span><br><span class="line">                value = arrM;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (value) &#123; // 有值，才需要给模型的属性赋值</span><br><span class="line">            // 利用KVC给模型中的属性赋值</span><br><span class="line">            [objc setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return objc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【使用tableView制作轮播图】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ChinaArJun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿俊的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/IOS【使用tableView制作轮播图】/" itemprop="url">IOS【使用tableView制作轮播图】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T21:55:08+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载请注明出处：<br><a href="http://www.jianshu.com/p/01d5aba5dd68" target="_blank" rel="noopener">http://www.jianshu.com/p/01d5aba5dd68</a></p>
<p>在实际开发中,或许也有人有我这样的疑惑，想利用tableView Cell的重用机制,去更佳优化app的内存，就会想到这方面的性能优化。<br>在网上查询了下，很少看到关于tableView轮播器的相关资料，干脆的自己写了一个希望大家喜欢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tableScrollViewPage</span><br><span class="line">Use a table view do the picture carousel device, </span><br><span class="line">the use of infinite loops and cell multiplexing </span><br><span class="line">and better performance, like please point star, thank you</span><br></pre></td></tr></table></figure></p>
<p>使用tableView表格视图 做的 图片轮播器 ， 使用了无限循环 和 cell复用，<br>tableView性能大家都知道，已经进行了封装，只需根据需求进行简单改动，<br>喜欢请点星，谢谢</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2692013-c0492d409977e9ef.gif?imageMogr2/auto-orient/strip" alt="tableScrollViewGif.gif"><br>github地址 <a href="https://github.com/ChinaArJun/TableScrollViewPage" target="_blank" rel="noopener">https://github.com/ChinaArJun/TableScrollViewPage</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【电商项目-高仿-爱鲜蜂-OC版】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ChinaArJun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿俊的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/IOS【电商项目-高仿-爱鲜蜂-OC版】/" itemprop="url">IOS【电商项目: 高仿<爱鲜蜂> OC版】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T21:54:39+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在做抽出一点空余时间仿了一款爱鲜蜂项目 </p>
<p>效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2692013-1ddca28220aa9f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-0b594aa0aaad1a9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-6d50d915f9079c12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-1759cbb0a7fcca36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p>
<p>github : <a href="https://github.com/ChinaArJun/loveFreshPeakApp_oc" target="_blank" rel="noopener">https://github.com/ChinaArJun/loveFreshPeakApp_oc</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【webSocket-socket-io-ios使用指南】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ChinaArJun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿俊的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/IOS【webSocket-socket-io-ios使用指南】/" itemprop="url">IOS【webSocket- socket.io_ios使用指南】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T21:54:19+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>要指定https在你的socketURL参数中.</p>
<blockquote>
<p>convenience init(socketURL: NSURL, options: NSDictionary?)</p>
</blockquote>
<p>同上, 但是为了ObjC准备,使用字典.</p>
<blockquote>
<p> Options</p>
</blockquote>
<p>所有关于SocketIOClientOption的设置.如果是ObjC,转换名字lowerCamelCase.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">case ConnectParams([String: AnyObject]) // 通过字典内容连接</span><br><span class="line">case Cookies([NSHTTPCookie]) // An array of NSHTTPCookies. Passed during the handshake. Default is nil.</span><br><span class="line">case DoubleEncodeUTF8(Bool) // Whether or not to double encode utf8. If using the node based server this should be true. Default is true.</span><br><span class="line">case ExtraHeaders([String: String]) // 添加自定义请求头初始化来请求, 默认为nil</span><br><span class="line">case ForcePolling(Bool) // 是否使用 xhr-polling. Default is `false`</span><br><span class="line">case ForceNew(Bool) // 将为每个连接创建一个新的connect, 如果你在重新连接时有bug时使用.</span><br><span class="line">case ForceWebsockets(Bool) // 是否使用 WebSockets. Default is `false`</span><br><span class="line">case HandleQueue(dispatch_queue_t) // 调度handle的运行队列. Default is the main queue.</span><br><span class="line">case Log(Bool) // 是否打印调试信息. Default is false.</span><br><span class="line">case Logger(SocketLogger) // 可自定义SocketLogger调试日志.默认是系统的.</span><br><span class="line">case Nsp(String) // 如果使用命名空间连接. Must begin with /. Default is `/`</span><br><span class="line">case Path(String) // 如果服务器使用一个自定义路径. 例如: `&quot;/swift/&quot;`. Default is `&quot;&quot;`</span><br><span class="line">case Reconnects(Bool) // 是否重新连接服务器失败. Default is `true`</span><br><span class="line">case ReconnectAttempts(Int) // 重新连接多少次. Default is `-1` (无限次)</span><br><span class="line">case ReconnectWait(Int) // 等待重连时间. Default is `10`</span><br><span class="line">case SessionDelegate(NSURLSessionDelegate) // NSURLSessionDelegate 底层引擎设置. 如果你需要处理自签名证书. Default is nil.</span><br><span class="line">case Secure(Bool) // 如果连接要使用TLS. Default is false.</span><br><span class="line">case SelfSigned(Bool) //  WebSocket.selfSignedSSL设置 (Don&apos;t do this, iOS will yell at you)</span><br><span class="line">case VoipEnabled(Bool) // 如果你的客户端使用VoIP服务,只有用这个选项,Default is false</span><br></pre></td></tr></table></figure></p>
<p>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">on(event: String, callback: NormalCallback) -&gt; NSUUID // 给一个事件添加一个句柄. Items are passed by an array. 可以发送ack请求. 例如,返回一个唯一ID.</span><br><span class="line">once(event: String, callback: NormalCallback) -&gt; NSUUID // 同上,但只执行一次.</span><br><span class="line">onAny(callback:((event: String, items: AnyObject?)) -&gt; Void) //可以给所有事件添加一个句柄. event可以接收任何事件.</span><br><span class="line">emit(event: String, _ items: AnyObject...) // 发送一个或多条消息.</span><br><span class="line">emit(event: String, withItems items: [AnyObject]) // emit for Objective-C</span><br><span class="line">emitWithAck(event: String, _ items: AnyObject...) -&gt; (timeoutAfter: UInt64, callback: (NSArray?) -&gt; Void) -&gt; Void // 给服务器发送一个ack确认请求. 返回一个函数,你可以用它添加一个句柄. 注意: 直到你调用这个返回函数,才会发送消息</span><br><span class="line">emitWithAck(event: String, withItems items: [AnyObject]) -&gt; (UInt64, (NSArray?) -&gt; Void) -&gt; Void // 同上,为Objective-C准备的 </span><br><span class="line">connect() // 建立一个连接到服务器. 连接成功会触发 &quot;connect&quot;事件</span><br><span class="line">connect(timeoutAfter timeoutAfter: Int, withTimeoutHandler handler: (() -&gt; Void)?) // 连接到服务器. 如果连接超时,会调用handle</span><br><span class="line">disconnect() // Closes the socket. 重开一个断开连接的socket还没完全测试.</span><br><span class="line">reconnect() // Causes the client to reconnect to the server.</span><br><span class="line">joinNamespace(namespace: String) - Causes the client to join namespace. 不应该被调用,除非你手动改变命名空间.</span><br><span class="line">leaveNamespace() // Causes the client to leave the nsp and go back to &apos;/&apos;</span><br><span class="line">off(event: String) - Removes all event handlers for event.</span><br><span class="line">off(id id: NSUUID) - Removes the event that corresponds to id.</span><br><span class="line">removeAllHandlers() - Removes all handlers.</span><br></pre></td></tr></table></figure></p>
<p>客户端的事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connect – 当成功连接时Emitted</span><br><span class="line">disconnect – 当连接断开Emitted</span><br><span class="line">error – 发送错误时Emitted</span><br><span class="line">reconnect – 当开始重连时Emitted</span><br><span class="line">reconnectAttempt – 当尝试重连时Emitted</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【开发经验之谈—正则表达式实现图文混排】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ChinaArJun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿俊的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/IOS【开发经验之谈—正则表达式实现图文混排】/" itemprop="url">IOS【开发经验之谈—正则表达式实现图文混排】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T21:53:44+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在项目中，我们经常需要发表情，以及经常需要将表情字符转换成表情。因为表情是一个图片，所以我们发给服务器的时候，实际上是发一段特殊的文字给服务器，然后转换成表情。以免浪费用户过多的流量。<br>那接下来，我们就来介绍一下，如何使用正则表达式实现图文混排呢？<br>为了以后的代码的管理方便，我们抽取出两个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> NSString+Regular.h中，我们暴露两个方法出来：</span><br><span class="line"> /**</span><br><span class="line"> *  返回正则表达式匹配的第一个结果</span><br><span class="line"> *</span><br><span class="line"> *  @param pattern 正则表达式</span><br><span class="line"> *</span><br><span class="line"> *  @return 匹配的第一个结果 是NSTextCheckingResult类型</span><br><span class="line"> */</span><br><span class="line">-(NSTextCheckingResult *)firstMacthWithPattern:(NSString *)pattern;</span><br><span class="line"></span><br><span class="line">-(NSArray &lt;NSTextCheckingResult *&gt; *)machesWithPattern:(NSString *)pattern;</span><br></pre></td></tr></table></figure></p>
<p>NSString+Regular.m中，我们实现一下这两个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (NSTextCheckingResult *)firstMacthWithPattern:(NSString *)pattern</span><br><span class="line">&#123;</span><br><span class="line">    //正则表达式的创建很容易失败，注意捕获错误</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    //根据正则表达式创建实例</span><br><span class="line">    NSRegularExpression *regular = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:&amp;error];</span><br><span class="line">    if ( error)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;正则表达式创建失败&quot;);</span><br><span class="line"></span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //匹配出结果</span><br><span class="line">  NSTextCheckingResult *result =   [regular firstMatchInString:self options:0 range:NSMakeRange(0, self.length)];</span><br><span class="line"></span><br><span class="line">    if ( result)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;匹配&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;不匹配&quot;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray &lt;NSTextCheckingResult *&gt; *)machesWithPattern:(NSString *)pattern</span><br><span class="line">&#123;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:&amp;error];</span><br><span class="line">    if (error)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;正则表达式创建失败&quot;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return [expression matchesInString:self options:0 range:NSMakeRange(0, self.length)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们进而对NSTextAttachment写一个子类 ZYTextAttachment.h 中 我们暴露一个方法出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface ZYTextAttachment : NSTextAttachment</span><br><span class="line">- (instancetype)initWithImage:(UIImage *)image;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>ZYTextAttachment.m中，我们实现一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZYTextAttachment.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZYTextAttachment</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithImage:(UIImage *)image</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init])</span><br><span class="line">    &#123;</span><br><span class="line">        self.image = image;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGRect)attachmentBoundsForTextContainer:(NSTextContainer *)textContainer proposedLineFragment:(CGRect)lineFrag glyphPosition:(CGPoint)position characterIndex:(NSUInteger)charIndex</span><br><span class="line">&#123;</span><br><span class="line">    return CGRectMake(0, -lineFrag.size.height * 0.2, lineFrag.size.height, lineFrag.size.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就能解决图片大写跟文字大小不一致的情况。</p>
<p>接下来，我们在viewController中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    self.label.text = @&quot;二货[smiley_2], 你在干嘛呢[smiley_6] 一起吃饭？[smiley_44]!&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在下面的方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    NSString *content = self.label.text;</span><br><span class="line">    //匹配表情文字</span><br><span class="line">    NSString *pattern = @&quot;\\[\\w+\\]&quot;;</span><br><span class="line"></span><br><span class="line">  NSArray *resultArr =   [content machesWithPattern:pattern];</span><br><span class="line">    if (!resultArr) return;</span><br><span class="line"></span><br><span class="line">    NSMutableAttributedString *attrContent = [[NSMutableAttributedString alloc]initWithString:content];</span><br><span class="line">    NSUInteger lengthDetail = 0;</span><br><span class="line">    //遍历所有的result 取出range</span><br><span class="line">    for (NSTextCheckingResult *result in resultArr) &#123;</span><br><span class="line">        //取出图片名</span><br><span class="line">      NSString *imageName =   [content substringWithRange:NSMakeRange(result.range.location + 1, result.range.length - 2)];</span><br><span class="line">        // 创建AttributeString, 来包装图片</span><br><span class="line">      ZYTextAttachment *attachment =   [[ZYTextAttachment alloc]initWithImage:[UIImage imageNamed:imageName]];</span><br><span class="line">        // 将附近包装到NSAttributedString中</span><br><span class="line">      NSAttributedString *imageString =   [NSAttributedString attributedStringWithAttachment:attachment];</span><br><span class="line">        //图片附件的文本长度是1</span><br><span class="line">        NSLog(@&quot;%zd&quot;,imageString.length);</span><br><span class="line"></span><br><span class="line">        NSUInteger length = attrContent.length;</span><br><span class="line">        NSRange newRange = NSMakeRange(result.range.location - lengthDetail, result.range.length);</span><br><span class="line">        [attrContent replaceCharactersInRange:newRange withAttributedString:imageString];</span><br><span class="line"></span><br><span class="line">        lengthDetail += length - attrContent.length;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //更新到label上</span><br><span class="line">    self.label.attributedText = attrContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看一下效果：<br> <img src="http://upload-images.jianshu.io/upload_images/2692013-2bedf01d7be485cb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正则"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-6c4715f65891302e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正则表情"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【tabBar框架之-tabbar动画-TabBarsAnimationDemo】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ChinaArJun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿俊的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/IOS【tabBar框架之-tabbar动画-TabBarsAnimationDemo】/" itemprop="url">IOS【tabBar框架之 tabbar动画 TabBarsAnimationDemo】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T21:53:19+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在iOS原生的tabBar中，能够实现按钮的点击事件，能够实现视图控制器的切换等，但是在实际工程中，对于tabBar的要求的功能往往是系统自己实现不了的，所以我们这里就需要用到自定义的tabBar了。<br>对于tabBar上展示视图控制器，我们会采用的是在把几个视图控制直接加载到tabBarController上去。这里新建三个视图控制器，由于在<br>一、系统样式<br>ViewController会有其他代码，所以我们这里另一写一个类，在这里只设置一个背景颜色就可以了。所以我们先新建一个类叫做ViewController，让它继承自UIViewController。这里设置视图的背景颜色，这里可以设置为随机色。</p>
<p>TabBarsAnimationDemo — 底部菜单push隐藏菜单栏动画（仿IOS京东效果）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2692013-4d92e4a6e2bbb922.gif?imageMogr2/auto-orient/strip" alt="B843B34D-9398-4A2E-B1C8-313D5EE8F6D5.gif"></p>
<p>git - <a href="https://github.com/ChinaArJun/TabBarsAnimationDemo" target="_blank" rel="noopener">https://github.com/ChinaArJun/TabBarsAnimationDemo</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【视频直播-高仿腾讯旗下-NOW直播-映客直播类型】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ChinaArJun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿俊的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/IOS【视频直播-高仿腾讯旗下-NOW直播-映客直播类型】/" itemprop="url">IOS【视频直播:高仿腾讯旗下<NOW直播>映客直播类型】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T21:52:53+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>效果图如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2692013-816da1bb2715290b.gif?imageMogr2/auto-orient/strip" alt="NowGif.gif"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2692013-9d2bcdf7a4c44812.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4349FA93-F15B-4287-9162-3AA27B223A72.png"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-11f7a449788fa21f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FA783124-4B81-455F-A6E6-461ACA874478.png"></p>
<p>处理了对IPad版本的适配<br><img src="http://upload-images.jianshu.io/upload_images/2692013-f02786c10a04c44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img_0257.png"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-b491b9b91e448cd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img_0258.png"></p>
<h1 id="随着直播市场的火热，市场大军都逐步进入直播市场-，腾讯旗下的NOW直播也不例外"><a href="#随着直播市场的火热，市场大军都逐步进入直播市场-，腾讯旗下的NOW直播也不例外" class="headerlink" title="随着直播市场的火热，市场大军都逐步进入直播市场 ，腾讯旗下的NOW直播也不例外"></a>随着直播市场的火热，市场大军都逐步进入直播市场 ，腾讯旗下的NOW直播也不例外</h1><p>先说说直播设计底层</p>
<h4 id="一-、流媒体"><a href="#一-、流媒体" class="headerlink" title="一 、流媒体"></a>一 、流媒体</h4><h6 id="1-伪流媒体"><a href="#1-伪流媒体" class="headerlink" title="1 - 伪流媒体"></a>1 - 伪流媒体</h6><p>  1.1 扫盲:边下载边播放<br>  1.2 伪流媒体:视频不是实时播放的,先把视频放在数据库,再供客户端访问,比如:优酷,爱奇艺等</p>
<p>  1.3 特点:</p>
<blockquote>
<p>边下边存,文件会保存.<br>遵守了 HTTP 协议,但是没有遵守 RTMP 和 HLS 协议<br>能够实现快进和快退的功能<br>实现简单,成本低</p>
</blockquote>
<p>######2 实时流媒体</p>
<p>  2.1 真正的流媒体,边下边播,但不会保存下载的文件</p>
<p>  2.2 特点:</p>
<blockquote>
<p>下载的文件不会保存<br>遵守了 RTMP 或者 HLS 协议<br>只能实现实时播放,不能快进或者快退<br>实现成本比较高,实现复杂</p>
</blockquote>
<h6 id="3-常见的流媒体协议-HLS-苹果基于-HTTP-开发的流媒体协议-RTMP-Adobe-的私有协议-MMS-微软"><a href="#3-常见的流媒体协议-HLS-苹果基于-HTTP-开发的流媒体协议-RTMP-Adobe-的私有协议-MMS-微软" class="headerlink" title="3 常见的流媒体协议: HLS(苹果基于 HTTP 开发的流媒体协议),RTMP(Adobe 的私有协议),MMS (微软)."></a>3 常见的流媒体协议: HLS(苹果基于 HTTP 开发的流媒体协议),RTMP(Adobe 的私有协议),MMS (微软).</h6><blockquote>
<p>HLS协议<br>  1 HLS: HTTP Live Streaming 是苹果公司实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在iOS系统，为iOS设备提供音视频直播和点播方案.</p>
</blockquote>
<blockquote>
<p>  2 直播原理:通过相关设备采集摄像头的视频和麦克风的音频,并实时进行 H264视频编码和 AAC 音频音频编码,并按照 HLS协议规范,转换为标准的 TS文件以及m3u8(是一个地址,里面记录了服务器多对应的文件)索引文件.</p>
</blockquote>
<blockquote>
<p>  3 HLS 点播:就是对 HTTP 进行分段播放,不同的就是在于对 HTTP 进行的分段非常小,因此可以说, HLS 点播的重点就是对 HTTP 进行分段.(现在的分段技术比较常见不在赘述)</p>
</blockquote>
<blockquote>
<p>  4 HLS 直播原理:和其他的常见的直播协议(如: RTMP,RTSP,MMS)不同, 遵守HLS 协议的直播在客户端接收到的并不是完整的数据流. 即HLS 协议的服务器将最新获取到的片段进行分割为小片段,客户端获取服务器刚编好的最新的片段进行播放.这样服务器端不断的获取新的数据进行分割成新的片段,客户端不断的从服务器端获取最近的片段进行播放.由此可以说 HLS 是以点播的形式实现的直播.</p>
</blockquote>
<blockquote>
<p>  5 HLS 的特点：由于数据是通过 HTTP 传输的,所以不用考虑防火墙和代理的问题，由于分割的时长很短,所以客户端可以很快的实现码率切换,以适应不同的带宽.HLS 协议的延迟一般会高于其他协议的流媒体直播.<br>  6 HLS 实现步骤采取视频源和音频源数据对原始数据尽心 H264和 ACC 编码视频和音频数据封装为 MPEG-TS 包 HLS 分段生成策略以及 m3u8索引文件  HTTP 传输协议<br>注:需要说明的是 HLS 分段策略的分段时长以10S 为最好.</p>
</blockquote>
<h4 id="二-、RTMP-协议"><a href="#二-、RTMP-协议" class="headerlink" title="二 、RTMP 协议"></a>二 、RTMP 协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1 RTMP 实时消息传输协议,是现在比较常用的协议</span><br><span class="line">2 RTMP使用原理:首先推流到 RTMP 服务器,然后再有 RTMP 服务器提供 RTMP 视频服务.</span><br><span class="line">注:需啊说明的是:RTMP 也提供 HLS, 将音视频切位 ts 流,然后用户可以直接播放 m3u8流媒体.</span><br><span class="line"></span><br><span class="line">3 RTMP协议规定</span><br><span class="line">3.1 建立一个网络连接</span><br><span class="line">3.2 建立一个网络流(发送多媒体的通道)</span><br><span class="line">注:只能建立一个网络连接,但是可以建立多个网络流</span><br><span class="line"></span><br><span class="line">4 RTMP 协议使用步骤</span><br><span class="line">4.1 握手:RTMP 协议都是以握手开始的</span><br><span class="line"></span><br><span class="line">客户端先发送 C0,C1两个数据块,服务器收到 C1或者 C2块的时候开始发送 S0和 S1</span><br><span class="line">客户端收齐 S0和 S1的时候开始发送 C2,当服务器收齐 C0和 C1的时候开始发送 S2</span><br><span class="line">当客户端收到 S2同时服务器收到 C2 的时候,握手完成</span><br><span class="line">4.2 建立连接:建立客户端和服务器端的网络连接</span><br><span class="line"></span><br><span class="line">&gt; 客户端发送命令消息中的”connect”,到服务器,请求与一个服务器应用实例建立连接</span><br><span class="line">&gt; 服务器接收到请求后,发送确认消息,同时连接到请求中的连接实例</span><br><span class="line">&gt; 服务器发送设置带宽协议消息到客户端</span><br><span class="line">&gt; 客户端接收到 设置带宽 消息之后,发送确认消息到服务器</span><br><span class="line">&gt; 服务器发送用户控制消息中的”stream”消息到客户端</span><br><span class="line">&gt; 服务器发送消息命令中的”结果”消息到客户端</span><br><span class="line"></span><br><span class="line">4.3 建立流:建立客户端和服务器端的”流连接”</span><br><span class="line"></span><br><span class="line">&gt; 客户端发送消息命令中的”创建流”到服务器</span><br><span class="line">&gt; 服务器接收到”创建流”命令后,发送”结果”命令到客户端</span><br><span class="line"></span><br><span class="line">4.4 播放传输音视频数据</span><br><span class="line"></span><br><span class="line">&gt; 客户端发送”播放”命令到服务器</span><br><span class="line">&gt; 服务器收到消息后,发送 设置消息大小协议消息</span><br><span class="line">&gt; 服务器发送” streambegin”,告知客户端流 ID</span><br><span class="line">&gt; 若播放成功的话,服务器发送”响应状态”到客户端.告知客户端播放成功</span><br><span class="line">&gt; 服务器发送客户端要播放是数据</span><br></pre></td></tr></table></figure>
<p>流媒体的播放</p>
<blockquote>
<p>1 HLS 的流媒体通过AVPlayer/AVPlayerViewController 和 MPMviePlayerController/MPMoviePlayerViewController 来实现.<br>2 RTMP 的流媒体要用第三方框架实现 如 FFMpeg ,IJKPlayer和 VLC 等<br>3 常用的流媒体框架:百度/阿里/腾讯/网易/斗鱼直播伴侣/七牛云等</p>
</blockquote>
<p>-项目主要是基于<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">ijkplayer </a>的. 最好是打包成framework<br>. 我也准备好了一份打包好的分享给大家<br>-百度云盘链接:<a href="https://pan.baidu.com/s/1smNcwsX" target="_blank" rel="noopener">https://pan.baidu.com/s/1smNcwsX</a>  密码:xpsq</p>
<p>打开项目记得用真机测试哦，不然模拟器会有音频跟不上失真的现象哦<br>github  -&gt; <a href="https://github.com/ChinaArJun/Tencent-NOW" target="_blank" rel="noopener">https://github.com/ChinaArJun/Tencent-NOW</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ChinaArJun</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChinaArJun</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
