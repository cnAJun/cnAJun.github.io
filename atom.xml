<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿俊的博客</title>
  
  <subtitle>每天成长一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/"/>
  <updated>2018-11-29T14:12:23.083Z</updated>
  <id>github.com:ChinaArJun/ChinaArJun.github.io.git/</id>
  
  <author>
    <name>iOS阿俊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MAC【解决Mac版本 Sublime text3安装Package Control问题】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/02web%E8%A7%A3%E5%86%B3Mac%E7%89%88%E6%9C%AC%20Sublime%20text3%E5%AE%89%E8%A3%85Package%20Control%E9%97%AE%E9%A2%98/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/02web解决Mac版本 Sublime text3安装Package Control问题/</id>
    <published>2018-11-29T14:12:14.000Z</published>
    <updated>2018-11-29T14:12:23.083Z</updated>
    
    <content type="html"><![CDATA[<h4 id="准备学习Weex开发，因为使用sublime比较方便轻量，就在这个上面安装些插件吧。"><a href="#准备学习Weex开发，因为使用sublime比较方便轻量，就在这个上面安装些插件吧。" class="headerlink" title="准备学习Weex开发，因为使用sublime比较方便轻量，就在这个上面安装些插件吧。"></a>准备学习Weex开发，因为使用sublime比较方便轻量，就在这个上面安装些插件吧。</h4><h4 id="其实自己遇到了较多的坑，还是不仔细哈哈"><a href="#其实自己遇到了较多的坑，还是不仔细哈哈" class="headerlink" title="其实自己遇到了较多的坑，还是不仔细哈哈"></a>其实自己遇到了较多的坑，还是不仔细哈哈</h4><h2 id="1-下载Sublime3"><a href="#1-下载Sublime3" class="headerlink" title="1.下载Sublime3"></a>1.下载Sublime3</h2><p><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">https://www.sublimetext.com/3</a></p><h2 id="2-安装Package-Control"><a href="#2-安装Package-Control" class="headerlink" title="2.安装Package Control"></a>2.安装Package Control</h2><p>在线安装： <a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">https://packagecontrol.io/installation</a> 因为网络原因可能失败。</p><p>离线安装：</p><p>下载地址： <a href="https://github.com/wbond/package_control" target="_blank" rel="noopener">https://github.com/wbond/package_control</a></p><p>1.把下载好的zip包解压，重命名为Package Control。</p><p>2.打开Sublime3</p><pre><code>菜单-&gt;Preferences-&gt;Browse Packages...然后复制Package Control文件夹到该目录、  MAC版本注意： Mac位置:/Users/用户名/Library/Application Support/Sublime Text 3/Installed Packages 3.重启Sublime3,如果菜单-&gt;Preferences有Package Setting和Package Control就说明安装成功。 4.Ctrl+Shift+p输入install选中Install Package回车就可以安装插件。 然后，你会发现遇到问题，也许是“There Are No Packages Available For Installation” 不要慌张 网上说了挺多原因，简单例举一下： 1、IPV6的问题 2、无法打开网址[https://packagecontrol.io/channel_v3.json](https://packagecontrol.io/channel_v3.json)导致访问不了 简单试一下都不行，最后我经过实验得出原因是：官方提供的Package Control就是不能用。将官方的那个Package Control删除了，自己进行添加Package Control便可以了！ 具体步骤： 1、Package Control下载网址：[Package Control下载链接](https://github.com/wbond/sublime_package_control) 下载之后将其解压后，将解压文件重新命名为：Package Control 严格按照上面明明，首字母记住要大些！！！ 2、打开Sublime，点击：首选项-&gt;浏览程序包，便会打开一个文件夹！ 然后删除这个文件夹中已有的”Package Control文件夹”，将刚才自己下载好的并且重新命名的Package Control复制到该文件夹下，然后重新启动Sublime，这样便可以使用Package Control来安装其他插件了！ 这样就能解决问题了。然后安装自己想要的插件。各种高亮都没有问题</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;准备学习Weex开发，因为使用sublime比较方便轻量，就在这个上面安装些插件吧。&quot;&gt;&lt;a href=&quot;#准备学习Weex开发，因为使用sublime比较方便轻量，就在这个上面安装些插件吧。&quot; class=&quot;headerlink&quot; title=&quot;准备学习Weex
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>APP【移动动态化方案在蜂鸟的架构演进（含React Native与Weex对比）】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/APP%E3%80%90%E7%A7%BB%E5%8A%A8%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E5%9C%A8%E8%9C%82%E9%B8%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%EF%BC%88%E5%90%ABReact-Native%E4%B8%8EWeex%E5%AF%B9%E6%AF%94%EF%BC%89%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/APP【移动动态化方案在蜂鸟的架构演进（含React-Native与Weex对比）】/</id>
    <published>2018-11-29T14:07:44.000Z</published>
    <updated>2018-11-29T15:32:10.622Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最近在准备学习一门跨平台语言时候表示很纠结，学习一门语言时间紧迫，-必须学到有用又适应市场的一门语言"><a href="#最近在准备学习一门跨平台语言时候表示很纠结，学习一门语言时间紧迫，-必须学到有用又适应市场的一门语言" class="headerlink" title="最近在准备学习一门跨平台语言时候表示很纠结，学习一门语言时间紧迫，   必须学到有用又适应市场的一门语言"></a>最近在准备学习一门跨平台语言时候表示很纠结，学习一门语言时间紧迫，   必须学到有用又适应市场的一门语言</h3><p>   直到看到这篇文章后就恍然大悟了，刚好饿了么也是一路采坑过来的，必须借鉴学习一下，说明最值得学习的还是阿里系Weex，体验什么的也比RN要好不少</p><p>当下，移动动态化已经成为各大公司都回避不了的问题，产品的快速迭代对技术提出了更高的要求，而移动端的动态化方案也是层出不穷：Hypid、结构化 Native View、React Native、Weex，什么样的方案才是适合自己团队的呢？本文将分享饿了么蜂鸟团队在过去两年多业务快速增长过程中，移动动态化方面的实践和探索。</p><h3 id="什么是移动动态化？"><a href="#什么是移动动态化？" class="headerlink" title="什么是移动动态化？"></a>什么是移动动态化？</h3><p>移动指的是移动端，包括安卓、iOS。动态化则是动态部署和逻辑下发到客户端的能力。移动动态最好的状态就是让移动应用和 Web 一样，想发就发！</p><p>为什么移动端要强调动态化的能力？</p><p>原因有如下三大点：</p><pre><code>业务迭代太快。当下大部分团队都是敏捷开发的模式，即使两周做一次迭代，产品周期还是会觉得长，有些应用不能及时上线。应用市场审核慢。安卓基本当天发应用市场，当天就能够有更新。但 iOS 需要约 3-4 天来审核。假设有些功能需要定时上线，iOS 审核时间必须要考虑进去。用户升级周期长。统计表明，每一个安卓版本发布，一周内会有 70% 的用户更新，一个月其余用户才能陆续完成更新。</code></pre><p>移动动态化方案共性，有如下三点：</p><pre><code>跨平台。布局。约定 DSL，保证渲染性能。逻辑。Android 和 iOS 必须共用解释器。</code></pre><h3 id="蜂鸟团队的现状与业务特点"><a href="#蜂鸟团队的现状与业务特点" class="headerlink" title="蜂鸟团队的现状与业务特点"></a>蜂鸟团队的现状与业务特点</h3><p>蜂鸟团队现状</p><p>蜂鸟团队于 2014 年成立，初衷是为了承接饿了么的物流业务。随着时间推移，订单量从每日几千单到百万单，配速员也达到百万数量，服务品类涉及外卖、商超、鲜花、蛋糕、文件等，蜂鸟提供全时段配送，配送服务覆盖全国 1200 多个城市。</p><p>蜂鸟团队的业务特点</p><p>蜂鸟团队的业务主要有离散性和突发性两大特点，如下图：</p><p>[图片上传中…(image-bdf201-1522679509307-23)]</p><p>从业务曲线可以看到两个很明显的波峰，这是午、晚用餐时间。同时，如果运营方面配置一些活动，会导致这两个波峰徒增。所以，动态方案要想把这两个时间段服务好，必须要考虑流量陡增下的性能压力。</p><h3 id="蜂鸟团队的技术特点和挑战"><a href="#蜂鸟团队的技术特点和挑战" class="headerlink" title="蜂鸟团队的技术特点和挑战"></a>蜂鸟团队的技术特点和挑战</h3><p>蜂鸟团队的技术特点和挑战，我主要分享重度依赖、网络环境复杂、重度使用和 28 定律这四个方面。</p><p>重度依赖</p><p>当前蜂鸟有众包、团队和送送三部分业务，右侧是一些功能展示，如下图：</p><p><a href="http://s5.51cto.com/wyfs02/M02/9E/C6/wKioL1mWQijhiveCAADLUbLqxfc678.jpg" target="_blank" rel="noopener">[图片上传中…(image-a9c71a-1522679509305-22)]</a> </p><p>这样的工具型应用，需要对 APP 有更强的控制、监控等能力。必要时还要做到强制更新。</p><p>对应到动态方案的话，控制能力就需要动态方案必须具备动态降级的能力、监控能力，实时的性能监控和业务埋点监控。强制更新方面，动态方案必须做到用户无感知的热更新。</p><p>网络环境复杂</p><p>饿了么小哥，每天穿梭在大街小巷、地下商超，他们的网络环境非常不稳定。据统计，有近 25% 的用户请求还来自非 4G 环境。</p><p>整体来说的网络环境复杂、信号差和 DNS 污染，那么动态方案就要解决 DNS 拦截、弱网环境下资源下发等问题。</p><p>重度使用</p><p>无论是下雨、下雪，还是发洪水大家都会叫饿了么。</p><p>配送员在高峰期的运动曲线，如下图：</p><p><a href="http://s1.51cto.com/wyfs02/M00/9E/C6/wKioL1mWQlqC5OOcAADG7ST6baA277.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>面对这样争分夺秒的准时达压力，如果动态方案不给力，会导致应用出现崩溃或卡顿，骑手必定不会有好的体验，甚至影响送餐时间。所以我们的动态方案一定要保证性能和稳定性。</p><p>28定律</p><p>相信很多公司的应用都符合类似 28 定律，蜂鸟也不例外。</p><p>如下图，蜂鸟的 28 定律：</p><p><a href="http://s5.51cto.com/wyfs02/M02/9E/C6/wKioL1mWQnTxXSK9AACC7MtQnPI175.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>可以从图中看出，大部分骑手日常使用的主流层面，可以采用 Native 来开发，这部分重度使用的占比约 20%，其余 80% 的功能都可以考虑动态化方案（H5）。</p><h3 id="蜂鸟团队的动态化架构演进"><a href="#蜂鸟团队的动态化架构演进" class="headerlink" title="蜂鸟团队的动态化架构演进"></a>蜂鸟团队的动态化架构演进</h3><p>蜂鸟的动态方案经过 Hypid、React Native 和 Weex 三个主要阶段。</p><p>第一阶段：Hypid</p><p>在 Hypid 方案上，以 H5 的动态性为基础，通过 Jspidge 做桥梁，与 Native 进行通信，之后通过 URL Router 进行跳转，架构如下图：</p><p><a href="http://s1.51cto.com/wyfs02/M00/9E/C7/wKioL1mWQwiCr3PkAACDqX-fg-k465.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>这套动态方案的优点显而易见，这里主要介绍开发效率、更新体验和跨平台三方面：</p><pre><code>开发效率。Web 经过多年的应用实践，已经拥有完整的开发流程和开发工具，开发一个 H5 页面非常快速。开发效率这一因素不能忽略，因为初期产品的想法和落地速度会直接影响产品的命运。如蜂鸟送送，初期没有原生的资源去支撑，就用原生包壳，内部全部用 H5，这样的情况坚持了两月左右，为蜂鸟送送前期的方案验证做了很大的贡献。更新体验。因 H5 和原生耦合只有扩展的 Native API，只要把这些 API 维护足够全，开发的业务功能就可以在完全不用更新 APK 的情况下，做到热更新。且用户下一次打开应用是最新的，这和 Native 的升级体验相比简直是一天一地。</code></pre><p>跨平台。之前安卓和 iOS 代码需要开发两次，现在一个功能决定用 H5 后，由一个工程师来开发一套代码即可。</p><p>这套动态方案很大的缺点就是用户体验差，当用 H5 做一些复杂的功能或动画时，可能会卡顿的和 PPT 一样。因为 H5 的体验问题，蜂鸟的原则是经常更新的且功能不复杂的页面会选择用 H5。</p><p>第二阶段：React Native</p><p>这个动态方案完全脱离了以 H5 为基础的 Hypid 方案，通过自定义 DSL 将 UI 渲染成原生控件，这样一来， RN 的页面就保证了原生的体验和 Web 的效率。</p><p><a href="http://s3.51cto.com/wyfs02/M00/00/17/wKiom1mWQ02SyElqAAA_HpORElY334.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>除了上一点，还有组件化开发、复用率高、Android 和 iOS 95% 的代码共用和测试效率高等优点。</p><p>鉴于这些优点，蜂鸟在 React Native 上做了很多事情，如 Crash 优化、基础控件沉淀、Bundle+ 图片热更新、首屏加载优化和 Redux 单项数据流等。</p><p>正当享受 React Native 带来的开发体验和应用体验提升时，蜂鸟遇到 RN 的一些痛点，如 ScrollView 性能、Bundle 包过大、很多优化都需要修改源码和 peaking change 等。</p><p>第三阶段：WEEX</p><p>面对如上这些痛点，不知如何应对时，WEEX 来了。官方宣传的轻量、可扩展和高性能等特点，让蜂鸟团队眼前一亮。</p><p><a href="http://s1.51cto.com/wyfs02/M02/00/17/wKiom1mWQ37hG3jlAABybECOtZo318.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>经深入研究后，蜂鸟发现 WEEX 和 React Native 如出一辙，那么为什么要选择类似的方案呢？</p><p>我们队 WEEX 和 React Native 两者基于 JS 引擎、语法、数据流、性能、开发体验及热更新等维度进行了对比。</p><p>如下图，是 WEEX 和 React Native JS 引擎对比：</p><p><a href="http://s2.51cto.com/wyfs02/M02/00/17/wKiom1mWRN7zAPELAABbNS_7sQg665.jpg-wh_600x-s_2591977570.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>React Native 在安卓和 iOS 使用的都是 JsCore，WEEX 在安卓端使用的是 UC 精简版 V8。如上图中的图表可以看出，V8 相比 JsCore 要胜一筹。</p><p>WEEX 和 React Native 语法对比。语法方面，React Native 使用的是 React，WEEX 使用的是 Vue。虽然两套方案都实现了如响应式，组件化、状态管理等功能。</p><p>如下图，是两者简单 Demo 的实践：</p><p><a href="http://s5.51cto.com/wyfs02/M00/9E/C7/wKioL1mWRCigdkKHAABwt0fvCXw732.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>实践发现，WEEX 相比 React Native 要优雅一些，是因为 Vue 有很多自定义标签，当在做一些 UI 和逻辑交杂在一起时，会让代码简洁很多。</p><p> WEEX 和 React Native 的数据流对比，React Native 使用 Redux，而 WEEX 使用 Vuex，不是 WEEX 不能使用 Redux，而是 Vuex 更适合 WEEX。</p><p>如下图，是两者的数据流，大同小异：</p><p><a href="http://s1.51cto.com/wyfs02/M00/00/17/wKiom1mWRLfh2saPAABuL1rfv8E279.jpg-wh_600x-s_4251596638.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>但 Vuex 在实现一些计算属性时，能在更细的颗粒度去更新 UI，而 Redux 只能实现到组件的级别，这样的点很多的话会带来性能上的差异。</p><p>如下图，是 WEEX 和 React Native 的性能对比，左侧是 WEEX 官方给出的与 React Native 在性能方面的对比图：</p><p><a href="http://s3.51cto.com/wyfs02/M01/00/17/wKiom1mWRTPAg_PPAACLct1tirY935.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>在渲染时间和内存占用方面 WEEX 要优于 React Native，在 CPU 占用方面两者相差不大，FPS 上 WEEX 要稍逊于 React Native。</p><p>在 ListView Android 方面，React Native 目前采用 ScrollView，WEEX 使用 Recyclerview 实现，性能稍好。</p><p>同时 WEEX 在增强开发、指定线程、首屏渲染和性能监控等方面也做了优化。</p><p>如下图，是 WEEX 和 React Native 的开发体验对比：</p><p><a href="http://s3.51cto.com/wyfs02/M01/9E/C7/wKioL1mWRVTAtcifAACBgbdrT_4252.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>和 React Native 相比，WEEX 在打包、监控性能、跨平台等方面都有一定优势。总体来说，React Native 更像是一个技术框架，WEEX 更像是一个业务框架。</p><p>如下图，是 WEEX 和 React Native 的热更新对比：</p><p><a href="http://s2.51cto.com/wyfs02/M01/9E/C7/wKioL1mWRHPyvUXiAABbEPXlvFo839.jpg-wh_600x-s_429993283.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>React Native 与 WEEX 官方都表示支持热更新，但他们的实现方式不同。在 React Native 上可通过把图片打包下发到本地来实现更新。</p><p>WEEX 有两个方法，一是选择本地资源加载，二是像网页一样直接加载页面。</p><p>如下图，是 React Native 与 WEEX 的对比总结：</p><p><a href="http://s1.51cto.com/wyfs02/M02/00/17/wKiom1mWRAWDORHEAACmpl7I_mM064.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>React Native 更像一个先驱者，拥有超强的社区人气，但也因开源社区维护代码的原因处于一个野蛮生长的状态。而 WEEX 是站在 React Native 的肩膀上，做了各种微创新，实现更多贴心的小细节。</p><p>基于 WEEX 性能、稳定性等方面都比 React Native 高，蜂鸟决定把动态化方案往 WEEX 上迁移，虽然它现在还有不足，有些轮子还是要自己去做。</p><h3 id="蜂鸟团队-WEEX-实践"><a href="#蜂鸟团队-WEEX-实践" class="headerlink" title="蜂鸟团队 WEEX 实践"></a>蜂鸟团队 WEEX 实践</h3><p>凭借之前 React Native 相关的实践经验，基于 WEEX 做了一套更完整的动态方案。涉及以下几个方面，如下图：</p><p><a href="http://s2.51cto.com/wyfs02/M01/9E/C7/wKioL1mWRujh1_1LAABeZzyxS1s184.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>统一的pidge </p><p><a href="http://s1.51cto.com/wyfs02/M00/00/17/wKiom1mWRvuA9JTzAABSweUT5M8986.jpg-wh_600x-s_2462090452.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>在 Android &amp; iOS 端，约定相同的方法名、参数，在 JS 层抹平平台差异以及统一分类管理暴露给业务的 API。</p><p>把这样的统一 pidge 方案提供给业务部门，他们只需关心暴露的 API，而不需要关心下一层平台的兼容，大大提升开发效率。</p><p>加载更新策略</p><p>加载更新方面，我们约定了一套自有协议，有 Page、URL 和 Tag，通过封装的 Router，就可以做到页面级的跳转。</p><p><a href="http://s1.51cto.com/wyfs02/M01/00/17/wKiom1mWR0HQ8EWCAABLZVoWZE0365.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>这样一来，我们很轻松地做到了页面的跳转、解耦和页面的降级。当页面出现问题，只需要把 URL 改成降级之后的 H5 页面下发即可，用户触及到的就是修复之后的 H5 页面了。</p><p>如下图，是预加载策略：</p><p><a href="http://s4.51cto.com/wyfs02/M00/9E/C7/wKioL1mWRyXyqfsRAABiyKnhkgc676.png" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-3d832b201afd2bdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a> </p><p>当 H5 页面下发到客户端之后，会对本地资源进行检查，如果有 JS 文件，就忽略，没有的话就把页面下载。当用户打开页面，再去看本地，存在资源的话直接加载，不存在的话就即时下载再运行，与传统的 Web 流程相似。</p><p>性能监控</p><p>性能监控用来判断线上服务是否正常，是整套方案最重要的部分。</p><p>WEEX 可以很方便地将所有的参数全部拿到且通过反射拿到所有的性能数据传到云端。</p><p>基于这些数据，我们就可以知道线上有了哪些页面，它的渲染是否有问题。基于这些问题，就可做相应的优化。</p><p>如下图，是线上的数据情况：</p><p><img src="https://upload-images.jianshu.io/upload_images/2692013-e49174df3d85ebf1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wKioL1mWR1_yo0slAACw7OO3gPA560.jpg"></p><p>监控三个指标，分别是 JS 引擎的初始化时间、页面打开时间和网络时间。因大部分 WEEX 页面都是业务，所以说业务埋点必不可少。饿了么也实现了一套框架，将业务埋点传给服务端，然后方便产品去制定一些产品方面的策略。</p><p>JS 的错误统计</p><p>可以捕捉 JS 端抛出的错误，如果所处团队是前端主导，可传给前端。如果是 Native 主导，可通过搜集平台将这些崩溃上传，在后台看到这些错误之后，找到相应的代码去修复。</p><p>Native 的错误</p><p>有了 JS 错误，Native 错误也不能忽略。</p><p>如下图，是 WEEX 动态方案上线一周之后线上抛的错误：</p><p><a href="http://s1.51cto.com/wyfs02/M01/00/17/wKiom1mWQYehx6inAABkUKfnsEE670.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>从图中可以看到都是个位数，这一点其实当时也很惊讶，WEEX 确实做得很稳定，这一点超出预料。</p><p>共用组件和 API</p><p>之前蜂鸟在 React Native 上面的一些实践，积累了一些很常用的组件和 API。WEEX 和 React Native 都是使用 JS 实现，所以我们很方便的将 RN 的控件转化为 WEEX 控件。</p><p>如下图，是实现的组件和 API，几乎可以满足中小团队的日常使用：</p><p><a href="http://s5.51cto.com/wyfs02/M00/00/17/wKiom1mWQS-yXSj_AABr0MKHwkc042.jpg-wh_600x-s_1736076720.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>调试工具</p><p>这方面 WEEX 做的很贴心，虽然没有整合到整个初始化的项目中，但开源了几个库，可把代码拷贝到业务中进行使用。</p><p><a href="http://s2.51cto.com/wyfs02/M02/9E/C6/wKioL1mWQRyT9bJJAAB4Jo5u2hU029.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>WEEX 还可支持 Debug 模式显示调试工具、支持 hot reload、方便的查看性能指标和 Shell 脚本一键打包等功能。</p><p>综上所述，基于这些维度实现的框架，可以方便的让业务来使用。</p><p>如下，是饿了么和蜂鸟用 WEEX 实现的两个页面：</p><p><a href="http://s1.51cto.com/wyfs02/M01/9E/C6/wKioL1mWQQ2QsuD8AAB7kaUC5I8950.jpg-wh_600x-s_1820802189.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>饿了么的第二个发现页面，就是基于 WEEX。蜂鸟 APP 可能大家接触不到，上图是当前通知的活动界面，还有大量的新功能正在接入。</p><p>如果你正在考虑 WEEX 与 React Native 方案，或是正在接入 React Native。看到这篇文章，你可以去调研以下 WEEX 方案，可能你会有另一种选择。</p><p>以上内容根据许锦洋老师在 WOTA2017 “移动端架构演进”专场的演讲内容整理。</p><p><a href="http://s2.51cto.com/wyfs02/M02/00/17/wKiom1mWQOuQbvEsAABT9GSW200927.jpg" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/2692013-6ecdcdbf7956a0d2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.jpeg"></a> </p><p>负责饿了么蜂鸟 APP 的架构、研发等工作。拥有饿了么商家、风行者、蜂鸟众包等多款 APP 开发工作经历，并从 0 开始架构和开发了整个蜂鸟团队 APP。目前关注的技术方向为移动跨平台技术方案、移动端架构、移动端性能优化等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最近在准备学习一门跨平台语言时候表示很纠结，学习一门语言时间紧迫，-必须学到有用又适应市场的一门语言&quot;&gt;&lt;a href=&quot;#最近在准备学习一门跨平台语言时候表示很纠结，学习一门语言时间紧迫，-必须学到有用又适应市场的一门语言&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA【老司机专属 Lombok超便捷工具介绍及使用方法】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA%E3%80%90%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B8%93%E5%B1%9E-Lombok%E8%B6%85%E4%BE%BF%E6%8D%B7%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【老司机专属-Lombok超便捷工具介绍及使用方法】/</id>
    <published>2018-11-29T14:06:43.000Z</published>
    <updated>2018-11-29T14:06:44.207Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/holten/p/5729226.html" target="_blank" rel="noopener">Lombok介绍及使用方法</a></p><p>lombok简介<br>lombok是一个非常好用的小工具，刚见到的时候就感觉非常惊艳，有一种相见恨晚的感觉，用了一段时间之后感觉的确挺不错，所以特此来推荐一下。<br><a href="https://projectlombok.org/" target="_blank" rel="noopener">lombok的官方地址：https://projectlombok.org/</a><br><a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="noopener">lombok的Github地址：https://github.com/rzwitserloot/lombok</a><br>那么lombok到底是个什么呢，lombok是一个可以通过简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 Java 代码的工具，简单来说，比如我们新建了一个类，然后在其中写了几个字段，然后通常情况下我们需要手动去建立getter和setter方法啊，构造函数啊之类的，lombok的作用就是为了省去我们手动创建这些代码的麻烦，它能够在我们编译源码的时候自动帮我们生成这些方法。<br>lombok能够达到的效果就是在源码中不需要写一些通用的方法，但是在编译生成的字节码文件中会帮我们生成这些方法，这就是lombok的神奇作用。<br>虽然有人可能会说IDE里面都自带自动生成这些方法的功能，但是使用lombok会使你的代码看起来更加简洁，写起来也更加方便。<br>lombok安装<br>lombok的安装跟一般引用jar包没有什么区别，可以到官网上下载最新的jar包，然后导入到项目里面就好啦。<br>Maven添加依赖</p><dependencies> <dependency><br><groupid>org.projectlombok</groupid><br><artifactid>lombok</artifactid><br><version>1.16.10</version><br></dependency></dependencies><p>Intellij idea开发的话需要安装Lombok plugin，同时设置 Setting -&gt; Compiler -&gt; Annotation Processors -&gt; Enable annotation processing勾选。<br>lombok使用<br>lombok使用过程中主要是靠注解起作用的，官网上的文档里面有所有的注解，这里不一一罗列，只说明其中几个比较常用的。<br>@NonNull<br>: 可以帮助我们避免空指针。<br>使用lombok：<br>import lombok.NonNull; public class NonNullExample extends Something {<br>private String name; public NonNullExample(@NonNull Person person) {<br>super(“Hello”); this.name = person.getName();<br>}}</p><p>不使用lombok：<br>public class NonNullExample extends Something { </p><p>private String name; public NonNullExample(@NonNull Person person)<br>{ super(“Hello”);<br>if (person == null) {<br> throw new NullPointerException(“person”);<br> }<br> this.name = person.getName();<br>}}</p><p>@Cleanup<br>: 自动帮我们调用close()<br>方法。<br>使用lombok：<br>import lombok.Cleanup;import java.io.*;public class CleanupExample {<br>public static void main(String[] args) throws IOException {<br>@Cleanup InputStream in = new FileInputStream(args[0]);<br> @Cleanup OutputStream out = new FileOutputStream(args[1]);<br> byte[] b = new byte[10000];<br>while (true) { int r = in.read(b);<br> if (r == -1) break; out.write(b, 0, r);<br>} }}</p><p>不使用lombok：<br>import java.io.*; public class CleanupExample {<br>public static void main(String[] args) throws IOException {<br>InputStream in = new FileInputStream(args[0]); try {<br>OutputStream out = new FileOutputStream(args[1]); try { byte[] b = new byte[10000]; while (true) {<br>int r = in.read(b); if (r == -1) break; out.write(b, 0, r);<br>} } finally {<br> if (out != null) {<br>out.close();<br>} } } finally {<br>if (in != null) { in.close();<br>} } }}</p><p>@Getter / @Setter<br>: 自动生成Getter/Setter方法<br>使用lombok：<br>import lombok.AccessLevel; import lombok.Getter; import lombok.Setter; public class GetterSetterExample {<br>@Getter @Setter private int age = 10; @Setter(AccessLevel.PROTECTED) private String name;<br> }</p><p>不使用lombok：<br>public class GetterSetterExample {<br> private int age = 10; private String name; </p><p>public int getAge() {<br> return age;<br>} </p><p>public void setAge(int age) {<br>this.age = age;<br> }<br>protected void setName(String name) { this.name = name; }}</p><p>@NoArgsConstructor<br>: 自动生成无参数构造函数。<br>@AllArgsConstructor<br>: 自动生成全参数构造函数。<br>@Data: [自动为所有字段添加@ToString]</p><p> @Test public void test1() {<br> // 自动生成日志对象 <em>log</em>.debug(“sss”); }</p><p>还有其他一些比如自动生成日志对象等等之类的注解可以到官方网站去了解，就不一一列举了。<br><a href="https://projectlombok.org/features/index.html" target="_blank" rel="noopener">官方文档https://projectlombok.org/features/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/holten/p/5729226.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lombok介绍及使用方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;lombok简介&lt;br&gt;lombok是一个非常好用的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA【手把手教你整合最简洁的SSM框架：SpringMVC + Spring + MyBatis】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA%E3%80%90Java-%E2%80%94-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%95%B4%E5%90%88%E6%9C%80%E7%AE%80%E6%B4%81%E7%9A%84SSM%E6%A1%86%E6%9E%B6%EF%BC%9ASpringMVC-Spring-MyBatis%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【Java-—-手把手教你整合最简洁的SSM框架：SpringMVC-Spring-MyBatis】/</id>
    <published>2018-11-29T14:06:19.000Z</published>
    <updated>2018-11-29T14:06:21.823Z</updated>
    
    <content type="html"><![CDATA[<p>手把手教你整合最简洁的SSM框架：SpringMVC + Spring + MyBatis<br>快速预览地址：<a href="http://120.24.96.44/AJ-crm/customer/list.action" target="_blank" rel="noopener">http://120.24.96.44/AJ-crm/customer/list.action</a><br>GitHub地址: <a href="https://github.com/ChinaArJun/Online-CRM" target="_blank" rel="noopener">https://github.com/ChinaArJun/Online-CRM</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.介绍 ~ Project introduction</span><br><span class="line">项目整体使用SSM框架：SpringMVC + Spring + MyBatis WEB层加入了bootstrap框架，视觉效果非常棒</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.下载项目 ~ Download project</span><br><span class="line">git clone [https://github.com/ChinaArJun/Online-CRM.git](https://github.com/ChinaArJun/Online-CRM.git) </span><br><span class="line">下载项目后需要导入sql文件,更改MySql用户名和密码即可</span><br></pre></td></tr></table></figure><p>3.预览 ~ Preview picture</p><p><a href="https://github.com/ChinaArJun/Online-CRM/blob/master/crm.png" target="_blank" rel="noopener"><img src="https://github.com/ChinaArJun/Online-CRM/raw/master/crm.png" alt="1"></a><a href="https://github.com/ChinaArJun/Online-CRM/blob/master/%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7.png" target="_blank" rel="noopener"><img src="https://github.com/ChinaArJun/Online-CRM/raw/master/%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7.png" alt="2"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;手把手教你整合最简洁的SSM框架：SpringMVC + Spring + MyBatis&lt;br&gt;快速预览地址：&lt;a href=&quot;http://120.24.96.44/AJ-crm/customer/list.action&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA【使用Mybatis-Generator自动生成Dao、Model、Mapping相关文件】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA%E3%80%90%E4%BD%BF%E7%94%A8Mybatis-Generator%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Dao%E3%80%81Model%E3%80%81Mapping%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【使用Mybatis-Generator自动生成Dao、Model、Mapping相关文件】/</id>
    <published>2018-11-29T14:06:01.000Z</published>
    <updated>2018-11-29T14:06:01.195Z</updated>
    
    <content type="html"><![CDATA[<p>用generatorsqlmapcustom对<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">数据库</a>进行逆向工程，生成接口和xml，还有实体</p><p>1 首先下载generatorsqlmapcustom</p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-3cdbb161841a237f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9072E162-8F11-4924-98C5-5E11598A8514.png"></p><p>2 导入工程</p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-f56fc8f472afe6bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AB80D8D6-FDA8-40C4-883D-BF67E5BEA045.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-a6cea7cc03233ef6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="97913C13-A787-4A84-8949-5D9C58F96EDE.png"></p><p>3 配置用户名密码</p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-6b445d202e1a974f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7F56185A-94B4-4310-95B1-596E69A06367.png"></p><p>4 配置映射信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">&lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;</span><br><span class="line">&lt;commentGenerator&gt;</span><br><span class="line">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span><br><span class="line">&lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/commentGenerator&gt;</span><br><span class="line">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span><br><span class="line">&lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">connectionURL=&quot;jdbc:mysql://localhost:3306/taotao&quot; userId=&quot;root&quot;</span><br><span class="line">password=&quot;123&quot;&gt;</span><br><span class="line">&lt;/jdbcConnection&gt;</span><br><span class="line">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 </span><br><span class="line">NUMERIC 类型解析为java.math.BigDecimal --&gt;</span><br><span class="line">&lt;javaTypeResolver&gt;</span><br><span class="line">&lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/javaTypeResolver&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- targetProject:生成PO类的位置 --&gt;</span><br><span class="line">&lt;javaModelGenerator targetPackage=&quot;com.taotao.pojo&quot;</span><br><span class="line">&lt;!-- 指定位置 ：最好直接指定根目录,以免出现生成不出文件的情况 --&gt;&lt;targetProject=&quot;/Users/pro/Desktop/Java/javaEE28/generatorSqlmapCustom/src&quot;&gt;</span><br><span class="line">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">&lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span><br><span class="line">&lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/javaModelGenerator&gt;</span><br><span class="line">        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;</span><br><span class="line">&lt;sqlMapGenerator targetPackage=&quot;com.taotao.mapper&quot; </span><br><span class="line">&lt;!-- 指定位置 ：最好直接指定根目录,以免出现生成不出文件的情况 --&gt;</span><br><span class="line">&lt;targetProject=&quot;/Users/pro/Desktop/Java/javaEE28/generatorSqlmapCustom/src&quot;&gt;</span><br><span class="line">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">&lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/sqlMapGenerator&gt;</span><br><span class="line">&lt;!-- targetPackage：mapper接口生成的位置 --&gt;</span><br><span class="line">&lt;javaClientGenerator type=&quot;XMLMAPPER&quot;</span><br><span class="line">targetPackage=&quot;com.taotao.mapper&quot; </span><br><span class="line">&lt;!-- 指定位置 ：最好直接指定根目录,以免出现生成不出文件的情况 --&gt;</span><br><span class="line"> &lt;targetProject=&quot;/Users/pro/Desktop/Java/javaEE28/generatorSqlmapCustom/src&quot;&gt;</span><br><span class="line">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">&lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">&lt;/javaClientGenerator&gt;</span><br><span class="line">&lt;!-- 指定数据库表 --&gt;</span><br><span class="line">&lt;table schema=&quot;&quot; tableName=&quot;tb_content&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;table schema=&quot;&quot; tableName=&quot;tb_content_category&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;table schema=&quot;&quot; tableName=&quot;tb_item&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;table schema=&quot;&quot; tableName=&quot;tb_item_cat&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;table schema=&quot;&quot; tableName=&quot;tb_item_desc&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;table schema=&quot;&quot; tableName=&quot;tb_item_param&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;table schema=&quot;&quot; tableName=&quot;tb_item_param_item&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;table schema=&quot;&quot; tableName=&quot;tb_order&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;table schema=&quot;&quot; tableName=&quot;tb_order_item&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;table schema=&quot;&quot; tableName=&quot;tb_order_shipping&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;table schema=&quot;&quot; tableName=&quot;tb_user&quot;&gt;&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure></p><p>5 运行生成</p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-77fc4f7f4a2b9693.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A39CF48E-5CCE-49DE-BA87-929777B17496.png"></p><p>Mybatis属于半自动ORM，在使用这个框架中，工作量最大的就是书写Mapping的映射文件，由于手动书写很容易出错，我们可以利用Mybatis-Generator来帮我们自动生成文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用generatorsqlmapcustom对&lt;a href=&quot;http://lib.csdn.net/base/mysql&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据库&lt;/a&gt;进行逆向工程，生成接口和xml，还有实体&lt;/p&gt;
&lt;p&gt;1 首先下载g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA【SpringMVC+Swagger UI生成可视图的API文档（详细图解）】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA%E3%80%90SpringMVC-Swagger-UI%E7%94%9F%E6%88%90%E5%8F%AF%E8%A7%86%E5%9B%BE%E7%9A%84API%E6%96%87%E6%A1%A3%EF%BC%88%E8%AF%A6%E7%BB%86%E5%9B%BE%E8%A7%A3%EF%BC%89%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【SpringMVC-Swagger-UI生成可视图的API文档（详细图解）】/</id>
    <published>2018-11-29T14:05:44.000Z</published>
    <updated>2018-11-29T14:05:45.031Z</updated>
    
    <content type="html"><![CDATA[<p>Swagger UI<br>关于Swagger UI官方解释是这样的：<strong><em>The Swagger UI is an open source project to visually render documentation for a Swagger defined API directly from the API’s Swagger specifcation</em></strong> <a href="http://swagger.io/" target="_blank" rel="noopener">官网地址</a> 下面是官方的效果图：<br><img src="http://upload-images.jianshu.io/upload_images/2692013-c212365ee2b499e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5F19E5D5-9FB4-45A0-BBF8-613E2014A5C1.png"></p><p>我将上图分成了两部分<br>文档地址：从改地址请求数据，获取JSON格式数据，交给第二步显示<br>API文档显示：将JSON数据转化成可视图的效果</p><p><strong>Swagger可以将某种固定格式的JSON数据生成可以视图的在线API文档，支持在线<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>，可以清楚的观察到IO数据</strong>。<br>SpringMVC + Swagger<br>目的：在原有的SpringMVC系统中添加Swagger，通过在接口上添加注解实现，接口文档的同步效果。 下图为我实现之后的效果：<br><img src="http://upload-images.jianshu.io/upload_images/2692013-c6eb0011d61f0be0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10B721C3-92EB-467F-B7A9-D1764CF96CA8.png"></p><p>项目搭建<br>我的工具：Eclipse开发工具（安装<a href="http://lib.csdn.net/base/javaee" target="_blank" rel="noopener">spring</a>插件，当然也可以不要，就是麻烦点）,Maven，Tomcat，Internet访问，Chrome浏览器 1.创建Simple Spring Web Maven工程 右键New-&gt;Spring Project，选择对应类型，finish, 如下图：[图片上传中。。。（3）] 我的工程的结构，注意那两个配置文件，名称不重要，可以随便改，注意要对应好web.xml中的名称就行。[图片上传中。。。（4）] 想了想还是把三个配置文件贴出来吧。 web.xml<br>&lt;?xml version=”1.0” encoding=”ISO-8859-1”?&gt;<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemalocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"> <display-name>SwaggerDemo</display-name> <!-- - Location of the XML file that defines the root application context. - Applied by ContextLoaderListener. --> <context-param> <param-name>contextConfigLocation</param-name> <param-value>classpath:spring/application-config.xml</param-value> </context-param> <listener> <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> </listener> <!-- - Servlet that dispatches request to registered handlers (Controller implementations). --> <servlet> <servlet-name>dispatcherServlet</servlet-name> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/mvc-config.xml</param-value> </init-param> <load-on-startup>1</load-on-startup> </servlet> <servlet-mapping> <servlet-name>dispatcherServlet</servlet-name> <url-pattern>/</url-pattern> </servlet-mapping></web-app></p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43</p><p>application-config.xml<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> <!-- Uncomment and add your base-package here: <context:component-scan base-package="org.springframework.samples.service"/> --></beans></p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p><p>mvc-config.xml<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemalocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> <!-- Uncomment and your base-package here: <context:component-scan base-package="org.springframework.samples.web"/> --> &lt;mvc:annotation-driven /&gt; <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"> <!-- Example: a logical view name of 'showMessage' is mapped to '/WEB-INF/jsp/showMessage.jsp' --> <property name="prefix" value="/WEB-INF/view/"> <property name="suffix" value=".jsp"> </property></property></bean></beans></p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23</p><p>这样配置到后面配置Swagger会出现无法自动注入的问题，后面再说，以上为工具自动生成的代码。<br>2.添加Swagger-Spring MVC包、JSON和jackson pom.xml文件中 properties标签里面添加jackson版本号</p><p>&lt;version.jackson&gt;2.4.4&lt;/version.jackson&gt;</p><p>1</p><p>1</p><p>dependencies标签中添加<br><!-- Swagger --> <dependency> <groupid>com.mangofactory</groupid> <artifactid>swagger-springmvc</artifactid> <version>0.9.5</version> </dependency> <!-- JSON --> <dependency> <groupid>net.sf.json-lib</groupid> <artifactid>json-lib</artifactid> <version>2.4</version> <classifier>jdk15</classifier> </dependency> <!-- JACKSON --> <dependency> <groupid>com.fasterxml.jackson.core</groupid> <artifactid>jackson-annotations</artifactid> <version>${version.jackson}</version> </dependency> <dependency> <groupid>com.fasterxml.jackson.core</groupid> <artifactid>jackson-databind</artifactid> <version>${version.jackson}</version> </dependency> <dependency> <groupid>com.fasterxml.jackson.core</groupid> <artifactid>jackson-core</artifactid> <version>${version.jackson}</version> </dependency></p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29</p><p>3.下面是重点，Swagger所有API文档都在这里存储，添加Swagger配置类 创建一个配置类MySwaggerConfig，添加私有成员SpringSwaggerConfig，set方法使用@Autowired注解自动注入，使用@Bean注解添加SwaggerSpringMvcPlugin，并使用自定义的ApiInfo，SwaggerConfig类需要添加@Configuration以及@EnableSwagger<br>package com.edu.xk;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import com.mangofactory.swagger.configuration.SpringSwaggerConfig;import com.mangofactory.swagger.models.dto.ApiInfo;import com.mangofactory.swagger.plugin.EnableSwagger;import com.mangofactory.swagger.plugin.SwaggerSpringMvcPlugin;@Configuration@EnableSwagger@EnableWebMvcpublic class MySwaggerConfig { private SpringSwaggerConfig springSwaggerConfig; /<strong> <em> Required to autowire SpringSwaggerConfig </em>/ @Autowired public void setSpringSwaggerConfig(SpringSwaggerConfig springSwaggerConfig) { this.springSwaggerConfig = springSwaggerConfig; } /</strong> <em> Every SwaggerSpringMvcPlugin bean is picked up by the swagger-mvc </em> framework - allowing for multiple swagger groups i.e. same code base <em> multiple swagger resource listings. </em>/ @Bean public SwaggerSpringMvcPlugin customImplementation() { // 暂时不用过滤 /<em>return new SwaggerSpringMvcPlugin(this.springSwaggerConfig).apiInfo(apiInfo()).includePatterns(“.</em>pet.<em>“);</em>/ return new SwaggerSpringMvcPlugin(this.springSwaggerConfig).apiInfo(apiInfo()); } private ApiInfo apiInfo() { ApiInfo apiInfo = new ApiInfo( “My Apps API Title”, “My Apps API Description”, “My Apps API terms of service”, “My Apps API Contact Email”, “My Apps API Licence Type”, “My Apps API License URL” ); return apiInfo; }}</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52</p><p>官方原话： <em>The @EnableSwagger annotation, in this example, enables swagger-springmvc out of the box. The generated swagger json Resource Listing is available at /api-docs</em> 4.添加Controller:WebServiceForCSS，Swagger文档在此处添加<br>package com.edu.xk.webservice;import javax.servlet.http.HttpServletRequest;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import com.edu.xk.model.User;import com.wordnik.swagger.annotations.ApiOperation;import com.wordnik.swagger.annotations.ApiParam;import net.sf.json.JSONObject;/*<em> </em> @moudle: WebServiceForCSS <em> @version:v1.0 </em> @Description: TODO <em> @author: xukai </em> @date: 2016年12月1日 下午5:37:30 <em> </em>/@Controllerpublic class WebServiceForCSS { @ResponseBody @RequestMapping(value = “getUserById”, method = RequestMethod.GET, produces = {“application/json; charset=utf-8”,”application/xml”}) @ApiOperation(value = “通过ID查询USER信息”, httpMethod = “GET”, notes = “暂无”) public String getUserById( @ApiParam(required = true, name = “id”, value = “ID”) @RequestParam(value = “id”) String id,HttpServletRequest request) { User user = new User(); user.setId(id); user.setName(“测试人员”); user.setAge(25); JSONObject object = JSONObject.fromObject(user); return object.toString(); }}</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42</p><p>5.配置文件修改 context加载的时候需要配置的文件，此处配置文件为application-config.xml<br>&lt;mvc:annotation-driven /&gt; <!-- mvc-config.xml中的可以去掉 --> &lt;context:component-scan base-package=”com.edu”/&gt; <bean class="com.edu.xk.configer.SwaggerConfig"></bean></p><p>1<br>2<br>3</p><p>1<br>2<br>3</p><p>6.下载Swagger UI组件 去官网下载Zip包，或者在github上下载也可以，需要将dist文件夹下的所有文件的复制到webapp目录下。<br>7.修改Project Properties 将jdk1.5换成最新的本地的jdk,对应的<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java </a>complier也改为对应的，还有maven包依赖也需要添加，不然启动的时候会找不到ContextLoader.class。<br>8.添加拦截器，不然无法访问.html后缀文件，在web.xml中添加</p><p><servlet-mapping> <servlet-name>default</servlet-name> <url-pattern><em>.jpg</em></url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern>.png</url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern><em>.gif</em></url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern>.ico</url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern><em>.js</em></url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern>.css</url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern><em>.html</em></url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern>.xls</url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern><em>.doc</em></url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern>.json</url-pattern> </servlet-mapping> <!-- 字体相关 开始 --> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern><em>.eot</em></url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern>.svg</url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern><em>.ttf</em></url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern>.woff</url-pattern> </servlet-mapping> <servlet-mapping> <servlet-name>default</servlet-name> <url-pattern>*.woff2</url-pattern> </servlet-mapping> <!-- 字体相关 结束 --> <welcome-file-list> <welcome-file>index.html</welcome-file> <welcome-file>index.htm</welcome-file> <welcome-file>index.jsp</welcome-file> <welcome-file>default.html</welcome-file> <welcome-file>default.htm</welcome-file> <welcome-file>default.jsp</welcome-file> </welcome-file-list></p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70</p><p>运行项目，可以看到效果图： [图片上传中。。。（5）]可以看到，现在效果还是和官网上一样的。改为自己的API文档可以通过修改index.html中的url = “<a href="http://petstore.swagger.io/v2/swagger.json&quot;" target="_blank" rel="noopener">http://petstore.swagger.io/v2/swagger.json&quot;</a>;<br>或者直接修改访问的地址栏为：<a href="http://localhost:8080/SwaggerDemo/api-docs" target="_blank" rel="noopener">http://localhost:8080/SwaggerDemo/api-docs</a><br>原理分析<br>SpringMVC+Swagger其实就是在系统加载的时候，Swagger配置类去扫描所有添加注释的接口，并且储存起来通过下面地址进行访问，返回JSON数据，在前端界面显示出来 [图片上传中。。。（6）] 这里我在网上看到一个汉化的版本（<a href="http://blog.csdn.net/hel12he/article/details/46547863" target="_blank" rel="noopener">原效果</a>），下载了他工程，将他生成demo.json放入的我的工程中的webapp目录下，下面是效果图 [图片上传中。。。（7）]<br>遇到的问题<br>问题1：下载maven的jar包中途失败，工程会出错maven missing 解决方法：选中Project-&gt;右键maven-&gt;update project-&gt;选中Force update 如果此时依然有 missing的jar，按照 buildpath 提示的 jar包missing 路径，去 maven 本地仓库中对应位置（jar包后面有路径），删掉 该 jar 包的 xxx.lastUpdated 文件，之后，再重新执行 项目右键maven-&gt;update project<br>问题2：缺失jackson包会导致出现异常java.lang.NoClassDefFoundError: com/fasterxml/jackson/databind/ObjectMapper)<br>问题3：java.lang.ClassNotFoundException: org.springframework.web.util.Log4jConfigListen，因为工程没有引入maven中的jar包，解决办法：选中工程右键-&gt;Properties-&gt;Deployment Assembly-&gt;add-&gt;Java Build Path Entries-&gt;Maven Dependencies-&gt;OK<br>问题4：<strong>org.springframework.beans.factory.BeanCreationException</strong>，出现这个异常是因为SpringSwaggerConfig的私有成员RequestMappingHandlerMapping造成的，将&lt;mvc:annotation-driven /&gt;<br>放入到web.xml的context-param标签对应的配置文件application-config.xml中，完美解决，官网解释该标签作用为： <em>Required so swagger-springmvc can access spring’s RequestMappingHandlerMapping</em> 。<br>org.springframework.beans.factory.NoSuchBeanDefinitionException: Noqualifying bean of type[org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping]found for dependency [collection oforg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping]:expected at least 1 bean which qualifies as autowire candidate forthis dependency. Dependency annotations:<a href="mailto:{@org.springframework.beans.factory.annotation.Autowired" target="_blank" rel="noopener">{@org.springframework.beans.factory.annotation.Autowired</a>(required=true)}</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</p><p><a href="https://github.com/springfox/springfox/blob/v1.0.2/README.md" target="_blank" rel="noopener">Swagger UI开发帮助</a></p><p>Swagger Editor</p><p>反正顺路，顺便的Editor也写完，Editor个人感觉就是一个文档编辑器，感觉SosoApi还是好些。试着在Swagger官网下载了一个Swagger Editor跑着玩了玩.下载swagger-editor.zip，解压到Tomcat的webapps文件夹中，来看一下效果图 [图片上传中。。。（8）]Swagger UI结合Swagger Editor更好用，但是在线编辑那个太卡了，备份一个本地的，以备不时只需。Swagger UI<br>关于Swagger UI官方解释是这样的：<strong><em>The Swagger UI is an open source project to visually render documentation for a Swagger defined API directly from the API’s Swagger specifcation</em></strong> <a href="http://swagger.io/" target="_blank" rel="noopener">官网地址</a> 下面是官方的效果图： </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Swagger UI&lt;br&gt;关于Swagger UI官方解释是这样的：&lt;strong&gt;&lt;em&gt;The Swagger UI is an open source project to visually render documentation for a Swagger de
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac【用OracleSQLDeveloper连接Windows虚拟机的Oracle数据库】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/Mac%E3%80%90%E4%B8%8B%E7%94%A8OracleSQLDeveloper%E8%BF%9E%E6%8E%A5Windows%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/Mac【下用OracleSQLDeveloper连接Windows虚拟机的Oracle数据库】/</id>
    <published>2018-11-29T14:04:34.000Z</published>
    <updated>2018-11-29T14:04:42.503Z</updated>
    
    <content type="html"><![CDATA[<p>因为在OS X中无法安装<a href="http://lib.csdn.net/base/oracle" target="_blank" rel="noopener">Oracle</a><a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">数据库</a>（除了雪豹系统）所以只能用虚拟机安装Oracle来替代。<br><a href="http://blog.sina.com.cn/s/blog_be59e93c0102uyhu.html" target="_blank" rel="noopener">Mac OS X 10.6 Snow Leopard x64 (雪豹) 安装 oracle</a> 虚拟机数据库和OS X之间的连接也没有说的很详细或者非常可行的教程，本文旨在帮助后继者来正确连接，免其麻烦。<br><strong>你需要的东西有：<a href="http://download.oracle.com/otn/java/sqldeveloper/sqldeveloper-4.1.3.20.78-macosx.app.zip" target="_blank" rel="noopener">OracleSQLDeveloper For OS X</a>以及已经安装好的Windows虚拟机和虚拟机上的Oracle数据库</strong><br>我使用的是PD11来装的Win8.1以及Oracle 11gR2 便捷版。</p><p><strong>我们需要提前明白为什么我们尝试的经常失败：</strong><br>1、虚拟机和主机间的连接网络连接模式最好为桥接，侨接之后IP会发生改变，在这里必须要细心和清楚</p><p>2、虚拟机(Win)防火墙要关闭 </p><p>3、监听程序默认的是localhost，需要配置才能监听远程接入的程序， 而我使用的便捷版数据库没有Oracle Net Manager，只能在listener.ora文件当中配置。 </p><p>4、需要添加一个有远程登陆权限的用户</p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-dc2c374a84116aec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="![Uploading 8368A7E8-6E74-481D-922B-38FB27410E71_850490.jpg . . .]"></p><p>其中需要指明的是，主机名最好用IP地址来表示，而这个IP地址为数据库那个机器的IP地址，端口号一般都是1521 或者在listener.ora中有，其中地址和示例配置代码如下：<br>C:\oraclexe\app\oracle\product\11.2.0\server\network\ADMIN\listener.ora (记得更改读写权限，参照我上一篇博客)</p><p>LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1)) (ADDRESS = (PROTOCOL = TCP)(HOST = MAC7F25)(PORT = 1521)) (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.100.103)(PORT = 1521))  ) )</p><p>MAC7F25是我的虚拟机名称，而192.168.100.103为虚拟机在桥接后的IP<br>添加这行代码：<br>(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.100.103)(PORT = 1521))</p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-8a35a5f11e73bd10.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8368A7E8-6E74-481D-922B-38FB27410E71.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为在OS X中无法安装&lt;a href=&quot;http://lib.csdn.net/base/oracle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Oracle&lt;/a&gt;&lt;a href=&quot;http://lib.csdn.net/base/mysql&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA【在Eclipse中用JDBC连接MySQL数据库】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA%E3%80%90%E5%9C%A8Eclipse%E4%B8%AD%E7%94%A8JDBC%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【在Eclipse中用JDBC连接MySQL数据库】/</id>
    <published>2018-11-29T14:04:16.000Z</published>
    <updated>2018-11-29T14:04:16.842Z</updated>
    
    <content type="html"><![CDATA[<p>1.准备工作: 准备相关的软件</p><p><1>.MySQL 6.0<br>下载地址:<a href="http://dev.mysql.com/downloads/mysql/6.0.html" target="_blank" rel="noopener">http://dev.mysql.com/downloads/mysql/6.0.html</a></1></p><p><2>.mysql-connector-java-5.1.6.zip<br>下载地址:<a href="http://dev.mysql.com/downloads/connector/j/5.1.html" target="_blank" rel="noopener">http://dev.mysql.com/downloads/connector/j/5.1.html</a></2></p><p><3>.SQLyog MySQL GUI - Enterprise 6.54 (Stable)(官网地址，不过需注册，也可以直接百度一下)<br>下载地址:<a href="http://www.webyog.com/en/downloads.php" target="_blank" rel="noopener">http://www.webyog.com/en/downloads.php</a></3></p><p>2.下载完之后开始进行安装 ,第一个是属于数据库软件,正常安装即可(端口默认3306，用户名root，当然也可以自己设置，建议默认安装)</p><ol><li><p>将JDBC解压缩到任意位置,找出mysql-connector-java-5.1.6-bin.jar文件，放在一个固定目录下，后面进行MySQL数据库连接需要加载它，其它文件都可删除。</p></li><li><p>安装SQLyog6.54软件，这是一款非常好的可视化操作MySQL的工具。（当然你也可以使用自己最习惯的方式在MySQL中建立建立一个测试数据库）。打开刚刚安装好的 SQLyog6.54,点continue,再NEW一个新连接，这里需要用到刚才所说的用户名密码，默认用户名root，密码是自己设置，这里暂且用1234，端口号为3306（默认），如做修改就输入你修改后的端口。点连接，之后的操作就相对容易，再可视化的窗口下，右键新建一个数据库，这里建一个mydb数据库。</p></li><li><p>打开Eclipse<br> a.新建工程-&gt; java -&gt; java project,起名为Test </p><p> b.右键单击目录窗口中的Test, 选择Build Path -&gt;Configure Build Path…, 添加扩展jar文件,即把mysql-connector-java-5.1.6-bin.jar添加到其中,确定。</p></li><li><p>编写java代码来测试连接数据库<br>程序代码:<br>import java.sql.*;<br>public class Test {<br>public static void main(String[] srg) {<br>String driverName = “com.mysql.jdbc.Driver”;  //加载JDBC驱动<br>String dbURL = “jdbc:mysql://localhost:3306/mydb”;  //连接服务器和数据库sample<br>String userName = “root”;  //默认用户名<br>String userPwd = “1234”;  //密码<br>Connection dbConn;<br>try {<br>Class.forName(driverName);<br>dbConn = DriverManager.getConnection(dbURL, userName, userPwd);<br>System.out.println(“Connection Successful!”);  //如果连接成功控制台输出Connection Successful!<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>}<br>}<br>总结<br>MySQL数据库的连接相对还是比较简单的，即使刚接触这方面的应用的，只要遵循这六步，半个小时内差不多都能搞定。<br>以前在这方面走过不少弯路，今天特别高兴能跟大家分享我的经验，希望对您数据库连接方面的快速入门会有所帮助！</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.准备工作: 准备相关的软件&lt;/p&gt;
&lt;p&gt;&lt;1&gt;.MySQL 6.0&lt;br&gt;下载地址:&lt;a href=&quot;http://dev.mysql.com/downloads/mysql/6.0.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http:
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA【有哪些适合新手练手的Java项目？】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA%E3%80%90%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%82%E5%90%88%E6%96%B0%E6%89%8B%E7%BB%83%E6%89%8B%E7%9A%84Java%E9%A1%B9%E7%9B%AE%EF%BC%9F%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【有哪些适合新手练手的Java项目？】/</id>
    <published>2018-11-29T14:03:16.000Z</published>
    <updated>2018-11-29T14:03:16.652Z</updated>
    
    <content type="html"><![CDATA[<p>Java作为一门古老的语言，已有20年左右的历史，这在发展日新月异的技术圈可以说是一个神话。虽然不少人曾抱怨Java语言就像老太太的裹脚布，又臭又长，有时写了500行都不能表达程序员的意图。但从市场上的招聘现状看，Java工程师依然有着其他语言不可取代的竞争优势。招聘情况请参考：<a href="https://zhuanlan.zhihu.com/p/21502019?refer=100offer" target="_blank" rel="noopener">为</a></p><p>看到了这里，恭喜正式开始进入主题：适合新手练手的Java项目？ </p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-a1e01685622219e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C9154343-0F98-4774-A1B0-C2EBA0BBDB13.png"></p><p>源码下载（实例一）：<br><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2358272909446144.htm" target="_blank" rel="noopener">jsp开发完整的博研图书馆后台管理系统，不使用框架开发的，太完美了</a><br>源码下载（实例二）：<br><a href="https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/defonds/7123499" target="_blank" rel="noopener">javaWeb图书馆管理系统源码mysql版本</a><br>源码下载（实例三）<br><a href="https://link.zhihu.com/?target=https%3A//github.com/uboger/LibraryManager" target="_blank" rel="noopener">GitHub - uboger/LibraryManager: JAVA GUI 图书馆管理系统</a><br>源码下载（实例四）：<br><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/1993977042701312.htm" target="_blank" rel="noopener">java swing开发企业人事管理系统源代码下载</a></p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-2e9fd0ffd70f69b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="D7B0A549-CB0A-4704-8606-353E81499F49.png"></p><p>源码下载（实例一）：<a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2813720957340672.htm" target="_blank" rel="noopener">java swing开发网络聊天室群聊系统,基于java多线程socket编程</a><br>源码下载（实例二）：<br><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2476196100705280.htm" target="_blank" rel="noopener">java swing开发大猫聊天室源码，简单易懂，适合java swing初学者</a><br>源码下载（实例三）：<br><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2681158015126528.htm" target="_blank" rel="noopener">java websocket开发简单聊天室系统，实现群聊与一对一单人聊天案例</a><br>源码下载（实例四）：<br><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2920853761723392.htm" target="_blank" rel="noopener">jsp开发简单聊天室demo-分享</a></p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-68e06ee3777393c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AB4E245B-91DF-434F-A1C7-3AE76E283F57.png"></p><p>源码下载（一）：<br><a href="https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/w364483790/598859" target="_blank" rel="noopener">java通讯录实现了添加删除和查找功能</a><br>源码下载（二）：<br><a href="https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/laudukang/8341541" target="_blank" rel="noopener">JAVA版通讯录管理系统课程设计源码</a><br>源码下载（三）：<br><a href="https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/k4duizhang/2572237" target="_blank" rel="noopener">Java Swing界面.完美设计通讯录..有需要的下</a></p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-938a72554c06b156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C4B55EBC-9908-493C-8D9A-32502E26BA5E.png"></p><p>源码下载（一）：<br><a href="https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/csyrooney/1692151" target="_blank" rel="noopener">JAVA坦克大战+源代码（适合初学者）</a><br>源码下载（二）：<br><a href="https://link.zhihu.com/?target=https%3A//github.com/wangzhengyi/TankWar" target="_blank" rel="noopener">GitHub - wangzhengyi/TankWar: 用J2SE写的一个坦克大战小游戏，巩固一下java基础</a></p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-4472d559df9e9023.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="51847F0C-4D8E-4D66-8501-CDEC911944B9.png"></p><p>源码下载（一）：<br><a href="https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/kavilee11/4079842" target="_blank" rel="noopener">俄罗斯方块 JAVA版</a><br>源码下载（二）：<br><a href="https://link.zhihu.com/?target=https%3A//github.com/FieldSoft-HelloClyde/Tetris-Swing" target="_blank" rel="noopener">GitHub - FieldSoft-HelloClyde/Tetris-Swing: Swing编写的俄罗斯方块</a><br>源码下载（三）：<br><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2855443151621120.htm" target="_blank" rel="noopener">java swing开发的俄罗斯方块游戏，包含完整代码+详细注释</a></p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-6de10bf9fef4cd2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1ECD6359-BE19-4E66-BF47-1657758A04D7.png"></p><p>源码下载（一）：<br><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/cnlht/article/details/8176130" target="_blank" rel="noopener">Java实践（十一）——五子棋</a><br>源码下载（二）：<br><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2937407256464384.htm" target="_blank" rel="noopener">java swing开发的五子棋小游戏源码</a><br>源码下载（三）：<br><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/1550463383030784.htm" target="_blank" rel="noopener">java swing开发单机版五子棋源代码下载</a><br>源码下载（四）：<br><a href="https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/longyin415/2267863" target="_blank" rel="noopener">Java五子棋算法和代码</a></p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-1f1fb3de4ebafef7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9A7FEEB9-6874-4ECA-8253-80FC7DD87579.png"></p><p>源码下载（一）：<a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/cnlht/article/details/8205733" target="_blank" rel="noopener">Java实践（十二）——中国象棋</a></p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-6cfa3470adfa6472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C9191E15-EACE-4A24-AB0F-4AD9943D8B39.png"></p><p>源码下载（实例一）：<br><a href="https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/java_cxrs/1005980" target="_blank" rel="noopener">JAVA贪吃蛇源代码</a><br>源码下载（实例二）：<br><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/2255780075867136.htm" target="_blank" rel="noopener">java swing编写的3个小游戏程序源码，俄罗斯方块，贪吃蛇和坦克大战</a><br>源码下载（实例三）：<br><a href="https://link.zhihu.com/?target=http%3A//www.zuidaima.com/share/1737620634422272.htm" target="_blank" rel="noopener">java贪吃蛇源代码</a> 、  <a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/yaerfeng/article/details/23254623" target="_blank" rel="noopener">java贪吃蛇源代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java作为一门古老的语言，已有20年左右的历史，这在发展日新月异的技术圈可以说是一个神话。虽然不少人曾抱怨Java语言就像老太太的裹脚布，又臭又长，有时写了500行都不能表达程序员的意图。但从市场上的招聘现状看，Java工程师依然有着其他语言不可取代的竞争优势。招聘情况请
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA【关于Eclipse不自动弹出提示的解决办法】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA%E3%80%90%E5%85%B3%E4%BA%8EEclipse%E4%B8%8D%E8%87%AA%E5%8A%A8%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA【关于Eclipse不自动弹出提示的解决办法】/</id>
    <published>2018-11-29T14:03:01.000Z</published>
    <updated>2018-11-29T14:03:01.553Z</updated>
    
    <content type="html"><![CDATA[<p>Eclipse代码里面的代码提示功能默认是关闭的，只有输入“.”的时候才会提示功能<br>Win配置和Mac配置基本一致.</p><p>用过其他编辑器的用户可能不太习惯这种，普遍编辑器是输入任何字母都会提示，<br>下面说一下如何修改eclipse配置，开启代码自动提示功能打开 Eclipse  -&gt; Window -&gt; Perferences -&gt; Java -&gt; Editor -&gt; Content Assist，在右边最下面一栏找到 auto-Activation ，下面有三个选项，找到第二个“Auto activation triggers for Java：”选项在其后的文本框中会看到一个“.”存在。</p><blockquote><p>这表示：只有输入“.”之后才会有代码提示和自动补全，我们要修改的地方就是这。把该文本框中的“.”换掉，换成“abcdefghijklmnopqrstuvwxyz.”，这样，你在Eclipse里面写Java代码就可以做到按“abcdefghijklmnopqrstuvwxyz.”中的任意一个里字符都会有代码提示。</p></blockquote><p>在编写代码时敲出几个字符的情况下就迅速地完成代码，那是一件很爽的事。可是默认情况下，eclipse只有在你打出’.’（点字符）的时候，才会弹出自动补全窗口给你选择。这在大部分时候是完全不够用的。</p><p>由于eclipse 本身有很多选项是默认关闭的，这样开发者只能自己去手动配置一下.</p><p>那么如何配置eclipse的代码自动提示功能呢？</p><blockquote><p>1、Window ——&gt; Preferences ——&gt; Java ——&gt; Editor ——&gt; Content Assist</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/2692013-4a6fa560d6bdfa59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="B1712935-519A-4046-8014-1917BE025FC0.png"><br>1)将图中复选框勾上</p><p>2)将自动补全延迟的时间[auto activation delay(ms)]默认是200ms, 可以将时间缩短一些,比如我设置2ms.</p><p>3)[auto activation triggers for java]自动补全触发器,默认是”.”, 这个位置可以设置成26个字母外加’.’：.abcdefghijklmnopqrstuvwxyz(不区分大小写)</p><p>4)[auto activation triggers for javadoc]javadoc的触发器,默认是”@#”.</p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-dc3315691bd827c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="64DF6577-B4D2-43DB-87BB-CE73C20FABEF.png"></p><blockquote><p>2、eclipse的代码自动提示功能设置成功后：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/2692013-e87eb7cf5a3a5353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="B2640F61-7EFD-41C7-9B54-9C22CDCB8BD3.png"></p><p>#####可是eclipse不允许输入这么的字符，文本框中最多允许输入4个字符，因此要通过修改配置文件的方法实现，具体操作步骤如下</p><ol><li><p>打开Eclipse，然后“window”→“Preferences”</p></li><li><p>选择“java”，展开，“Editor”，选择“Content Assist”。</p></li></ol><p>3.选择“Content Assist”，然后看到右边，右边的“Auto Activation”下面的“Auto Activation triggers for java”这个选项。其实就是指触发代码提示的就是“.”这个符号。</p><p>4.“Auto Activation triggers for java”这个选项，在“.”后加abc字母，方便后面的查找修改。然后“apply”，点击“OK”。</p><ol><li><p>然后，“File”→“Export”，在弹出的窗口中选择“General”→“Perferences”，点击“下一步”。</p></li><li><p>选择导出文件路径，本人导出到桌面，输入“abc”作为文件名，点击“保存”。</p></li><li><p>在桌面找到刚在保存的文件“abc.epf”,右键选择“用记事本打开”。</p></li><li><p>按“ctrl + F”快捷键，输入“.abc”，点击“查找下一个”。</p></li><li><p>查找到“.abc”的配置信息如下：如下：</p></li><li><p>把“.abc”改成“.abcdefghijklmnopqrstuvwxyz(,”，保存，关闭“test.epf”。</p></li><li><p>回到MyEclipse界面，“File”→“Import”，在弹出的窗口中选择“Perferences”，点击“下一步”，选</p></li></ol><p>择刚在已经修改的“abc.epf”文件，点击“打开”，点击“Finish”。该步骤和上面 的导出步骤类似。</p><p>12.修改完毕，测试一下就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Eclipse代码里面的代码提示功能默认是关闭的，只有输入“.”的时候才会提示功能&lt;br&gt;Win配置和Mac配置基本一致.&lt;/p&gt;
&lt;p&gt;用过其他编辑器的用户可能不太习惯这种，普遍编辑器是输入任何字母都会提示，&lt;br&gt;下面说一下如何修改eclipse配置，开启代码自动提示功
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA【基于JAVA调用免费天气api接口示例】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/JAVA/</id>
    <published>2018-11-29T14:02:00.000Z</published>
    <updated>2018-11-29T14:02:39.901Z</updated>
    
    <content type="html"><![CDATA[<p>查询天气预报在APP中常用的一个常用功能，聚合数据免费天气api接口可以根据根据城市名/id查询天气、根据IP查询天气、据GPS坐标查询天气、查询城市天气三小时预报，并且支持全国不同城市天气预报查询。<br>代码描述：基于JAVA的免费天气api接口调用示例，根据文档中注明的需求参数,调用接口返回数据。<br>关联数据：免费天气api<br>接口地址：<a href="https://www.juhe.cn/docs/api/id/39" target="_blank" rel="noopener">https://www.juhe.cn/docs/api/id/39</a><br>step1:选择本文所示例的接口”免费天气api” url:<a href="https://www.juhe.cn/docs/api/id/39/aid/87" target="_blank" rel="noopener">https://www.juhe.cn/docs/api/id/39/aid/87</a><br>step2:每个接口都需要传入一个参数key,相当于用户的令牌,所以第一步你需要申请一个key<br>step3:看文档!!!学过java的同学们都知道,当我们对一个类或者方法不明白其意图和思想时,我们可以去查看文档,这里也不例外,而且对于英文不是特别好的同学来说很幸运的是,聚合网站上的文档都是中文版本的,比起阅读java源码里的英文文档应该轻松很多.<br>全国天气预报接口下面有六个子接口,打开第一个接口链接,看文档发现需要传入一个城市名或者城市ID参数,这个参数我们可以通过第六个子接口获取(接口之间参数的调用类似于java中方法之间的调用),即支持城市列表获取.所以示例中我们先调用这个接口.调用接口涉及到请求网络资源的问题,这里我封装了一个工具类,包含GET和POST两种方法<br>step4:上代码</p><h4 id="Demo1-网络访问工具类-封装get和post方法"><a href="#Demo1-网络访问工具类-封装get和post方法" class="headerlink" title="Demo1:网络访问工具类(封装get和post方法)"></a>Demo1:网络访问工具类(封装get和post方法)</h4><h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package juheAPI;  </span><br><span class="line">    </span><br><span class="line">import java.io.BufferedReader;  </span><br><span class="line">import java.io.BufferedWriter;  </span><br><span class="line">import java.io.InputStream;  </span><br><span class="line">import java.io.InputStreamReader;  </span><br><span class="line">import java.io.OutputStream;  </span><br><span class="line">import java.io.OutputStreamWriter;  </span><br><span class="line">import java.net.HttpURLConnection;  </span><br><span class="line">import java.net.URL;  </span><br><span class="line">import java.util.Map;  </span><br><span class="line">/** </span><br><span class="line"> * 网络访问工具类 </span><br><span class="line"> * @author silk </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">public class PureNetUtil &#123;  </span><br><span class="line">    /** </span><br><span class="line">     * get方法直接调用post方法 </span><br><span class="line">     * @param url 网络地址 </span><br><span class="line">     * @return 返回网络数据 </span><br><span class="line">     */  </span><br><span class="line">    public static String get(String url)&#123;  </span><br><span class="line">        return post(url,null);  </span><br><span class="line">    &#125;  </span><br><span class="line">    /** </span><br><span class="line">     * 设定post方法获取网络资源,如果参数为null,实际上设定为get方法 </span><br><span class="line">     * @param url 网络地址 </span><br><span class="line">     * @param param 请求参数键值对 </span><br><span class="line">     * @return 返回读取数据 </span><br><span class="line">     */  </span><br><span class="line">   public static &lt;K, V&gt; String post(String  url,Map&lt;K,V&gt;   param)&#123;  </span><br><span class="line">        HttpURLConnection conn=null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            URL u=new URL(url);  </span><br><span class="line">            conn=(HttpURLConnection) u.openConnection();  </span><br><span class="line">            StringBuffer sb=null;  </span><br><span class="line">            if(param!=null)&#123;//如果请求参数不为空  </span><br><span class="line">                sb=new StringBuffer();  </span><br><span class="line">                /*A URL connection can be used for input and/or output.  Set the DoOutput </span><br><span class="line">                 * flag to true if you intend to use the URL connection for output, </span><br><span class="line">                 * false if not.  The default is false.*/  </span><br><span class="line">                //默认为false,post方法需要写入参数,设定true  </span><br><span class="line">                conn.setDoOutput(true);  </span><br><span class="line">                //设定post方法,默认get  </span><br><span class="line">                conn.setRequestMethod(&quot;POST&quot;);  </span><br><span class="line">                //获得输出流  </span><br><span class="line">                OutputStream out=conn.getOutputStream();  </span><br><span class="line">                //对输出流封装成高级输出流  </span><br><span class="line">                BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out));  </span><br><span class="line">                //将参数封装成键值对的形式  </span><br><span class="line">                for(Map.Entry s:param.entrySet())&#123;  </span><br><span class="line">                    sb.append(s.getKey()).append(&quot;=&quot;).append(s.getValue()).append(&quot;&amp;&quot;);  </span><br><span class="line">                &#125;  </span><br><span class="line">                //将参数通过输出流写入  </span><br><span class="line">                writer.write(sb.deleteCharAt(sb.toString().length()-1).toString());  </span><br><span class="line">                writer.close();//一定要关闭,不然可能出现参数不全的错误  </span><br><span class="line">                sb=null;  </span><br><span class="line">            &#125;  </span><br><span class="line">            conn.connect();//建立连接  </span><br><span class="line">            sb=new StringBuffer();  </span><br><span class="line">            //获取连接状态码  </span><br><span class="line">            int recode=conn.getResponseCode();  </span><br><span class="line">            BufferedReader reader=null;  </span><br><span class="line">            if(recode==200)&#123;  </span><br><span class="line">                //Returns an input stream that reads from this open connection  </span><br><span class="line">                //从连接中获取输入流  </span><br><span class="line">                InputStream in=conn.getInputStream();  </span><br><span class="line">                //对输入流进行封装  </span><br><span class="line">                reader=new BufferedReader(new InputStreamReader(in));  </span><br><span class="line">                String str=null;  </span><br><span class="line">                sb=new StringBuffer();  </span><br><span class="line">                //从输入流中读取数据  </span><br><span class="line">                while((str=reader.readLine())!=null)&#123;  </span><br><span class="line">                    sb.append(str).append(System.getProperty(&quot;line.separator&quot;));  </span><br><span class="line">                &#125;  </span><br><span class="line">                //关闭输入流  </span><br><span class="line">                reader.close();  </span><br><span class="line">                if (sb.toString().length() == 0) &#123;  </span><br><span class="line">                    return null;  </span><br><span class="line">                &#125;  </span><br><span class="line">                return sb.toString().substring(0,  </span><br><span class="line">                        sb.toString().length() - System.getProperty(&quot;line.separator&quot;).length());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            return null;  </span><br><span class="line">        &#125;finally&#123;  </span><br><span class="line">            if(conn!=null)//关闭连接  </span><br><span class="line">                conn.disconnect();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Demo2-调用获取城市列表接口示例"><a href="#Demo2-调用获取城市列表接口示例" class="headerlink" title="Demo2:调用获取城市列表接口示例"></a>Demo2:调用获取城市列表接口示例</h4><h4 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package juheAPI;  </span><br><span class="line">   </span><br><span class="line">import net.sf.json.JSONArray;  </span><br><span class="line">import net.sf.json.JSONObject;  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">/** </span><br><span class="line"> * 获取城市列表 </span><br><span class="line"> * 全国天气预报接口调用JAVA示例 </span><br><span class="line"> *     dtype     string    N    返回数据格式：json或xml,默认json     </span><br><span class="line"> *     key        string     Y    你申请的key     </span><br><span class="line"> * @author silk </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">public class GetCityList &#123;  </span><br><span class="line">    /** </span><br><span class="line">     * 调用获取城市列表接口,返回所有数据 </span><br><span class="line">     * @return 返回接口数据 </span><br><span class="line">     */  </span><br><span class="line">    public static String excute()&#123;  </span><br><span class="line">        String url=&quot;http://v.juhe.cn/weather/citys?key=***a7558b2e0bedaa19673f74a6809ce&quot;;//接口URL  </span><br><span class="line">        //PureNetUtil是一个封装了get和post方法获取网络请求数据的工具类  </span><br><span class="line">        return PureNetUtil.get(url);//使用get方法  </span><br><span class="line">    &#125;  </span><br><span class="line">    /** </span><br><span class="line">     * 调用接口返回数据后,解析数据,根据输入城市名得到对应ID </span><br><span class="line">     * @param cityName 城市名称 </span><br><span class="line">     * @return 返回对应ID </span><br><span class="line">     */  </span><br><span class="line">    public static String getIDBycityName(String cityName) &#123;  </span><br><span class="line">        String result=excute();//返回接口结果,得到json格式数据  </span><br><span class="line">        if(result!=null)&#123;  </span><br><span class="line">            JSONObject obj=JSONObject.fromObject(result);  </span><br><span class="line">            result=obj.getString(&quot;resultcode&quot;);//得到返回状态码  </span><br><span class="line">            if(result!=null&amp;&amp;result.equals(&quot;200&quot;))&#123;//200表示成功返回数据  </span><br><span class="line">                result=obj.getString(&quot;result&quot;);//得到城市列表的json格式字符串数组  </span><br><span class="line">                JSONArray arr=JSONArray.fromObject(result);  </span><br><span class="line">                for(Object o:arr)&#123;//对arr进行遍历  </span><br><span class="line">                    //将数组中的一个json个数字符串进行解析  </span><br><span class="line">                    obj=JSONObject.fromObject(o.toString());  </span><br><span class="line">                    /*此时obj如 &#123;&quot;id&quot;:&quot;2&quot;,&quot;province&quot;:&quot;北京&quot;,&quot;city&quot;:&quot;北京&quot;,&quot;district&quot;:&quot;海淀&quot;&#125;*/  </span><br><span class="line">                    //以city这个key为线索判断所需要寻找的这条记录  </span><br><span class="line">                    result=obj.getString(&quot;district&quot;);  </span><br><span class="line">                    //防止输入城市名不全,如苏州市输入为苏州,类似与模糊查询  </span><br><span class="line">                    if(result.equals(cityName)||result.contains(cityName))&#123;  </span><br><span class="line">                        result=obj.getString(&quot;id&quot;);//得到ID  </span><br><span class="line">                        return result;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        System.out.println(getIDBycityName(&quot;香港&quot;));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Demo3-调用根据城市名-id查询天气"><a href="#Demo3-调用根据城市名-id查询天气" class="headerlink" title="Demo3:调用根据城市名/id查询天气"></a>Demo3:调用根据城市名/id查询天气</h4><h4 id="Java代码-2"><a href="#Java代码-2" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package juheAPI;  </span><br><span class="line">   </span><br><span class="line">import net.sf.json.JSONObject;  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">/** </span><br><span class="line"> * 根据城市名/id查询天气 </span><br><span class="line"> * @author silk </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">public class WeatherReportByCity &#123;  </span><br><span class="line">    /** </span><br><span class="line">     * 根据城市名获取 </span><br><span class="line">     * @param cityName </span><br><span class="line">     * @return </span><br><span class="line">     */  </span><br><span class="line">    public static String excute(String cityName)&#123;  </span><br><span class="line">        String url=//此处以返回json格式数据示例,所以format=2,以根据城市名称为例,cityName传入中文  </span><br><span class="line">                &quot;http://v.juhe.cn/weather/index?cityname=&quot;+cityName+&quot;&amp;key=***a7558b2e0bedaa19673f74a6809ce&quot;;  </span><br><span class="line">        return PureNetUtil.get(url);//通过工具类获取返回数据  </span><br><span class="line">    &#125;  </span><br><span class="line">    /** </span><br><span class="line">     * 获取返回数据中的一个属性示例,此处以获取今日温度为例 </span><br><span class="line">     * &quot;temperature&quot;: &quot;8℃~20℃&quot;     今日温度 </span><br><span class="line">     * @param args </span><br><span class="line">     * @return  </span><br><span class="line">     */  </span><br><span class="line">    public static String GetTodayTemperatureByCity(String city) &#123;  </span><br><span class="line">        String result=excute(city);  </span><br><span class="line">        if(result!=null)&#123;  </span><br><span class="line">            JSONObject obj=JSONObject.fromObject(result);  </span><br><span class="line">            /*获取返回状态码*/  </span><br><span class="line">            result=obj.getString(&quot;resultcode&quot;);  </span><br><span class="line">            /*如果状态码是200说明返回数据成功*/  </span><br><span class="line">            if(result!=null&amp;&amp;result.equals(&quot;200&quot;))&#123;  </span><br><span class="line">                result=obj.getString(&quot;result&quot;);  </span><br><span class="line">                //此时result中数据有多个key,可以对其key进行遍历,得到对个属性  </span><br><span class="line">                obj=JSONObject.fromObject(result);  </span><br><span class="line">                //今日温度对应的key是today  </span><br><span class="line">                result=obj.getString(&quot;today&quot;);  </span><br><span class="line">                obj=JSONObject.fromObject(result);  </span><br><span class="line">                //今日温度对应当key是temperature  </span><br><span class="line">                result=obj.getString(&quot;temperature&quot;);  </span><br><span class="line">                return result;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        System.out.println(GetTodayTemperatureByCity(&quot;苏州&quot;));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Demo4-调用天气种类及表示列表接口示例"><a href="#Demo4-调用天气种类及表示列表接口示例" class="headerlink" title="Demo4:调用天气种类及表示列表接口示例"></a>Demo4:调用天气种类及表示列表接口示例</h4><h4 id="Java代码-3"><a href="#Java代码-3" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package juheAPI;  </span><br><span class="line">   </span><br><span class="line">import net.sf.json.JSONArray;  </span><br><span class="line">import net.sf.json.JSONObject;  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">/** </span><br><span class="line"> * 天气种类及标识列表接口调用JAVA示例 </span><br><span class="line"> * @author silk </span><br><span class="line"> */  </span><br><span class="line">public class GetWeatherSignAndTypeList &#123;  </span><br><span class="line">    //接口地址,因为只需要传入一个固定的key为参数,所以设为常量  </span><br><span class="line">    private static final String URL= &quot;http://v.juhe.cn/weather/uni?key=***a7558b2e0bedaa19673f74a6809ce&quot;;  </span><br><span class="line">    /** </span><br><span class="line">     * 通过工具类获取数据 </span><br><span class="line">     * @return </span><br><span class="line">     */  </span><br><span class="line">    public static String excute()&#123;  </span><br><span class="line">        return PureNetUtil.get(URL);//调用工具类获取接口数据  </span><br><span class="line">    &#125;  </span><br><span class="line">    /** </span><br><span class="line">     * 利用遍历数组的方式获取 </span><br><span class="line">     * @param wid天气对应id </span><br><span class="line">     * @return 天气名称 </span><br><span class="line">     */  </span><br><span class="line">    public static String getWeatherByWid(String wid) &#123;  </span><br><span class="line">        String result=excute();//获取接口数据  </span><br><span class="line">        if(result!=null)&#123;  </span><br><span class="line">            JSONObject obj=JSONObject.fromObject(result);  </span><br><span class="line">            result=obj.getString(&quot;resultcode&quot;);  </span><br><span class="line">            /*获取返回状态码*/  </span><br><span class="line">            if(result!=null&amp;&amp;result.equals(&quot;200&quot;))&#123;  </span><br><span class="line">                /*获取数组数据*/  </span><br><span class="line">                result=obj.getString(&quot;result&quot;);  </span><br><span class="line">                JSONArray arr=JSONArray.fromObject(result);  </span><br><span class="line">                for(Object o:arr)&#123;//遍历数组  </span><br><span class="line">                    obj=JSONObject.fromObject(o.toString());  </span><br><span class="line">                    //如果遍历到需要的数据后直接返回结果,根据key(wid)得到value判断是否等于传入参数  </span><br><span class="line">                    if(obj.getString(&quot;wid&quot;).equals(wid))&#123;  </span><br><span class="line">                        result=obj.getString(&quot;weather&quot;);  </span><br><span class="line">                        return result;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        System.out.println(getWeatherByWid(&quot;10&quot;));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  step5:调用接口时候如果状态码不是200,仔细参考文档说明!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查询天气预报在APP中常用的一个常用功能，聚合数据免费天气api接口可以根据根据城市名/id查询天气、根据IP查询天气、据GPS坐标查询天气、查询城市天气三小时预报，并且支持全国不同城市天气预报查询。&lt;br&gt;代码描述：基于JAVA的免费天气api接口调用示例，根据文档中注明
      
    
    </summary>
    
      <category term="JAVA" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>IOS【加载微信文章注入JS实现交互 浏览图片及保存】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS%E3%80%90%E5%8A%A0%E8%BD%BD%E5%BE%AE%E4%BF%A1%E6%96%87%E7%AB%A0%E6%B3%A8%E5%85%A5JS%E5%AE%9E%E7%8E%B0%E4%BA%A4%E4%BA%92-%E6%B5%8F%E8%A7%88%E5%9B%BE%E7%89%87%E5%8F%8A%E4%BF%9D%E5%AD%98%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【加载微信文章注入JS实现交互-浏览图片及保存】/</id>
    <published>2018-11-29T14:01:58.000Z</published>
    <updated>2018-11-29T14:01:59.087Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目某个模块中要求可以实现对网页中图片的查看，并要求在多张图片的情况下可以实现滑动浏览。<br>所以，问题的集中点就是如何获取所有的图片地址及添加图片的点击事件。不多说，直接上码！</p><p>在网页加载完成时，通过js获取图片和添加点击的识别方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</span><br><span class="line">    [IDProgressHUD IDPlaceViewHideDirect:self.view];</span><br><span class="line">    </span><br><span class="line">    //这里是js，主要目的实现对url的获取</span><br><span class="line">    static  NSString * const jsGetImages =</span><br><span class="line">    @&quot;function getImages()&#123;\</span><br><span class="line">    var objs = document.getElementsByTagName(\&quot;img\&quot;);\</span><br><span class="line">    var imgScr = &apos;&apos;;\</span><br><span class="line">    for(var i=0;i&lt;objs.length;i++)&#123;\</span><br><span class="line">    imgScr = imgScr + objs[i].src + &apos;+&apos;;\</span><br><span class="line">    &#125;;\</span><br><span class="line">    return imgScr;\</span><br><span class="line">    &#125;;&quot;;</span><br><span class="line">    </span><br><span class="line">    [webView stringByEvaluatingJavaScriptFromString:jsGetImages];//注入js方法</span><br><span class="line">    NSString *urlResurlt = [webView stringByEvaluatingJavaScriptFromString:@&quot;getImages()&quot;];</span><br><span class="line">    mUrlArray = [NSMutableArray arrayWithArray:[urlResurlt componentsSeparatedByString:@&quot;+&quot;]];</span><br><span class="line">    if (mUrlArray.count &gt;= 2) &#123;</span><br><span class="line">        [mUrlArray removeLastObject];</span><br><span class="line">    &#125;</span><br><span class="line">    //urlResurlt 就是获取到得所有图片的url的拼接；mUrlArray就是所有Url的数组</span><br><span class="line">    </span><br><span class="line">    //添加图片可点击js</span><br><span class="line">    [mWebView stringByEvaluatingJavaScriptFromString:@&quot;function registerImageClickAction()&#123;\</span><br><span class="line">     var imgs=document.getElementsByTagName(&apos;img&apos;);\</span><br><span class="line">     var length=imgs.length;\</span><br><span class="line">     for(var i=0;i&lt;length;i++)&#123;\</span><br><span class="line">     img=imgs[i];\</span><br><span class="line">     img.onclick=function()&#123;\</span><br><span class="line">     window.location.href=&apos;image-preview:&apos;+this.src&#125;\</span><br><span class="line">     &#125;\</span><br><span class="line">     &#125;&quot;];</span><br><span class="line">    [mWebView stringByEvaluatingJavaScriptFromString:@&quot;registerImageClickAction();&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//在这个方法中捕获到图片的点击事件和被点击图片的url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;</span><br><span class="line">    </span><br><span class="line">    //预览图片</span><br><span class="line">    if ([request.URL.scheme isEqualToString:@&quot;image-preview&quot;]) &#123;</span><br><span class="line">        NSString* path = [request.URL.absoluteString substringFromIndex:[@&quot;image-preview:&quot; length]];</span><br><span class="line">        path = [path stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">        //path 就是被点击图片的url</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>#以下是保存所在作用域的图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">    //添加长按事件</span><br><span class="line">    UILongPressGestureRecognizer *longPressed = [[UILongPressGestureRecognizer alloc]</span><br><span class="line">                                                 initWithTarget:self action:@selector(longPressed:)];</span><br><span class="line">    longPressed.minimumPressDuration = 0.3;</span><br><span class="line">    longPressed.delegate = self;</span><br><span class="line">    [webView addGestureRecognizer:longPressed];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> 获取长按事件所在的位置图片</span><br><span class="line"> */</span><br><span class="line">- (void)longPressed:(UILongPressGestureRecognizer*)recognizer</span><br><span class="line">&#123;</span><br><span class="line">    if (recognizer.state != UIGestureRecognizerStateBegan) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    CGPoint touchPoint = [recognizer locationInView:_webView];</span><br><span class="line">    NSString *imgURL = [NSString stringWithFormat:@&quot;document.elementFromPoint(%f, %f).src&quot;,</span><br><span class="line">                        touchPoint.x, touchPoint.y];</span><br><span class="line">    NSString *webImage = [_webView stringByEvaluatingJavaScriptFromString:imgURL];</span><br><span class="line">    </span><br><span class="line">    if([webImage rangeOfString:@&quot;player&quot;].location !=NSNotFound || webImage.length == 0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self showImageOptionsWithUrl:webImage];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)showImageOptionsWithUrl:(NSString *)imageUrl</span><br><span class="line">&#123;</span><br><span class="line">    _webImageURL = imageUrl;</span><br><span class="line">    IBActionSheet *standardIBAS = [[IBActionSheet alloc] initWithTitle:nil delegate:self cancelButtonTitle:@&quot;取消&quot; destructiveButtonTitle:@&quot;保存图片&quot; otherButtonTitles:nil];</span><br><span class="line">    [standardIBAS setFont:FontWithSize(SIZE_FONT_CONTENT)];</span><br><span class="line">    [standardIBAS setTitleFont:FontWithSize(SIZE_FONT_SUBCONTENT)];</span><br><span class="line">    [standardIBAS setButtonTextColor:[UIColor blackColor]];</span><br><span class="line">    [standardIBAS showInView:self.navigationController.view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - IBActionSheetDelegate</span><br><span class="line"></span><br><span class="line">-(void)actionSheet:(IBActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex&#123;</span><br><span class="line">    </span><br><span class="line">    if (buttonIndex == 0) &#123;</span><br><span class="line">        </span><br><span class="line">        NSURL *url = [NSURL URLWithString:_webImageURL];</span><br><span class="line">        NSURLSessionConfiguration * configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">        NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:[NSOperationQueue new]];</span><br><span class="line">        NSURLRequest *imgRequest = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:30.0];</span><br><span class="line">        </span><br><span class="line">        NSURLSessionDownloadTask  *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            NSData * imageData = [NSData dataWithContentsOfURL:location];</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                UIImage * image = [UIImage imageWithData:imageData];</span><br><span class="line">                UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL);</span><br><span class="line">            &#125;);   </span><br><span class="line">        &#125;];</span><br><span class="line">        [task resume];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后记：js挺好玩，我相信以后还会去多接触它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目某个模块中要求可以实现对网页中图片的查看，并要求在多张图片的情况下可以实现滑动浏览。&lt;br&gt;所以，问题的集中点就是如何获取所有的图片地址及添加图片的点击事件。不多说，直接上码！&lt;/p&gt;
&lt;p&gt;在网页加载完成时，通过js获取图片和添加点击的识别方式&lt;br&gt;&lt;figur
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IOS【关于iOS开发中比较常见的优化】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS%E3%80%90%E5%85%B3%E4%BA%8EiOS%E5%BC%80%E5%8F%91%E4%B8%AD%E6%AF%94%E8%BE%83%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BC%98%E5%8C%96%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【关于iOS开发中比较常见的优化】/</id>
    <published>2018-11-29T14:01:20.000Z</published>
    <updated>2018-11-29T14:01:23.714Z</updated>
    
    <content type="html"><![CDATA[<p>一. 如何让你的应用程序更加省电？<br>答：<br>(1). 如果程序用到定位，需要在定位完毕之后关闭定位，或者降低定位的频率，不停的定位会消耗电量。(2). 如果用到了蓝牙，需要使用蓝牙时候开启蓝牙，蓝牙用完之后关闭蓝牙，蓝牙也很耗电。<br>(3). 优化算法，减少循环次数，大量循环会让CPU一直处于忙碌状态，特别费电。<br>(4). 尽量不要使用网络轮询（心跳包、定时器），使用推送。<br>(5). timer的时间间隔不宜太短，满足需求即可。<br>(6). 不要频繁刷新页面，能刷新1行cell的最好刷新一行，尽量不要reloadData。<br>(7). 线程适量，不宜过多。</p><p>二、简单描述一下你在开发的过程中，如何实现程序的性能优化？</p><p>答：我在开发的过程中会注意一下几点来优化程序性能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）.避免庞大的XIB、Storyboard，尽量多用纯代码开发</span><br><span class="line">2）.使用懒加载的方式延迟加载界面</span><br><span class="line">3）.避免反复处理数据</span><br><span class="line">4）.避免使用NSDateFormatter和NSCalendar。</span><br><span class="line"></span><br><span class="line">5）.图片缓存的取舍UIImage加载图片方式一般有两种:A：imagedNamed初始化B：imageWithContentsOfFile初始化二者不同之处在于,imageNamed默认加载图片成功后会内存中缓存图片,这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象.如果缓存中没有找到相应的图片对象,则从指定地方加载图片然后缓存对象，并返回这个图片对象.而imageWithContentsOfFile则仅只加载图片,不缓存.大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间来做这件事.当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片的，用imageWithContentsOfFile是最为经济的方式,这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间.使用场景需要编程时，应该根据实际应用场景加以区分，UIImage虽小，但使用元素较多问题会有所凸显.</span><br></pre></td></tr></table></figure></p><p>三、tableView的重用机制？（简单了解即可）</p><p>查看UITableView头文件，会找到NSMutableArray<em> visiableCells，和NSMutableDictnery</em>reusableTableCells两个结构。visiableCells内保存当前显示的cells，reusableTableCells保存可重用的cells。TableView显示之初，reusableTableCells为空，那么tableViewdequeueReusableCellWithIdentifier:CellIdentifier返回nil。开始的cell都是通过[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]来创建，而且cellForRowAtIndexPath只是调用最大显示cell数的次数。比如：有100条数据，iPhone一屏最多显示10个cell。程序最开始显示TableView的情况是：1.用<br>[[UITableViewCellalloc] initWithStyle:UITableViewCellStyleDefaultreuseIdentifier:CellIdentifier]</p><p>创建10次cell，并给cell指定同样的重用标识(当然，可以为不同显示类型的cell指定不同的标识)。并且10个cell全部都加入到visiableCells数组，reusableTableCells为空。2.向下拖动tableView，当cell1完全移出屏幕，并且cell11(它也是alloc出来的，原因同上)完全显示出来的时候。cell11加入到visiableCells，cell1移出visiableCells，cell1加入到reusableTableCells。3.接着向下拖动tableView，因为reusableTableCells中已经有值，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用的时候，tableViewdequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。cell1加入到visiableCells，cell1移出reusableTableCells；cell2移出visiableCells，cell2加入到reusableTableCells。之后再需要显示的Cell就可以正常重用了。</p><p>四、如何减小一个应用程序占用存储空间？</p><p>检查程序 去掉多余的xib。iOS App Store相关因素作为提交到App Store中app里的可执行文件是被加过密的。加密的副作用是可执行文件的压缩效果没有之前的好了。Build Settings编译选项，将build setting中的Optimization Level设置为Fastest, Smallest [-Os];将build setting中的Strip Debug Symbols During Copy设置为YES(COPY_PHASE_STRIP = YES)，这样可以减小编译出二进制文件的尺寸。Target针对较少的CPUs对程序指定的特定CPU类型做优化处理，以生成相对于的可执行文件。不同的硬件，将运行不同的可执行代码。虽然这样优化后的程序，只能针对某些设备运行，但是这大大减小可执行程序的大小。要想只设定特定类型的CPUs，可以修改build setting中的Architectures，将其从Standard $(ARCHS_STANDARD)修改为你希望支持的列表中对应的特定类型CPU。有效的CPU名称列在Valid Architectures (VALID_ARCHS) build setting中。请不要修改Valid Architectures设置项，最好由Xcode管理。尽量使用8-bit图片。使用8-bit的PNG图片，比32-bit的图片能减少4倍的压缩率。由于8-bit的图片支持最多256种不同的颜色，所以8-bit的图片一般只应该用于一小部分的颜色图片。例如灰度图片最好使用8-bit</p><p>五、如何提高一个应用程序的性能？</p><p>1、使用ARC减少内存失误，dealloc需要重写并对属性置nil。2、重用。3、尽量少使用透明或半透明。会产生额外的运算。4、少用运算获得圆角，不论view.maskToBounds还是layer.clipToBounds都会有很大资源开销，必须要用圆角的话不如图片本身就做成圆角。5、不要阻塞主线程。6、使用正确的容器类型。7、图片与imageView相同大小避免多余运算。8、使用懒加载。9、使用绘制。</p><p>六、如何优化内存？</p><p>（1）.用ARC管理内存ARC(Automatic ReferenceCounting,自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存。（2）.在正确的地方使用reuseIdentifier一个开发中常见的错误就是没有给UITableViewCells，UICollectionViewCells，甚至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。<br>（3）.尽量把views设置为透明如果你有透明的Views你应该设置它们的opaque属性为YES。原因是这会使系统用一个最优的方式渲染这些views。如果设为YES，渲染系统就认为这个view是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是YES。<br>（4）.避免过于庞大的XIB当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。<br>（5）.不要阻塞主线程永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。一直使用主线程的风险就是如果你的代码真的block了主线程，你的app会失去反应。大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。<br>（6）.在Image Views中调整图片大小如果要在UIImageView<br>中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是UIImageView<br>嵌套在UIScrollView<br>中的情况下。如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。<br>（7）.选择正确的Collection学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理collections时这句话尤其正确。一些常见collection的总结：·Arrays:有序的一组值。使用index来lookup很快，使用value lookup很慢，插入/删除很慢。·Dictionaries:存储键值对。用键来查找比较快。·Sets:无序的一组值。用值来查找很快，插入/删除很快。<br>（8）.打开gzip压缩大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。好消息是，iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经支持了压缩输出。<br>（9）.重用和延迟加载(lazy load) Views更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。这里我们用到的技巧就是模仿UITableView<br>和UICollectionView的操作:不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。创建views的能效问题也适用于你app的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个view的场景。有两种实现方法：1.创建并隐藏这个view当这个screen加载的时候，当需要时显示它；2.当需要时才创建并展示。每个方案都有其优缺点。用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。<br>（10）. Cache, Cache,还是Cache!一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。NSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。<br>（11）.权衡渲染方法在iOS中可以有很多方法做出漂亮的按钮。你可以用整幅的图片，可调大小的图片，uozhe可以用CALayer，CoreGraphics甚至OpenGL来画它们。当然每个不同的解决方法都有不同的复杂程度和相应的性能。简单来说，就是用事先渲染好的图片更快一些，因为如此一来iOS就免去了创建一个图片再画东西上去然后显示在屏幕上的程序。问题是你需要把所有你需要用到的图片放到app的bundle里面，这样就增加了体积–这就是使用可变大小的图片更好的地方了:你可以省去一些不必要的空间，也不需要再为不同的元素(比如按钮)来做不同的图。然而，使用图片也意味着你失去了使用代码调整图片的机动性，你需要一遍又一遍不断地重做他们，这样就很浪费时间了，而且你如果要做一个动画效果，虽然每幅图只是一些细节的变化你就需要很多的图片造成bundle大小的不断增大。总得来说，你需要权衡一下利弊，到底是要性能能还是要bundle保持合适的大小。<br>（12）.处理内存警告一旦系统内存过低，iOS会通知所有运行中app。如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.幸运的是，UIKit提供了几种收集低内存警告的方法:· 在app delegate中使用applicationDidReceiveMemoryWarning:<br>的方法· 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning<br>· 注册并接收UIApplicationDidReceiveMemoryWarningNotification的通知一旦收到这类通知，你就需要释放任何不必要的内存使用。例如，UIViewController的默认行为是移除一些不可见的view，它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。<br>（13）.重用大开销对象一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。<br>（14）.减少使用Web特性UIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。但是你可能有注意到UIWebView并不像不像驱动Safari的那么快。这是由于以JIT compilation为特色的Webkit的Nitro Engine的限制。所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。<br>（15）.优化Table ViewTable view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。为了保证table view平滑滚动，确保你采取了以下的措施:· 正确使用reuseIdentifier<br>来重用cells· 尽量使所有的view opaque，包括cell自身· 避免渐变，图片缩放，后台选人· 缓存行高· 如果cell内现实的内容来自web，使用异步加载，缓存请求结果· 使用shadowPath<br>来画阴影· 减少subviews的数量·尽量不适用cellForRowAtIndexPath:<br>，如果你需要用到它，只用一次然后缓存结果· 使用正确的数据结构来存储数据· 使用rowHeight<br>,sectionFooterHeight<br>和sectionHeaderHeight<br>来设定固定的高，不要请求delegate<br>（16）.使用Autorelease PoolNSAutoreleasePool<br>负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为：<br>NSArray <em>urls = &lt;# An array of file URLs #&gt;;for(NSURL </em>url in urls) {@autoreleasepool {NSError <em>error;NSString </em>fileContents = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];/<em> Process the string, creating and autoreleasing more objects. </em>/}}</p><p>这段代码在每次遍历后释放所有autorelease对象<br>（17）.选择是否缓存图片常见的从bundle中加载图片的方式有两种，一个是用imageNamed<br>，二是用imageWithContentsOfFile<br>，第一种比较常见一点。既然有两种类似的方法来实现相同的目的，那么他们之间的差别是什么呢？imageNamed<br>的优点是当加载时会缓存图片。imageNamed<br>的文档中这么说:这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。相反的，imageWithContentsOfFile<br>仅加载图片。如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用imageWithContentsOfFile<br>足矣，这样不会浪费内存来缓存它。然而，在图片反复重用的情况下imageNamed<br>是一个好得多的选择。</p><p>七、如何加强iOS里的列表滚动时的顺畅感？</p><p>1、UITableViewCell里不要添加太多subview，最好只添加一个cellview。<br>2、UITableViewCell上的子View的opaque属性设为YES。其实默认也是不透明。UITableViewCell尽量不要包含透明的子View。<br>3、在cellview里，重写drawRect函数绘制UITableViewCell的内容。<br>4、在绘制字符串时，尽可能使用drawAtPoint: withFont:，而不要使用更复杂的drawAtPoint:(CGPoint)point forWidth:(CGFloat)width withFont:(UIFont <em>)font lineBreakMode:(UILineBreakMode)lineBreakMode;如果要绘制过长的字符串，建议自己先截断，然后使用drawAtPoint: withFont:方法绘制。<br>5、在绘制图片时，尽量使用drawAtPoint，而不要使用drawInRect。drawInRect如果在绘制过程中对图片进行放缩，会特别消耗CPU。<br>6、如果绘制cell过程中，需要下载cell中的图片，建议在绘制cell一段时间后再开启图片下载任务。譬如先画一个默认图片，然后在0.5S后开始下载本cell的图片。<br>7、即使下载cell图片是在子线程中进行，在绘制cell过程中，也不能开启过多的子线程。最好只有一个下载图片的子线程在活动。否则也会影响UITableViewCell的绘制，因而影响了UITableViewCell的滑动速度。(建议结合使用NSOpeartion和NSOperationQueue来下载图片，如果想尽可能找的下载图片，可以把[self.queuesetMaxConcurrentOperationCount:4];)<br>8、最好自己写一个cache，用来缓存UITableView中的UITableViewCell，这样在整个UITableView的生命周期里，一个cell只需绘制一次，并且如果发生内存不足，也可以有效的释放掉缓存的cell。<br>9、不要将tableview的背景颜色设置成一个图片。这回严重影响UITableView的滑动速度。在限时免费搜索里，我曾经翻过一个错误：self.tableView_.backgroundColor = [UIColorcolorWithPatternImage:[UIImageimageNamed:@”background.png”]];通过这种方式设置UITableView的背景颜色会严重影响UTIableView的滑动流畅性。修改成self.tableView_.backgroundColor = [UIColor clearColor];之后，fps从43上升到60左右。滑动比较流畅。<br>10、cell的行高不是固定值，需要计算，则要尽可能缓存行高值，避免重复计算行高。这里指的是UITableViewDelegate里的行高函数。<br>八、怎么解决缓存池满的问题（cell）<br>ios中不存在缓存池满的情况，因为通常我们ios中开发，对象都是在需要的时候才会创建，有种常用的说话叫做懒加载，还有在UITableView中一般只会创建刚开始出现在屏幕中的cell，之后都是从缓存池里取，不会在创建新对象。缓存池里最多也就一两个对象，缓存池满的这种情况一般在开发java中比较常见，java中一般把最近最少使用的对象先释放。<br>//清楚cell的缓存NSArray </em>subviews = [[NSArray alloc] initWithArray:cell.contentView.subviews];for (UIView *subview in subviews) {[subview removeFromSuperview];</p><p>九、TableView是怎么优化的？tableView下拉加载数据的时候为什么会出现卡顿，如何解决？</p><p>  (1)使用不透明视图<br>（2）不要重复创建不必要的table cell。<br>（3）减少视图的数目。<br>（4）不要做多余的绘制工作。<br>（5）预渲染图像。<br>（6）不要阻塞主线程。</p><p>十、正常使用应用时，按HOME键退出。稍后再次打开，界面出现卡顿现象，尝试分析一下可能原因。</p><p>这是由iOS系统管理决定的，但APP退出在后台后，只有10秒的持续运行时间，然后暂停。但该APP还在内存中，当出现内存警告，也就是别的APP要运行，而此时内存又不足的情况下，系统会回收停在后台APP所占用的内存。如果出现这种情况，那么你再次打开你的APP，就会重新启动。不知道你是为什么要让APP在后台还要继续运行，如果非得这样，那可以使用多线程技术中的gcd，可以让APP退出后继续运行很长一段时间（大概10分钟）iOS APP类型：1.保存现场。按下Home键10秒内直接杀死进程，并释放内存。<br>iOS支持的“多任务”。按下Home键转入多任务状态，保留在内存中，但只能系统允许的动作：比如GPS，比如VoIP，比如音乐等等。3.真正的桌面级别的多任务。只有Safari/Mail是，苹果嫡系大都都不是。这个级别的app在后台没有任何限制动作。无限制动作的程序，一会在用户无察觉的情况下耗光电力，二会有安全上面的问题(那些在后台依旧默默发送你的个人消息程序)顺便提一句，后两种占用内存的app，也会在任意时间从内存中被砍掉，取决于你是否动用了其它app而导致内存不足。真正不会被砍掉的后台，只有苹果那个通知系统。</p><p>.什么时候会用到懒加载？如果需要展示大量图片的时候还要一个个去加载么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">懒加载，又称为延迟加载。说的通俗一点，就是在开发中，程序启动的时候不加载资源，只有在运行当需要一些资源时，再去加载这些资源。我们知道iOS设备的内存有限，如果在程序在启动后就一次性加载将来会用到的所有资源，那么就有可能会耗尽iOS设备的内存。这些资源例如大量数据，图片，音频等等</span><br></pre></td></tr></table></figure></p><p>工程中的图片存在哪里，如何保证刷新后内存不断增加问题，以及节约用户流量？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工程中使用的图片可以自己创建个文件夹进行存放你需要用的图片,也可以在你工程中的Images.xcassets文件中存放你的图片.解决刷新内存不断增加的问题,需要把你创建的控件布局写成对应类的属性,在ViewDidLoad中初始化一次.不要在其他的类方法里创建控件.刷新节约用户流量的方法就是在一定时间段中判断当前的请求时间和上次刷新的时间并限定一个时间范围在某个范围内刷新不重新请求数据.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一. 如何让你的应用程序更加省电？&lt;br&gt;答：&lt;br&gt;(1). 如果程序用到定位，需要在定位完毕之后关闭定位，或者降低定位的频率，不停的定位会消耗电量。(2). 如果用到了蓝牙，需要使用蓝牙时候开启蓝牙，蓝牙用完之后关闭蓝牙，蓝牙也很耗电。&lt;br&gt;(3). 优化算法，减少循
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IOS【Runtime】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS%E3%80%90Runtime%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【Runtime】/</id>
    <published>2018-11-29T13:57:00.000Z</published>
    <updated>2018-11-29T14:32:20.171Z</updated>
    
    <content type="html"><![CDATA[<p>一、runtime简介<br>RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。<br>对于C语言，函数的调用在编译的时候会决定调用哪个函数。<br>对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。<br>事实证明：<br>在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。<br>在编译阶段，C语言调用未实现的函数就会报错。<br>二、runtime作用<br>1.发送消息<br>方法调用的本质，就是让对象发送消息。<br>objc_msgSend,只有对象才能发送消息，因此以objc开头.<br>使用消息机制前提，必须导入#import &lt;objc/message.h&gt;<br>消息机制简单使用<br>clang -rewrite-objc main.m 查看最终生成代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 创建person对象</span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">// 调用对象方法</span><br><span class="line">[p eat];</span><br><span class="line"></span><br><span class="line">// 本质：让对象发送消息</span><br><span class="line">objc_msgSend(p, @selector(eat));</span><br><span class="line"></span><br><span class="line">// 调用类方法的方式：两种</span><br><span class="line">// 第一种通过类名调用</span><br><span class="line">[Person eat];</span><br><span class="line">// 第二种通过类对象调用</span><br><span class="line">[[Person class] eat];</span><br><span class="line"></span><br><span class="line">// 用类名调用类方法，底层会自动把类名转换成类对象调用</span><br><span class="line">// 本质：让类对象发送消息</span><br><span class="line">objc_msgSend([Person class], @selector(eat));</span><br></pre></td></tr></table></figure></p><p>消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现</p><p>2.交换方法<br>开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。<br>方式一:继承系统的类，重写方法.<br>方式二:使用runtime,交换方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。</span><br><span class="line">    // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;</span><br><span class="line">    // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。</span><br><span class="line">    UIImage *image = [UIImage imageNamed:@&quot;123&quot;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation UIImage (Image)</span><br><span class="line">// 加载分类到内存的时候调用</span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    // 交换方法</span><br><span class="line"></span><br><span class="line">    // 获取imageWithName方法地址</span><br><span class="line">    Method imageWithName = class_getClassMethod(self, @selector(imageWithName:));</span><br><span class="line"></span><br><span class="line">    // 获取imageWithName方法地址</span><br><span class="line">    Method imageName = class_getClassMethod(self, @selector(imageNamed:));</span><br><span class="line"></span><br><span class="line">    // 交换方法地址，相当于交换实现方式</span><br><span class="line">    method_exchangeImplementations(imageWithName, imageName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.</span><br><span class="line"></span><br><span class="line">// 既能加载图片又能打印</span><br><span class="line">+ (instancetype)imageWithName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 这里调用imageWithName，相当于调用imageName</span><br><span class="line">    UIImage *image = [self imageWithName:name];</span><br><span class="line"></span><br><span class="line">    if (image == nil) &#123;</span><br><span class="line">        NSLog(@&quot;加载空的图片&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>交换原理：<br>交换之前： </p><p>交换之后： </p><p>3.动态添加方法<br>开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。<br>经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。<br>简单使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">    // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</span><br><span class="line">    // 动态添加方法就不会报错</span><br><span class="line">    [p performSelector:@selector(eat)];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">// void(*)()</span><br><span class="line">// 默认方法都有两个隐式参数，</span><br><span class="line">void eat(id self,SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;,self,NSStringFromSelector(sel));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span><br><span class="line">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (sel == @selector(eat)) &#123;</span><br><span class="line">        // 动态添加eat方法</span><br><span class="line"></span><br><span class="line">        // 第一个参数：给哪个类添加方法</span><br><span class="line">        // 第二个参数：添加方法的方法编号</span><br><span class="line">        // 第三个参数：添加方法的函数实现（函数地址）</span><br><span class="line">        // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span><br><span class="line">        class_addMethod(self, @selector(eat), eat, &quot;v@:&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>4.给分类添加属性<br>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line">    // 给系统NSObject类动态添加属性name</span><br><span class="line"></span><br><span class="line">    NSObject *objc = [[NSObject alloc] init];</span><br><span class="line">    objc.name = @&quot;小码哥&quot;;</span><br><span class="line">    NSLog(@&quot;%@&quot;,objc.name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义关联的key</span><br><span class="line">static const char *key = &quot;name&quot;;</span><br><span class="line"></span><br><span class="line">@implementation NSObject (Property)</span><br><span class="line"></span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    // 根据关联的key，获取关联的值。</span><br><span class="line">    return objc_getAssociatedObject(self, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    // 第一个参数：给哪个对象添加关联</span><br><span class="line">    // 第二个参数：关联的key，通过这个key获取</span><br><span class="line">    // 第三个参数：关联的value</span><br><span class="line">    // 第四个参数:关联的策略</span><br><span class="line">    objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>5.字典转模型<br>设计模型：字典转模型的第一步<br>模型属性，通常需要跟字典中的key一一对应<br>问题：一个一个的生成模型属性，很慢？<br>需求：能不能自动根据一个字典，生成对应的属性。<br>解决：提供一个分类，专门根据字典生成对应的属性字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    @implementation NSObject (Log)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 自动打印属性字符串</span><br><span class="line">+ (void)resolveDict:(NSDictionary *)dict&#123;</span><br><span class="line"></span><br><span class="line">    // 拼接属性字符串代码</span><br><span class="line">    NSMutableString *strM = [NSMutableString string];</span><br><span class="line"></span><br><span class="line">    // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line"></span><br><span class="line">        // 类型经常变，抽出来</span><br><span class="line">         NSString *type;</span><br><span class="line"></span><br><span class="line">        if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123;</span><br><span class="line">            type = @&quot;NSString&quot;;</span><br><span class="line">        &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)])&#123;</span><br><span class="line">            type = @&quot;NSArray&quot;;</span><br><span class="line">        &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)])&#123;</span><br><span class="line">            type = @&quot;int&quot;;</span><br><span class="line">        &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)])&#123;</span><br><span class="line">            type = @&quot;NSDictionary&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 属性字符串</span><br><span class="line">        NSString *str;</span><br><span class="line">        if ([type containsString:@&quot;NS&quot;]) &#123;</span><br><span class="line">            str = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) %@ *%@;&quot;,type,key];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            str = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) %@ %@;&quot;,type,key];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 每生成属性字符串，就自动换行。</span><br><span class="line">        [strM appendFormat:@&quot;\n%@\n&quot;,str];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 把拼接好的字符串打印出来，就好了。</span><br><span class="line">    NSLog(@&quot;%@&quot;,strM);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>字典转模型的方式一：KVC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation Status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (instancetype)statusWithDict:(NSDictionary *)dict</span><br><span class="line">&#123;</span><br><span class="line">    Status *status = [[self alloc] init];</span><br><span class="line"></span><br><span class="line">    [status setValuesForKeysWithDictionary:dict];</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。<br>如果不一致，就会调用[<status 0x7fa74b545d60=""> setValue:forUndefinedKey:] 报key找不到的错。<br>分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。<br>解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖， 就能继续使用KVC，字典转模型了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></status></p><p>字典转模型的方式二：Runtime<br>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。<br>步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line">    // 解析Plist文件</span><br><span class="line">    NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil];</span><br><span class="line"></span><br><span class="line">    NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath];</span><br><span class="line"></span><br><span class="line">    // 获取字典数组</span><br><span class="line">    NSArray *dictArr = statusDict[@&quot;statuses&quot;];</span><br><span class="line"></span><br><span class="line">    // 自动生成模型的属性字符串</span><br><span class="line">//    [NSObject resolveDict:dictArr[0][@&quot;user&quot;]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _statuses = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    // 遍历字典数组</span><br><span class="line">    for (NSDictionary *dict in dictArr) &#123;</span><br><span class="line"></span><br><span class="line">        Status *status = [Status modelWithDict:dict];</span><br><span class="line"></span><br><span class="line">        [_statuses addObject:status];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试数据</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;,_statuses,[_statuses[0] user]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSObject (Model)</span><br><span class="line"></span><br><span class="line">+ (instancetype)modelWithDict:(NSDictionary *)dict</span><br><span class="line">&#123;</span><br><span class="line">    // 思路：遍历模型中所有属性-》使用运行时</span><br><span class="line"></span><br><span class="line">    // 0.创建对应的对象</span><br><span class="line">    id objc = [[self alloc] init];</span><br><span class="line"></span><br><span class="line">    // 1.利用runtime给对象中的成员属性赋值</span><br><span class="line"></span><br><span class="line">    // class_copyIvarList:获取类中的所有成员属性</span><br><span class="line">    // Ivar：成员属性的意思</span><br><span class="line">    // 第一个参数：表示获取哪个类中的成员属性</span><br><span class="line">    // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值</span><br><span class="line">    // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</span><br><span class="line">    /* 类似下面这种写法</span><br><span class="line"></span><br><span class="line">     Ivar ivar;</span><br><span class="line">     Ivar ivar1;</span><br><span class="line">     Ivar ivar2;</span><br><span class="line">     // 定义一个ivar的数组a</span><br><span class="line">     Ivar a[] = &#123;ivar,ivar1,ivar2&#125;;</span><br><span class="line"></span><br><span class="line">     // 用一个Ivar *指针指向数组第一个元素</span><br><span class="line">     Ivar *ivarList = a;</span><br><span class="line"></span><br><span class="line">     // 根据指针访问数组第一个元素</span><br><span class="line">     ivarList[0];</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line">    unsigned int count;</span><br><span class="line"></span><br><span class="line">    // 获取类中的所有成员属性</span><br><span class="line">    Ivar *ivarList = class_copyIvarList(self, &amp;count);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        // 根据角标，从数组取出对应的成员属性</span><br><span class="line">        Ivar ivar = ivarList[i];</span><br><span class="line"></span><br><span class="line">        // 获取成员属性名</span><br><span class="line">        NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line"></span><br><span class="line">        // 处理成员属性名-&gt;字典中的key</span><br><span class="line">        // 从第一个角标开始截取</span><br><span class="line">        NSString *key = [name substringFromIndex:1];</span><br><span class="line"></span><br><span class="line">        // 根据成员属性名去字典中查找对应的value</span><br><span class="line">        id value = dict[key];</span><br><span class="line"></span><br><span class="line">        // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</span><br><span class="line">        // 判断下value是否是字典</span><br><span class="line">        if ([value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">            // 字典转模型</span><br><span class="line">            // 获取模型的类对象，调用modelWithDict</span><br><span class="line">            // 模型的类名已知，就是成员属性的类型</span><br><span class="line"></span><br><span class="line">            // 获取成员属性类型</span><br><span class="line">           NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</span><br><span class="line">          // 生成的是这种@&quot;@\&quot;User\&quot;&quot; 类型 -》 @&quot;User&quot;  在OC字符串中 \&quot; -&gt; &quot;，\是转义的意思，不占用字符</span><br><span class="line">            // 裁剪类型字符串</span><br><span class="line">            NSRange range = [type rangeOfString:@&quot;\&quot;&quot;];</span><br><span class="line"></span><br><span class="line">           type = [type substringFromIndex:range.location + range.length];</span><br><span class="line"></span><br><span class="line">            range = [type rangeOfString:@&quot;\&quot;&quot;];</span><br><span class="line"></span><br><span class="line">            // 裁剪到哪个角标，不包括当前角标</span><br><span class="line">          type = [type substringToIndex:range.location];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 根据字符串类名生成类对象</span><br><span class="line">            Class modelClass = NSClassFromString(type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (modelClass) &#123; // 有对应的模型才需要转</span><br><span class="line"></span><br><span class="line">                // 把字典转模型</span><br><span class="line">                value  =  [modelClass modelWithDict:value];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</span><br><span class="line">        // 判断值是否是数组</span><br><span class="line">        if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            // 判断对应类有没有实现字典数组转模型数组的协议</span><br><span class="line">            if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;</span><br><span class="line"></span><br><span class="line">                // 转换成id类型，就能调用任何对象的方法</span><br><span class="line">                id idSelf = self;</span><br><span class="line"></span><br><span class="line">                // 获取数组中字典对应的模型</span><br><span class="line">                NSString *type =  [idSelf arrayContainModelClass][key];</span><br><span class="line"></span><br><span class="line">                // 生成模型</span><br><span class="line">               Class classModel = NSClassFromString(type);</span><br><span class="line">                NSMutableArray *arrM = [NSMutableArray array];</span><br><span class="line">                // 遍历字典数组，生成模型数组</span><br><span class="line">                for (NSDictionary *dict in value) &#123;</span><br><span class="line">                    // 字典转模型</span><br><span class="line">                  id model =  [classModel modelWithDict:dict];</span><br><span class="line">                    [arrM addObject:model];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 把模型数组赋值给value</span><br><span class="line">                value = arrM;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (value) &#123; // 有值，才需要给模型的属性赋值</span><br><span class="line">            // 利用KVC给模型中的属性赋值</span><br><span class="line">            [objc setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return objc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、runtime简介&lt;br&gt;RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。&lt;br&gt;对于C语言，函数的调用在编译的时候会决定调用哪个函数。&lt;br&gt;对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只
      
    
    </summary>
    
      <category term="iOS" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/categories/iOS/"/>
    
    
      <category term="iOS" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>IOS【使用tableView制作轮播图】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS%E3%80%90%E4%BD%BF%E7%94%A8tableView%E5%88%B6%E4%BD%9C%E8%BD%AE%E6%92%AD%E5%9B%BE%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【使用tableView制作轮播图】/</id>
    <published>2018-11-29T13:55:08.000Z</published>
    <updated>2018-11-29T13:55:08.709Z</updated>
    
    <content type="html"><![CDATA[<p>转载请注明出处：<br><a href="http://www.jianshu.com/p/01d5aba5dd68" target="_blank" rel="noopener">http://www.jianshu.com/p/01d5aba5dd68</a></p><p>在实际开发中,或许也有人有我这样的疑惑，想利用tableView Cell的重用机制,去更佳优化app的内存，就会想到这方面的性能优化。<br>在网上查询了下，很少看到关于tableView轮播器的相关资料，干脆的自己写了一个希望大家喜欢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tableScrollViewPage</span><br><span class="line">Use a table view do the picture carousel device, </span><br><span class="line">the use of infinite loops and cell multiplexing </span><br><span class="line">and better performance, like please point star, thank you</span><br></pre></td></tr></table></figure></p><p>使用tableView表格视图 做的 图片轮播器 ， 使用了无限循环 和 cell复用，<br>tableView性能大家都知道，已经进行了封装，只需根据需求进行简单改动，<br>喜欢请点星，谢谢</p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-c0492d409977e9ef.gif?imageMogr2/auto-orient/strip" alt="tableScrollViewGif.gif"><br>github地址 <a href="https://github.com/ChinaArJun/TableScrollViewPage" target="_blank" rel="noopener">https://github.com/ChinaArJun/TableScrollViewPage</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载请注明出处：&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/01d5aba5dd68&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jianshu.com/p/01d5aba5dd68&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IOS【电商项目: 高仿&lt;爱鲜蜂&gt; OC版】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS%E3%80%90%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE-%E9%AB%98%E4%BB%BF-%E7%88%B1%E9%B2%9C%E8%9C%82-OC%E7%89%88%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【电商项目-高仿-爱鲜蜂-OC版】/</id>
    <published>2018-11-29T13:54:39.000Z</published>
    <updated>2018-11-29T13:54:40.505Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做抽出一点空余时间仿了一款爱鲜蜂项目 </p><p>效果图</p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-1ddca28220aa9f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-0b594aa0aaad1a9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-6d50d915f9079c12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-1759cbb0a7fcca36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p><p>github : <a href="https://github.com/ChinaArJun/loveFreshPeakApp_oc" target="_blank" rel="noopener">https://github.com/ChinaArJun/loveFreshPeakApp_oc</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在做抽出一点空余时间仿了一款爱鲜蜂项目 &lt;/p&gt;
&lt;p&gt;效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2692013-1ddca28220aa9f5d.png?imageMogr2/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IOS【webSocket- socket.io_ios使用指南】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS%E3%80%90webSocket-socket-io-ios%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【webSocket-socket-io-ios使用指南】/</id>
    <published>2018-11-29T13:54:19.000Z</published>
    <updated>2018-11-29T13:54:22.407Z</updated>
    
    <content type="html"><![CDATA[<p>要指定https在你的socketURL参数中.</p><blockquote><p>convenience init(socketURL: NSURL, options: NSDictionary?)</p></blockquote><p>同上, 但是为了ObjC准备,使用字典.</p><blockquote><p> Options</p></blockquote><p>所有关于SocketIOClientOption的设置.如果是ObjC,转换名字lowerCamelCase.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">case ConnectParams([String: AnyObject]) // 通过字典内容连接</span><br><span class="line">case Cookies([NSHTTPCookie]) // An array of NSHTTPCookies. Passed during the handshake. Default is nil.</span><br><span class="line">case DoubleEncodeUTF8(Bool) // Whether or not to double encode utf8. If using the node based server this should be true. Default is true.</span><br><span class="line">case ExtraHeaders([String: String]) // 添加自定义请求头初始化来请求, 默认为nil</span><br><span class="line">case ForcePolling(Bool) // 是否使用 xhr-polling. Default is `false`</span><br><span class="line">case ForceNew(Bool) // 将为每个连接创建一个新的connect, 如果你在重新连接时有bug时使用.</span><br><span class="line">case ForceWebsockets(Bool) // 是否使用 WebSockets. Default is `false`</span><br><span class="line">case HandleQueue(dispatch_queue_t) // 调度handle的运行队列. Default is the main queue.</span><br><span class="line">case Log(Bool) // 是否打印调试信息. Default is false.</span><br><span class="line">case Logger(SocketLogger) // 可自定义SocketLogger调试日志.默认是系统的.</span><br><span class="line">case Nsp(String) // 如果使用命名空间连接. Must begin with /. Default is `/`</span><br><span class="line">case Path(String) // 如果服务器使用一个自定义路径. 例如: `&quot;/swift/&quot;`. Default is `&quot;&quot;`</span><br><span class="line">case Reconnects(Bool) // 是否重新连接服务器失败. Default is `true`</span><br><span class="line">case ReconnectAttempts(Int) // 重新连接多少次. Default is `-1` (无限次)</span><br><span class="line">case ReconnectWait(Int) // 等待重连时间. Default is `10`</span><br><span class="line">case SessionDelegate(NSURLSessionDelegate) // NSURLSessionDelegate 底层引擎设置. 如果你需要处理自签名证书. Default is nil.</span><br><span class="line">case Secure(Bool) // 如果连接要使用TLS. Default is false.</span><br><span class="line">case SelfSigned(Bool) //  WebSocket.selfSignedSSL设置 (Don&apos;t do this, iOS will yell at you)</span><br><span class="line">case VoipEnabled(Bool) // 如果你的客户端使用VoIP服务,只有用这个选项,Default is false</span><br></pre></td></tr></table></figure></p><p>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">on(event: String, callback: NormalCallback) -&gt; NSUUID // 给一个事件添加一个句柄. Items are passed by an array. 可以发送ack请求. 例如,返回一个唯一ID.</span><br><span class="line">once(event: String, callback: NormalCallback) -&gt; NSUUID // 同上,但只执行一次.</span><br><span class="line">onAny(callback:((event: String, items: AnyObject?)) -&gt; Void) //可以给所有事件添加一个句柄. event可以接收任何事件.</span><br><span class="line">emit(event: String, _ items: AnyObject...) // 发送一个或多条消息.</span><br><span class="line">emit(event: String, withItems items: [AnyObject]) // emit for Objective-C</span><br><span class="line">emitWithAck(event: String, _ items: AnyObject...) -&gt; (timeoutAfter: UInt64, callback: (NSArray?) -&gt; Void) -&gt; Void // 给服务器发送一个ack确认请求. 返回一个函数,你可以用它添加一个句柄. 注意: 直到你调用这个返回函数,才会发送消息</span><br><span class="line">emitWithAck(event: String, withItems items: [AnyObject]) -&gt; (UInt64, (NSArray?) -&gt; Void) -&gt; Void // 同上,为Objective-C准备的 </span><br><span class="line">connect() // 建立一个连接到服务器. 连接成功会触发 &quot;connect&quot;事件</span><br><span class="line">connect(timeoutAfter timeoutAfter: Int, withTimeoutHandler handler: (() -&gt; Void)?) // 连接到服务器. 如果连接超时,会调用handle</span><br><span class="line">disconnect() // Closes the socket. 重开一个断开连接的socket还没完全测试.</span><br><span class="line">reconnect() // Causes the client to reconnect to the server.</span><br><span class="line">joinNamespace(namespace: String) - Causes the client to join namespace. 不应该被调用,除非你手动改变命名空间.</span><br><span class="line">leaveNamespace() // Causes the client to leave the nsp and go back to &apos;/&apos;</span><br><span class="line">off(event: String) - Removes all event handlers for event.</span><br><span class="line">off(id id: NSUUID) - Removes the event that corresponds to id.</span><br><span class="line">removeAllHandlers() - Removes all handlers.</span><br></pre></td></tr></table></figure></p><p>客户端的事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connect – 当成功连接时Emitted</span><br><span class="line">disconnect – 当连接断开Emitted</span><br><span class="line">error – 发送错误时Emitted</span><br><span class="line">reconnect – 当开始重连时Emitted</span><br><span class="line">reconnectAttempt – 当尝试重连时Emitted</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要指定https在你的socketURL参数中.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;convenience init(socketURL: NSURL, options: NSDictionary?)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同上, 但是为了ObjC
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IOS【开发经验之谈—正则表达式实现图文混排】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS%E3%80%90%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【开发经验之谈—正则表达式实现图文混排】/</id>
    <published>2018-11-29T13:53:44.000Z</published>
    <updated>2018-11-29T13:53:47.025Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中，我们经常需要发表情，以及经常需要将表情字符转换成表情。因为表情是一个图片，所以我们发给服务器的时候，实际上是发一段特殊的文字给服务器，然后转换成表情。以免浪费用户过多的流量。<br>那接下来，我们就来介绍一下，如何使用正则表达式实现图文混排呢？<br>为了以后的代码的管理方便，我们抽取出两个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> NSString+Regular.h中，我们暴露两个方法出来：</span><br><span class="line"> /**</span><br><span class="line"> *  返回正则表达式匹配的第一个结果</span><br><span class="line"> *</span><br><span class="line"> *  @param pattern 正则表达式</span><br><span class="line"> *</span><br><span class="line"> *  @return 匹配的第一个结果 是NSTextCheckingResult类型</span><br><span class="line"> */</span><br><span class="line">-(NSTextCheckingResult *)firstMacthWithPattern:(NSString *)pattern;</span><br><span class="line"></span><br><span class="line">-(NSArray &lt;NSTextCheckingResult *&gt; *)machesWithPattern:(NSString *)pattern;</span><br></pre></td></tr></table></figure></p><p>NSString+Regular.m中，我们实现一下这两个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (NSTextCheckingResult *)firstMacthWithPattern:(NSString *)pattern</span><br><span class="line">&#123;</span><br><span class="line">    //正则表达式的创建很容易失败，注意捕获错误</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    //根据正则表达式创建实例</span><br><span class="line">    NSRegularExpression *regular = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:&amp;error];</span><br><span class="line">    if ( error)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;正则表达式创建失败&quot;);</span><br><span class="line"></span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //匹配出结果</span><br><span class="line">  NSTextCheckingResult *result =   [regular firstMatchInString:self options:0 range:NSMakeRange(0, self.length)];</span><br><span class="line"></span><br><span class="line">    if ( result)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;匹配&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;不匹配&quot;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray &lt;NSTextCheckingResult *&gt; *)machesWithPattern:(NSString *)pattern</span><br><span class="line">&#123;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:&amp;error];</span><br><span class="line">    if (error)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;正则表达式创建失败&quot;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return [expression matchesInString:self options:0 range:NSMakeRange(0, self.length)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进而对NSTextAttachment写一个子类 ZYTextAttachment.h 中 我们暴露一个方法出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface ZYTextAttachment : NSTextAttachment</span><br><span class="line">- (instancetype)initWithImage:(UIImage *)image;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>ZYTextAttachment.m中，我们实现一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZYTextAttachment.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZYTextAttachment</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithImage:(UIImage *)image</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init])</span><br><span class="line">    &#123;</span><br><span class="line">        self.image = image;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGRect)attachmentBoundsForTextContainer:(NSTextContainer *)textContainer proposedLineFragment:(CGRect)lineFrag glyphPosition:(CGPoint)position characterIndex:(NSUInteger)charIndex</span><br><span class="line">&#123;</span><br><span class="line">    return CGRectMake(0, -lineFrag.size.height * 0.2, lineFrag.size.height, lineFrag.size.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就能解决图片大写跟文字大小不一致的情况。</p><p>接下来，我们在viewController中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    self.label.text = @&quot;二货[smiley_2], 你在干嘛呢[smiley_6] 一起吃饭？[smiley_44]!&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在下面的方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    NSString *content = self.label.text;</span><br><span class="line">    //匹配表情文字</span><br><span class="line">    NSString *pattern = @&quot;\\[\\w+\\]&quot;;</span><br><span class="line"></span><br><span class="line">  NSArray *resultArr =   [content machesWithPattern:pattern];</span><br><span class="line">    if (!resultArr) return;</span><br><span class="line"></span><br><span class="line">    NSMutableAttributedString *attrContent = [[NSMutableAttributedString alloc]initWithString:content];</span><br><span class="line">    NSUInteger lengthDetail = 0;</span><br><span class="line">    //遍历所有的result 取出range</span><br><span class="line">    for (NSTextCheckingResult *result in resultArr) &#123;</span><br><span class="line">        //取出图片名</span><br><span class="line">      NSString *imageName =   [content substringWithRange:NSMakeRange(result.range.location + 1, result.range.length - 2)];</span><br><span class="line">        // 创建AttributeString, 来包装图片</span><br><span class="line">      ZYTextAttachment *attachment =   [[ZYTextAttachment alloc]initWithImage:[UIImage imageNamed:imageName]];</span><br><span class="line">        // 将附近包装到NSAttributedString中</span><br><span class="line">      NSAttributedString *imageString =   [NSAttributedString attributedStringWithAttachment:attachment];</span><br><span class="line">        //图片附件的文本长度是1</span><br><span class="line">        NSLog(@&quot;%zd&quot;,imageString.length);</span><br><span class="line"></span><br><span class="line">        NSUInteger length = attrContent.length;</span><br><span class="line">        NSRange newRange = NSMakeRange(result.range.location - lengthDetail, result.range.length);</span><br><span class="line">        [attrContent replaceCharactersInRange:newRange withAttributedString:imageString];</span><br><span class="line"></span><br><span class="line">        lengthDetail += length - attrContent.length;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //更新到label上</span><br><span class="line">    self.label.attributedText = attrContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看一下效果：<br> <img src="http://upload-images.jianshu.io/upload_images/2692013-2bedf01d7be485cb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正则"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-6c4715f65891302e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正则表情"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中，我们经常需要发表情，以及经常需要将表情字符转换成表情。因为表情是一个图片，所以我们发给服务器的时候，实际上是发一段特殊的文字给服务器，然后转换成表情。以免浪费用户过多的流量。&lt;br&gt;那接下来，我们就来介绍一下，如何使用正则表达式实现图文混排呢？&lt;br&gt;为了以后的代
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IOS【tabBar框架之 tabbar动画 TabBarsAnimationDemo】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS%E3%80%90tabBar%E6%A1%86%E6%9E%B6%E4%B9%8B-tabbar%E5%8A%A8%E7%94%BB-TabBarsAnimationDemo%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【tabBar框架之-tabbar动画-TabBarsAnimationDemo】/</id>
    <published>2018-11-29T13:53:19.000Z</published>
    <updated>2018-11-29T13:53:23.500Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS原生的tabBar中，能够实现按钮的点击事件，能够实现视图控制器的切换等，但是在实际工程中，对于tabBar的要求的功能往往是系统自己实现不了的，所以我们这里就需要用到自定义的tabBar了。<br>对于tabBar上展示视图控制器，我们会采用的是在把几个视图控制直接加载到tabBarController上去。这里新建三个视图控制器，由于在<br>一、系统样式<br>ViewController会有其他代码，所以我们这里另一写一个类，在这里只设置一个背景颜色就可以了。所以我们先新建一个类叫做ViewController，让它继承自UIViewController。这里设置视图的背景颜色，这里可以设置为随机色。</p><p>TabBarsAnimationDemo — 底部菜单push隐藏菜单栏动画（仿IOS京东效果）</p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-4d92e4a6e2bbb922.gif?imageMogr2/auto-orient/strip" alt="B843B34D-9398-4A2E-B1C8-313D5EE8F6D5.gif"></p><p>git - <a href="https://github.com/ChinaArJun/TabBarsAnimationDemo" target="_blank" rel="noopener">https://github.com/ChinaArJun/TabBarsAnimationDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在iOS原生的tabBar中，能够实现按钮的点击事件，能够实现视图控制器的切换等，但是在实际工程中，对于tabBar的要求的功能往往是系统自己实现不了的，所以我们这里就需要用到自定义的tabBar了。&lt;br&gt;对于tabBar上展示视图控制器，我们会采用的是在把几个视图控制直
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IOS【视频直播:高仿腾讯旗下&lt;NOW直播&gt;映客直播类型】</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS%E3%80%90%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD-%E9%AB%98%E4%BB%BF%E8%85%BE%E8%AE%AF%E6%97%97%E4%B8%8B-NOW%E7%9B%B4%E6%92%AD-%E6%98%A0%E5%AE%A2%E7%9B%B4%E6%92%AD%E7%B1%BB%E5%9E%8B%E3%80%91/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/11/29/IOS【视频直播-高仿腾讯旗下-NOW直播-映客直播类型】/</id>
    <published>2018-11-29T13:52:53.000Z</published>
    <updated>2018-11-29T13:52:55.015Z</updated>
    
    <content type="html"><![CDATA[<p>效果图如下</p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-816da1bb2715290b.gif?imageMogr2/auto-orient/strip" alt="NowGif.gif"></p><p><img src="http://upload-images.jianshu.io/upload_images/2692013-9d2bcdf7a4c44812.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4349FA93-F15B-4287-9162-3AA27B223A72.png"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-11f7a449788fa21f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FA783124-4B81-455F-A6E6-461ACA874478.png"></p><p>处理了对IPad版本的适配<br><img src="http://upload-images.jianshu.io/upload_images/2692013-f02786c10a04c44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img_0257.png"><br><img src="http://upload-images.jianshu.io/upload_images/2692013-b491b9b91e448cd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img_0258.png"></p><h1 id="随着直播市场的火热，市场大军都逐步进入直播市场-，腾讯旗下的NOW直播也不例外"><a href="#随着直播市场的火热，市场大军都逐步进入直播市场-，腾讯旗下的NOW直播也不例外" class="headerlink" title="随着直播市场的火热，市场大军都逐步进入直播市场 ，腾讯旗下的NOW直播也不例外"></a>随着直播市场的火热，市场大军都逐步进入直播市场 ，腾讯旗下的NOW直播也不例外</h1><p>先说说直播设计底层</p><h4 id="一-、流媒体"><a href="#一-、流媒体" class="headerlink" title="一 、流媒体"></a>一 、流媒体</h4><h6 id="1-伪流媒体"><a href="#1-伪流媒体" class="headerlink" title="1 - 伪流媒体"></a>1 - 伪流媒体</h6><p>  1.1 扫盲:边下载边播放<br>  1.2 伪流媒体:视频不是实时播放的,先把视频放在数据库,再供客户端访问,比如:优酷,爱奇艺等</p><p>  1.3 特点:</p><blockquote><p>边下边存,文件会保存.<br>遵守了 HTTP 协议,但是没有遵守 RTMP 和 HLS 协议<br>能够实现快进和快退的功能<br>实现简单,成本低</p></blockquote><p>######2 实时流媒体</p><p>  2.1 真正的流媒体,边下边播,但不会保存下载的文件</p><p>  2.2 特点:</p><blockquote><p>下载的文件不会保存<br>遵守了 RTMP 或者 HLS 协议<br>只能实现实时播放,不能快进或者快退<br>实现成本比较高,实现复杂</p></blockquote><h6 id="3-常见的流媒体协议-HLS-苹果基于-HTTP-开发的流媒体协议-RTMP-Adobe-的私有协议-MMS-微软"><a href="#3-常见的流媒体协议-HLS-苹果基于-HTTP-开发的流媒体协议-RTMP-Adobe-的私有协议-MMS-微软" class="headerlink" title="3 常见的流媒体协议: HLS(苹果基于 HTTP 开发的流媒体协议),RTMP(Adobe 的私有协议),MMS (微软)."></a>3 常见的流媒体协议: HLS(苹果基于 HTTP 开发的流媒体协议),RTMP(Adobe 的私有协议),MMS (微软).</h6><blockquote><p>HLS协议<br>  1 HLS: HTTP Live Streaming 是苹果公司实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在iOS系统，为iOS设备提供音视频直播和点播方案.</p></blockquote><blockquote><p>  2 直播原理:通过相关设备采集摄像头的视频和麦克风的音频,并实时进行 H264视频编码和 AAC 音频音频编码,并按照 HLS协议规范,转换为标准的 TS文件以及m3u8(是一个地址,里面记录了服务器多对应的文件)索引文件.</p></blockquote><blockquote><p>  3 HLS 点播:就是对 HTTP 进行分段播放,不同的就是在于对 HTTP 进行的分段非常小,因此可以说, HLS 点播的重点就是对 HTTP 进行分段.(现在的分段技术比较常见不在赘述)</p></blockquote><blockquote><p>  4 HLS 直播原理:和其他的常见的直播协议(如: RTMP,RTSP,MMS)不同, 遵守HLS 协议的直播在客户端接收到的并不是完整的数据流. 即HLS 协议的服务器将最新获取到的片段进行分割为小片段,客户端获取服务器刚编好的最新的片段进行播放.这样服务器端不断的获取新的数据进行分割成新的片段,客户端不断的从服务器端获取最近的片段进行播放.由此可以说 HLS 是以点播的形式实现的直播.</p></blockquote><blockquote><p>  5 HLS 的特点：由于数据是通过 HTTP 传输的,所以不用考虑防火墙和代理的问题，由于分割的时长很短,所以客户端可以很快的实现码率切换,以适应不同的带宽.HLS 协议的延迟一般会高于其他协议的流媒体直播.<br>  6 HLS 实现步骤采取视频源和音频源数据对原始数据尽心 H264和 ACC 编码视频和音频数据封装为 MPEG-TS 包 HLS 分段生成策略以及 m3u8索引文件  HTTP 传输协议<br>注:需要说明的是 HLS 分段策略的分段时长以10S 为最好.</p></blockquote><h4 id="二-、RTMP-协议"><a href="#二-、RTMP-协议" class="headerlink" title="二 、RTMP 协议"></a>二 、RTMP 协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1 RTMP 实时消息传输协议,是现在比较常用的协议</span><br><span class="line">2 RTMP使用原理:首先推流到 RTMP 服务器,然后再有 RTMP 服务器提供 RTMP 视频服务.</span><br><span class="line">注:需啊说明的是:RTMP 也提供 HLS, 将音视频切位 ts 流,然后用户可以直接播放 m3u8流媒体.</span><br><span class="line"></span><br><span class="line">3 RTMP协议规定</span><br><span class="line">3.1 建立一个网络连接</span><br><span class="line">3.2 建立一个网络流(发送多媒体的通道)</span><br><span class="line">注:只能建立一个网络连接,但是可以建立多个网络流</span><br><span class="line"></span><br><span class="line">4 RTMP 协议使用步骤</span><br><span class="line">4.1 握手:RTMP 协议都是以握手开始的</span><br><span class="line"></span><br><span class="line">客户端先发送 C0,C1两个数据块,服务器收到 C1或者 C2块的时候开始发送 S0和 S1</span><br><span class="line">客户端收齐 S0和 S1的时候开始发送 C2,当服务器收齐 C0和 C1的时候开始发送 S2</span><br><span class="line">当客户端收到 S2同时服务器收到 C2 的时候,握手完成</span><br><span class="line">4.2 建立连接:建立客户端和服务器端的网络连接</span><br><span class="line"></span><br><span class="line">&gt; 客户端发送命令消息中的”connect”,到服务器,请求与一个服务器应用实例建立连接</span><br><span class="line">&gt; 服务器接收到请求后,发送确认消息,同时连接到请求中的连接实例</span><br><span class="line">&gt; 服务器发送设置带宽协议消息到客户端</span><br><span class="line">&gt; 客户端接收到 设置带宽 消息之后,发送确认消息到服务器</span><br><span class="line">&gt; 服务器发送用户控制消息中的”stream”消息到客户端</span><br><span class="line">&gt; 服务器发送消息命令中的”结果”消息到客户端</span><br><span class="line"></span><br><span class="line">4.3 建立流:建立客户端和服务器端的”流连接”</span><br><span class="line"></span><br><span class="line">&gt; 客户端发送消息命令中的”创建流”到服务器</span><br><span class="line">&gt; 服务器接收到”创建流”命令后,发送”结果”命令到客户端</span><br><span class="line"></span><br><span class="line">4.4 播放传输音视频数据</span><br><span class="line"></span><br><span class="line">&gt; 客户端发送”播放”命令到服务器</span><br><span class="line">&gt; 服务器收到消息后,发送 设置消息大小协议消息</span><br><span class="line">&gt; 服务器发送” streambegin”,告知客户端流 ID</span><br><span class="line">&gt; 若播放成功的话,服务器发送”响应状态”到客户端.告知客户端播放成功</span><br><span class="line">&gt; 服务器发送客户端要播放是数据</span><br></pre></td></tr></table></figure><p>流媒体的播放</p><blockquote><p>1 HLS 的流媒体通过AVPlayer/AVPlayerViewController 和 MPMviePlayerController/MPMoviePlayerViewController 来实现.<br>2 RTMP 的流媒体要用第三方框架实现 如 FFMpeg ,IJKPlayer和 VLC 等<br>3 常用的流媒体框架:百度/阿里/腾讯/网易/斗鱼直播伴侣/七牛云等</p></blockquote><p>-项目主要是基于<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">ijkplayer </a>的. 最好是打包成framework<br>. 我也准备好了一份打包好的分享给大家<br>-百度云盘链接:<a href="https://pan.baidu.com/s/1smNcwsX" target="_blank" rel="noopener">https://pan.baidu.com/s/1smNcwsX</a>  密码:xpsq</p><p>打开项目记得用真机测试哦，不然模拟器会有音频跟不上失真的现象哦<br>github  -&gt; <a href="https://github.com/ChinaArJun/Tencent-NOW" target="_blank" rel="noopener">https://github.com/ChinaArJun/Tencent-NOW</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;效果图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2692013-816da1bb2715290b.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;NowG
      
    
    </summary>
    
    
  </entry>
  
</feed>
