<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿俊的博客</title>
  
  <subtitle>每天成长一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/"/>
  <updated>2018-12-03T03:20:56.866Z</updated>
  <id>github.com:ChinaArJun/ChinaArJun.github.io.git/</id>
  
  <author>
    <name>iOS阿俊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础巩固之注解(8)</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/12/03/java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA%E4%B9%8B%E6%B3%A8%E8%A7%A3-8/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/12/03/java基础巩固之注解-8/</id>
    <published>2018-12-03T03:20:36.000Z</published>
    <updated>2018-12-03T03:20:56.866Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java基础巩固之注解(7)</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2018/12/03/java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA%E4%B9%8B%E6%B3%A8%E8%A7%A3-7/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2018/12/03/java基础巩固之注解-7/</id>
    <published>2018-12-03T03:20:08.000Z</published>
    <updated>2018-12-03T03:20:08.540Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java 历史版本新特性</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/28/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/28/Java基础巩固之设计模式-4/</id>
    <published>2014-12-27T16:19:00.000Z</published>
    <updated>2018-12-02T17:30:52.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JDK5新特性-自己实现枚举类"><a href="#JDK5新特性-自己实现枚举类" class="headerlink" title="JDK5新特性-自己实现枚举类"></a>JDK5新特性-自己实现枚举类</h3><ul><li>A:枚举概述<ul><li>是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内。举例：一周只有7天，一年只有12个月等。</li></ul></li><li>B:回想单例设计模式：单例类是一个类只有一个实例<ul><li>那么多例类就是一个类有多个实例，但不是无限个数的实例，而是有限个数的实例。这才能是枚举类。</li></ul></li></ul><a id="more"></a><ul><li>C:案例演示<ul><li>自己实现枚举类<br>1,自动拆装箱<br>2,泛型<br>3,可变参数<br>4,静态导入<br>5,增强for循环<br>6,互斥锁<br>7,枚举</li></ul></li></ul><h3 id="JDK5新特性-通过enum实现枚举类"><a href="#JDK5新特性-通过enum实现枚举类" class="headerlink" title="JDK5新特性-通过enum实现枚举类"></a>JDK5新特性-通过enum实现枚举类</h3><ul><li>A:案例演示<ul><li>通过enum实现枚举类</li></ul></li></ul><h3 id="JDK5新特性-枚举的注意事项"><a href="#JDK5新特性-枚举的注意事项" class="headerlink" title="JDK5新特性-枚举的注意事项"></a>JDK5新特性-枚举的注意事项</h3><ul><li>A:案例演示<ul><li>定义枚举类要用关键字enum</li><li>所有枚举类都是Enum的子类</li><li>枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略</li><li>枚举类可以有构造器，但必须是private的，它默认的也是private的。</li><li>枚举类也可以有抽象方法，但是枚举项必须重写该方法</li><li>枚举在switch语句中的使用</li></ul></li></ul><h3 id="JDK5新特性-枚举类的常见方法"><a href="#JDK5新特性-枚举类的常见方法" class="headerlink" title="JDK5新特性-枚举类的常见方法"></a>JDK5新特性-枚举类的常见方法</h3><ul><li>A:枚举类的常见方法<ul><li>int ordinal()</li><li>int compareTo(E o)</li><li>String name()</li><li>String toString()</li><li><t> T valueOf(Class<t> type,String name)</t></t></li><li>values() </li><li>此方法虽然在JDK文档中查找不到，但每个枚举类都具有该方法，它遍历枚举类的所有枚举值非常方便</li></ul></li><li>B:案例演示<ul><li>枚举类的常见方法</li></ul></li></ul><h3 id="JDK7新特性-JDK7的六个新特性回顾和讲解"><a href="#JDK7新特性-JDK7的六个新特性回顾和讲解" class="headerlink" title="JDK7新特性-JDK7的六个新特性回顾和讲解"></a>JDK7新特性-JDK7的六个新特性回顾和讲解</h3><ul><li>A:二进制字面量</li><li>B:数字字面量可以出现下划线</li><li>C:switch 语句可以用字符串</li><li>D:泛型简化,菱形泛型</li><li>E:异常的多个catch合并,每个异常用或|</li><li>F:try-with-resources 语句</li></ul><h3 id="JDK8新特性-JDK8的新特性"><a href="#JDK8新特性-JDK8的新特性" class="headerlink" title="JDK8新特性-JDK8的新特性"></a>JDK8新特性-JDK8的新特性</h3><ul><li>接口中可以定义有方法体的方法,如果是非静态,必须用default修饰    </li><li>如果是静态的就不用了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">i.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么?</li><li>因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JDK5新特性-自己实现枚举类&quot;&gt;&lt;a href=&quot;#JDK5新特性-自己实现枚举类&quot; class=&quot;headerlink&quot; title=&quot;JDK5新特性-自己实现枚举类&quot;&gt;&lt;/a&gt;JDK5新特性-自己实现枚举类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:枚举概述&lt;ul&gt;
&lt;li&gt;是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内。举例：一周只有7天，一年只有12个月等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:回想单例设计模式：单例类是一个类只有一个实例&lt;ul&gt;
&lt;li&gt;那么多例类就是一个类有多个实例，但不是无限个数的实例，而是有限个数的实例。这才能是枚举类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程语言" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JDK" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>java基础巩固之多线程线程通信(6)</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/07/java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-6/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/07/java基础巩固之多线程并发编程-6/</id>
    <published>2014-12-06T16:58:00.000Z</published>
    <updated>2018-12-02T17:28:51.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程-单例"><a href="#多线程-单例" class="headerlink" title="多线程-单例"></a>多线程-单例</h3><ul><li><p>单例设计模式：保证类在内存中只有一个对象。</p></li><li><p>如何保证类在内存中只有一个对象呢？</p><ul><li>(1)控制类的创建，不让其他类来创建本类的对象。private</li><li>(2)在本类中定义一个本类的对象。Singleton s;</li><li>(3)提供公共的访问方式。  public static Singleton getInstance(){return s}<a id="more"></a></li></ul></li><li>单例写法两种：<ul><li>(1)饿汉式 开发用这种方式。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">//1,私有构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//2,创建本类对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="comment">//3,对外提供公共的访问方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"11111111111"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(2)懒汉式 面试写这种方式。多线程的问题？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式,单例的延迟加载模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">//1,私有构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//2,声明一个本类的引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line"><span class="comment">//3,对外提供公共的访问方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">//线程1,线程2</span></span><br><span class="line">s = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"11111111111"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(3)第三种格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton s = <span class="keyword">new</span> Singleton();<span class="comment">//final是最终的意思,被final修饰的变量不可以被更改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程-Runtime类"><a href="#多线程-Runtime类" class="headerlink" title="多线程-Runtime类"></a>多线程-Runtime类</h3><ul><li>Runtime类是一个单例类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runtime r = Runtime.getRuntime();</span><br><span class="line"><span class="comment">//r.exec("shutdown -s -t 300");//300秒后关机</span></span><br><span class="line">r.exec(<span class="string">"shutdown -a"</span>);<span class="comment">//取消关机</span></span><br></pre></td></tr></table></figure><h3 id="多线程-Timer"><a href="#多线程-Timer" class="headerlink" title="多线程-Timer"></a>多线程-Timer</h3><ul><li>Timer类:计时器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5_Timer</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * 计时器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Timer t = <span class="keyword">new</span> Timer();</span><br><span class="line">t.schedule(<span class="keyword">new</span> MyTimerTask(), <span class="keyword">new</span> Date(<span class="number">114</span>,<span class="number">9</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">54</span>,<span class="number">20</span>),<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"起床背英语单词"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程-两个线程间的通信"><a href="#多线程-两个线程间的通信" class="headerlink" title="多线程-两个线程间的通信"></a>多线程-两个线程间的通信</h3><ul><li>1.什么时候需要通信<ul><li>多个线程并发执行时, 在默认情况下CPU是随机切换线程的</li><li>如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印</li></ul></li><li>2.怎么通信<ul><li>如果希望线程等待, 就调用wait()</li><li>如果希望唤醒等待的线程, 就调用notify();</li><li>这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用</li></ul></li></ul><h3 id="多线程-三个或三个以上间的线程通信"><a href="#多线程-三个或三个以上间的线程通信" class="headerlink" title="多线程-三个或三个以上间的线程通信"></a>多线程-三个或三个以上间的线程通信</h3><ul><li>多个线程通信的问题<ul><li>notify()方法是随机唤醒一个线程</li><li>notifyAll()方法是唤醒所有线程</li><li>JDK5之前无法唤醒指定的一个线程</li><li>如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件<h3 id="多线程-JDK1-5的新特性互斥锁"><a href="#多线程-JDK1-5的新特性互斥锁" class="headerlink" title="多线程-JDK1.5的新特性互斥锁"></a>多线程-JDK1.5的新特性互斥锁</h3></li></ul></li><li>1.同步<ul><li>使用ReentrantLock类的lock()和unlock()方法进行同步</li></ul></li><li>2.通信<ul><li>使用ReentrantLock类的newCondition()方法可以获取Condition对象</li><li>需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法</li><li>不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了</li></ul></li></ul><h3 id="多线程-线程组的概述和使用"><a href="#多线程-线程组的概述和使用" class="headerlink" title="多线程-线程组的概述和使用"></a>多线程-线程组的概述和使用</h3><ul><li>A:线程组概述<ul><li>Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。</li><li>默认情况下，所有的线程都属于主线程组。<ul><li>public final ThreadGroup getThreadGroup()//通过线程对象获取他所属于的组</li><li>public final String getName()//通过线程组对象获取他组的名字</li></ul></li><li>我们也可以给线程设置分组<ul><li>1,ThreadGroup(String name) 创建线程组对象并给其赋值名字</li><li>2,创建线程对象</li><li>3,Thread(ThreadGroup?group, Runnable?target, String?name) </li><li>4,设置整组的优先级或者守护线程</li></ul></li><li>B:案例演示<ul><li>线程组的使用,默认是主线程组</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(mr, <span class="string">"张三"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(mr, <span class="string">"李四"</span>);</span><br><span class="line"><span class="comment">//获取线程组</span></span><br><span class="line"><span class="comment">// 线程类里面的方法：public final ThreadGroup getThreadGroup()</span></span><br><span class="line">ThreadGroup tg1 = t1.getThreadGroup();</span><br><span class="line">ThreadGroup tg2 = t2.getThreadGroup();</span><br><span class="line"><span class="comment">// 线程组里面的方法：public final String getName()</span></span><br><span class="line">String name1 = tg1.getName();</span><br><span class="line">String name2 = tg2.getName();</span><br><span class="line">System.out.println(name1);</span><br><span class="line">System.out.println(name2);</span><br><span class="line"><span class="comment">// 通过结果我们知道了：线程默认情况下属于main线程组</span></span><br><span class="line"><span class="comment">// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组</span></span><br><span class="line">System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line"></span><br><span class="line">* 自己设定线程组</span><br><span class="line">* </span><br><span class="line"><span class="comment">// ThreadGroup(String name)</span></span><br><span class="line">ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"这是一个新的组"</span>);</span><br><span class="line"></span><br><span class="line">MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"><span class="comment">// Thread(ThreadGroup group, Runnable target, String name)</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tg, mr, <span class="string">"张三"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(tg, mr, <span class="string">"李四"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(t1.getThreadGroup().getName());</span><br><span class="line">System.out.println(t2.getThreadGroup().getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过组名称设置后台线程，表示该组的线程都是后台线程</span></span><br><span class="line">tg.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="多线程-线程的五种状态"><a href="#多线程-线程的五种状态" class="headerlink" title="多线程-线程的五种状态"></a>多线程-线程的五种状态</h3><ul><li>看图说话</li><li>新建,就绪,运行,阻塞,死亡</li></ul><h3 id="多线程-线程池的概述和使用"><a href="#多线程-线程池的概述和使用" class="headerlink" title="多线程-线程池的概述和使用"></a>多线程-线程池的概述和使用</h3><ul><li>A:线程池概述<ul><li>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</li></ul></li><li>B:内置线程池的使用概述<ul><li>JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法<ul><li>public static ExecutorService newFixedThreadPool(int nThreads)</li><li>public static ExecutorService newSingleThreadExecutor()</li><li>这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法</li><li>Future&lt;?&gt; submit(Runnable task)</li><li><t> Future<t> submit(Callable<t> task)</t></t></t></li></ul></li><li>使用步骤：<ul><li>创建线程池对象</li><li>创建Runnable实例</li><li>提交Runnable实例</li><li>关闭线程池</li></ul></li><li>C:案例演示<ul><li>提交的是Runnable</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束线程池</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure><h3 id="多线程-多线程程序实现的方式3"><a href="#多线程-多线程程序实现的方式3" class="headerlink" title="多线程-多线程程序实现的方式3"></a>多线程-多线程程序实现的方式3</h3><ul><li>提交的是Callable</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池对象</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">Future&lt;Integer&gt; f1 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">100</span>));</span><br><span class="line">Future&lt;Integer&gt; f2 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// V get()</span></span><br><span class="line">Integer i1 = f1.get();</span><br><span class="line">Integer i2 = f2.get();</span><br><span class="line"></span><br><span class="line">System.out.println(i1);</span><br><span class="line">System.out.println(i2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= number; x++) &#123;</span><br><span class="line">sum += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>多线程程序实现的方式3的好处和弊端</p><ul><li><p>好处：</p><ul><li>可以有返回值</li><li>可以抛出异常</li></ul></li><li><p>弊端：</p><ul><li>代码比较复杂，所以一般不用</li></ul></li></ul></li></ul><p>###25.11_设计模式(简单工厂模式概述和使用)(了解)</p><ul><li>A:简单工厂模式概述<ul><li>又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例</li></ul></li><li>B:优点<ul><li>客户端不需要在负责对象的创建，从而明确了各个类的职责</li></ul></li><li>C:缺点<ul><li>这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护</li></ul></li><li>D:案例演示<ul><li>动物抽象类：public abstract Animal { public abstract void eat(); }</li><li>具体狗类：public class Dog extends Animal {}</li><li>具体猫类：public class Cat extends Animal {}</li><li>开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AnimalFactory</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public static Dog createDog() &#123;return new Dog();&#125;</span></span><br><span class="line"><span class="comment">//public static Cat createCat() &#123;return new Cat();&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">createAnimal</span><span class="params">(String animalName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(“dog”.equals(animalName)) &#123;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(“cat”.equals(animale)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;多线程-单例&quot;&gt;&lt;a href=&quot;#多线程-单例&quot; class=&quot;headerlink&quot; title=&quot;多线程-单例&quot;&gt;&lt;/a&gt;多线程-单例&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单例设计模式：保证类在内存中只有一个对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何保证类在内存中只有一个对象呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1)控制类的创建，不让其他类来创建本类的对象。private&lt;/li&gt;
&lt;li&gt;(2)在本类中定义一个本类的对象。Singleton s;&lt;/li&gt;
&lt;li&gt;(3)提供公共的访问方式。  public static Singleton getInstance(){return s}
    
    </summary>
    
      <category term="编程语言" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="多线程" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础巩固之多线程安全(5)</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/05/java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-4/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/05/java基础巩固之多线程安全-4/</id>
    <published>2014-12-04T16:44:00.000Z</published>
    <updated>2018-12-02T17:28:43.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程-同步代码块"><a href="#多线程-同步代码块" class="headerlink" title="多线程-同步代码块"></a>多线程-同步代码块</h3><ul><li>1.什么情况下需要同步<ul><li>当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.</li><li>如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.</li></ul></li><li>2.同步代码块<ul><li>使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块</li><li>多个同步代码块如果使用相同的锁对象, 那么他们就是同步的</li></ul></li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(d)&#123;</span><br><span class="line">                 <span class="comment">//锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象</span></span><br><span class="line">                 System.out.print(<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">synchronized</span>(d)&#123;</span><br><span class="line">             System.out.print(<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程-同步方法"><a href="#多线程-同步方法" class="headerlink" title="多线程-同步方法"></a>多线程-同步方法</h3><ul><li>使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Printer.class)&#123;<span class="comment">//锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象</span></span><br><span class="line">System.out.print(<span class="string">"黑"</span>);</span><br><span class="line">System.out.print(<span class="string">"马"</span>);</span><br><span class="line">System.out.print(<span class="string">"程"</span>);</span><br><span class="line">System.out.print(<span class="string">"序"</span>);</span><br><span class="line">System.out.print(<span class="string">"员"</span>);</span><br><span class="line">System.out.print(<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 非静态同步函数的锁是:this</span></span><br><span class="line"><span class="comment"> * 静态的同步函数的锁是:字节码对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"传"</span>);</span><br><span class="line">System.out.print(<span class="string">"智"</span>);</span><br><span class="line">System.out.print(<span class="string">"播"</span>);</span><br><span class="line">System.out.print(<span class="string">"客"</span>);</span><br><span class="line">System.out.print(<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程-线程安全问题"><a href="#多线程-线程安全问题" class="headerlink" title="多线程-线程安全问题"></a>多线程-线程安全问题</h3><ul><li>多线程并发操作同一数据时, 就有可能出现线程安全问题</li><li>使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_Synchronized</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * 需求:铁路售票,一共100张,通过四个窗口卖完.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">TicketsSeller t1 = <span class="keyword">new</span> TicketsSeller();</span><br><span class="line">TicketsSeller t2 = <span class="keyword">new</span> TicketsSeller();</span><br><span class="line">TicketsSeller t3 = <span class="keyword">new</span> TicketsSeller();</span><br><span class="line">TicketsSeller t4 = <span class="keyword">new</span> TicketsSeller();</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line">t4.setName(<span class="string">"窗口4"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketsSeller</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TicketsSeller</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TicketsSeller</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line"><span class="keyword">if</span>(tickets &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);<span class="comment">//线程1睡,线程2睡,线程3睡,线程4睡</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(getName() + <span class="string">"...这是第"</span> + tickets-- + <span class="string">"号票"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程-死锁"><a href="#多线程-死锁" class="headerlink" title="多线程-死锁"></a>多线程-死锁</h3><ul><li>多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁<ul><li>尽量不要嵌套使用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String s1 = <span class="string">"筷子左"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String s2 = <span class="string">"筷子右"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(s1) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">"...拿到"</span> + s1 + <span class="string">"等待"</span> + s2);</span><br><span class="line"><span class="keyword">synchronized</span>(s2) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">"...拿到"</span> + s2 + <span class="string">"开吃"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(s2) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">"...拿到"</span> + s2 + <span class="string">"等待"</span> + s1);</span><br><span class="line"><span class="keyword">synchronized</span>(s1) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">"...拿到"</span> + s1 + <span class="string">"开吃"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程-以前的线程安全的类回顾"><a href="#多线程-以前的线程安全的类回顾" class="headerlink" title="多线程-以前的线程安全的类回顾"></a>多线程-以前的线程安全的类回顾</h3><ul><li>A:回顾以前说过的线程安全问题<ul><li>看源码：Vector,StringBuffer,Hashtable,Collections.synchroinzed(xxx)</li><li>Vector是线程安全的,ArrayList是线程不安全的</li><li>StringBuffer是线程安全的,StringBuilder是线程不安全的</li><li>Hashtable是线程安全的,HashMap是线程不安全的</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;多线程-同步代码块&quot;&gt;&lt;a href=&quot;#多线程-同步代码块&quot; class=&quot;headerlink&quot; title=&quot;多线程-同步代码块&quot;&gt;&lt;/a&gt;多线程-同步代码块&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1.什么情况下需要同步&lt;ul&gt;
&lt;li&gt;当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.&lt;/li&gt;
&lt;li&gt;如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.同步代码块&lt;ul&gt;
&lt;li&gt;使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块&lt;/li&gt;
&lt;li&gt;多个同步代码块如果使用相同的锁对象, 那么他们就是同步的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程语言" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>java基础巩固之多线程概念和应用(4)</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/04/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0-4-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/04/java基础笔记-4-多线程/</id>
    <published>2014-12-03T16:30:00.000Z</published>
    <updated>2018-12-02T17:28:31.923Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程-多线程的引入"><a href="#多线程-多线程的引入" class="headerlink" title="多线程-多线程的引入"></a>多线程-多线程的引入</h3><ul><li>1.什么是线程<ul><li>线程是程序执行的一条路径, 一个进程中可以包含多条线程</li><li>多线程并发执行可以提高程序的效率, 可以同时完成多项工作</li></ul></li><li>2.多线程的应用场景<ul><li>红蜘蛛同时共享屏幕给多个电脑</li><li>迅雷开启多条线程一起下载</li><li>QQ同时和多个人一起视频</li><li>服务器同时处理多个客户端请求</li></ul></li></ul><a id="more"></a><h3 id="多线程-多线程并行和并发的区别"><a href="#多线程-多线程并行和并发的区别" class="headerlink" title="多线程-多线程并行和并发的区别"></a>多线程-多线程并行和并发的区别</h3><ul><li>并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)</li><li>并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。</li><li>比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。</li><li>如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。</li></ul><h3 id="多线程-Java程序运行原理和JVM的启动是多线程的吗"><a href="#多线程-Java程序运行原理和JVM的启动是多线程的吗" class="headerlink" title="多线程-Java程序运行原理和JVM的启动是多线程的吗"></a>多线程-Java程序运行原理和JVM的启动是多线程的吗</h3><ul><li><p>A:Java程序运行原理</p><ul><li>Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。</li></ul></li><li><p>B:JVM的启动是多线程的吗</p><ul><li>JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。</li></ul></li></ul><h3 id="多线程-多线程程序实现的方式1"><a href="#多线程-多线程程序实现的方式1" class="headerlink" title="多线程-多线程程序实现的方式1"></a>多线程-多线程程序实现的方式1</h3><ul><li>1.继承Thread<ul><li>定义类继承Thread</li><li>重写run方法</li><li>把新线程要做的事写在run方法中</li><li>创建线程对象</li><li>开启新线程, 内部会自动执行run方法</li><li></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread(); <span class="comment">// 4,创建自定义类的对象</span></span><br><span class="line">mt.start(); <span class="comment">// 5,开启线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"bb"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; <span class="comment">// 1,定义类继承Thread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 2,重写run方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123; <span class="comment">// 3,将要执行的代码,写在run方法中</span></span><br><span class="line">System.out.println(<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程-多线程程序实现的方式2"><a href="#多线程-多线程程序实现的方式2" class="headerlink" title="多线程-多线程程序实现的方式2"></a>多线程-多线程程序实现的方式2</h3><ul><li>2.实现Runnable<ul><li>定义类实现Runnable接口</li><li>实现run方法</li><li>把新线程要做的事写在run方法中</li><li>创建自定义的Runnable的子类对象</li><li>创建Thread对象, 传入Runnable</li><li>调用start()开启新线程, 内部会自动调用Runnable的run()方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_Runnable</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyRunnable mr = <span class="keyword">new</span> MyRunnable(); <span class="comment">// 4,创建自定义类对象</span></span><br><span class="line"><span class="comment">// Runnable target = new MyRunnable();</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(mr); <span class="comment">// 5,将其当作参数传递给Thread的构造函数</span></span><br><span class="line">t.start(); <span class="comment">// 6,开启线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"bb"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// 1,自定义类实现Runnable接口</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 2,重写run方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123; <span class="comment">// 3,将要执行的代码,写在run方法中</span></span><br><span class="line">System.out.println(<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程-实现Runnable的原理"><a href="#多线程-实现Runnable的原理" class="headerlink" title="多线程-实现Runnable的原理"></a>多线程-实现Runnable的原理</h3><ul><li>查看源码<ul><li>1,看Thread类的构造函数,传递了Runnable接口的引用 </li><li>2,通过init()方法找到传递的target给成员变量的target赋值</li><li>3,查看run方法,发现run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法</li></ul></li></ul><h3 id="多线程-两种方式的区别"><a href="#多线程-两种方式的区别" class="headerlink" title="多线程-两种方式的区别"></a>多线程-两种方式的区别</h3><ul><li><p>查看源码的区别:</p><ul><li>a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法</li><li>b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法</li></ul></li><li><p>继承Thread</p><ul><li>好处是:可以直接使用Thread类中的方法,代码简单</li><li>弊端是:如果已经有了父类,就不能用这种方法</li></ul></li><li>实现Runnable接口<ul><li>好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的</li><li>弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂<h3 id="多线程-匿名内部类实现线程的两种方式"><a href="#多线程-匿名内部类实现线程的两种方式" class="headerlink" title="多线程-匿名内部类实现线程的两种方式"></a>多线程-匿名内部类实现线程的两种方式</h3></li></ul></li><li>继承Thread类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread() &#123; <span class="comment">// 1,new 类()&#123;&#125;继承这个类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 2,重写run方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123; <span class="comment">// 3,将要执行的代码,写在run方法中</span></span><br><span class="line">System.out.println(<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="comment">// 实现Runnable接口</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 1,new 接口()&#123;&#125;实现这个接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 2,重写run方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123; <span class="comment">// 3,将要执行的代码,写在run方法中</span></span><br><span class="line">System.out.println(<span class="string">"bb"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程-获取名字和设置名字"><a href="#多线程-获取名字和设置名字" class="headerlink" title="多线程-获取名字和设置名字"></a>多线程-获取名字和设置名字</h3><ul><li>1.获取名字<ul><li>通过getName()方法获取线程对象的名字</li></ul></li><li>2.设置名字<ul><li>通过构造函数可以传入String类型的名字</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">"xxx"</span>) &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"....aaaaaaaaaaaaaaaaaaaaaaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">"yyy"</span>) &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"....bb"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过setName(String)方法可以设置线程对象的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"....aaaaaaaaaaaaaaaaaaaaaaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"....bb"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.setName(<span class="string">"芙蓉姐姐"</span>);</span><br><span class="line">t2.setName(<span class="string">"凤姐"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程-获取当前线程的对象"><a href="#多线程-获取当前线程的对象" class="headerlink" title="多线程-获取当前线程的对象"></a>多线程-获取当前线程的对象</h3><ul><li>Thread.currentThread(), 主线程也可以获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"...aaaaaaaaaaaaaaaaaaaaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"...bb"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">Thread.currentThread().setName(<span class="string">"我是主线程"</span>);<span class="comment">//获取主函数线程的引用,并改名字</span></span><br><span class="line">System.out.println(Thread.currentThread().getName());<span class="comment">//获取主函数线程的引用,并获取名字</span></span><br></pre></td></tr></table></figure><h3 id="多线程-休眠线程"><a href="#多线程-休眠线程" class="headerlink" title="多线程-休眠线程"></a>多线程-休眠线程</h3><ul><li>Thread.sleep(毫秒,纳秒), 控制当前线程休眠若干毫秒1秒= 1000毫秒 1秒 = 1000 <em> 1000 </em> 1000纳秒 1000000000</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">"...aaaaaaaaaaaaaaaaaaaaaa"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">"...bb"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h3 id="多线程-守护线程"><a href="#多线程-守护线程" class="headerlink" title="多线程-守护线程"></a>多线程-守护线程</h3><ul><li>setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">"...aaaaaaaaaaaaaaaaaaaaaa"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">"...bb"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t1.setDaemon(<span class="keyword">true</span>);<span class="comment">//将t1设置为守护线程</span></span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">### 多线程-加入线程</span><br><span class="line">* join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续</span><br><span class="line">* join(<span class="keyword">int</span>), 可以等待指定的毫秒之后继续</span><br><span class="line">* </span><br><span class="line"><span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">"...aaaaaaaaaaaaaaaaaaaaaa"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//t1.join();//插队,加入</span></span><br><span class="line">t1.join(<span class="number">30</span>);<span class="comment">//加入,有固定的时间,过了固定时间,继续交替执行</span></span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(getName() + <span class="string">"...bb"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><h3 id="多线程-礼让线程"><a href="#多线程-礼让线程" class="headerlink" title="多线程-礼让线程"></a>多线程-礼让线程</h3><ul><li>yield让出cpu</li></ul><h3 id="多线程-设置线程的优先级"><a href="#多线程-设置线程的优先级" class="headerlink" title="多线程-设置线程的优先级"></a>多线程-设置线程的优先级</h3><ul><li>setPriority()设置线程的优先级</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;多线程-多线程的引入&quot;&gt;&lt;a href=&quot;#多线程-多线程的引入&quot; class=&quot;headerlink&quot; title=&quot;多线程-多线程的引入&quot;&gt;&lt;/a&gt;多线程-多线程的引入&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1.什么是线程&lt;ul&gt;
&lt;li&gt;线程是程序执行的一条路径, 一个进程中可以包含多条线程&lt;/li&gt;
&lt;li&gt;多线程并发执行可以提高程序的效率, 可以同时完成多项工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.多线程的应用场景&lt;ul&gt;
&lt;li&gt;红蜘蛛同时共享屏幕给多个电脑&lt;/li&gt;
&lt;li&gt;迅雷开启多条线程一起下载&lt;/li&gt;
&lt;li&gt;QQ同时和多个人一起视频&lt;/li&gt;
&lt;li&gt;服务器同时处理多个客户端请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程语言" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="多线程" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础巩固之设计模式(3)</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/03/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/03/Java基础巩固之设计模式-3/</id>
    <published>2014-12-03T15:59:00.000Z</published>
    <updated>2018-12-02T17:29:03.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式-模版-Template-设计模式概述和使用"><a href="#设计模式-模版-Template-设计模式概述和使用" class="headerlink" title="设计模式-模版(Template)设计模式概述和使用"></a>设计模式-模版(Template)设计模式概述和使用</h3><ul><li>A:模版设计模式概述<ul><li>模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现</li></ul></li><li>B:优点和缺点<ul><li>a:优点<ul><li>使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求</li></ul></li><li>b:缺点<ul><li>如果算法骨架有修改的话，则需要修改抽象类</li></ul></li></ul></li></ul><a id="more"></a><p>1,装饰<br>2,单例</p><h3 id="多线程-单例"><a href="#多线程-单例" class="headerlink" title="多线程-单例"></a>多线程-单例</h3><ul><li><p>单例设计模式：保证类在内存中只有一个对象。</p></li><li><p>如何保证类在内存中只有一个对象呢？</p><ul><li>(1)控制类的创建，不让其他类来创建本类的对象。private</li><li>(2)在本类中定义一个本类的对象。Singleton s;</li><li>(3)提供公共的访问方式。  public static Singleton getInstance(){return s}<!-- more --></li></ul></li><li>单例写法两种：<ul><li>(1)饿汉式 开发用这种方式。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">//1,私有构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//2,创建本类对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="comment">//3,对外提供公共的访问方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"11111111111"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(2)懒汉式 面试写这种方式。多线程的问题？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式,单例的延迟加载模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">//1,私有构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//2,声明一个本类的引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line"><span class="comment">//3,对外提供公共的访问方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">//线程1,线程2</span></span><br><span class="line">s = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"11111111111"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(3)第三种格式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton s = <span class="keyword">new</span> Singleton();<span class="comment">//final是最终的意思,被final修饰的变量不可以被更改</span></span><br><span class="line">&#125;</span><br><span class="line">###25.02_多线程(Runtime类)</span><br><span class="line">* Runtime类是一个单例类</span><br><span class="line">* </span><br><span class="line">Runtime r = Runtime.getRuntime();</span><br><span class="line"><span class="comment">//r.exec("shutdown -s -t 300");//300秒后关机</span></span><br><span class="line">r.exec(<span class="string">"shutdown -a"</span>);<span class="comment">//取消关机</span></span><br></pre></td></tr></table></figure></li></ul><p>3,简单工厂<br>4,工厂方法</p><h3 id="设计模式-工厂方法模式的概述和使用"><a href="#设计模式-工厂方法模式的概述和使用" class="headerlink" title="设计模式-工厂方法模式的概述和使用"></a>设计模式-工厂方法模式的概述和使用</h3><ul><li>A:工厂方法模式概述<ul><li>工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</li></ul></li><li>B:优点<ul><li>客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性</li></ul></li><li>C:缺点<ul><li>需要额外的编写代码，增加了工作量</li></ul></li><li>D:案例演示</li><li><pre><code>动物抽象类：public abstract Animal { public abstract void eat(); }工厂接口：public interface Factory {public abstract Animal createAnimal();}具体狗类：public class Dog extends Animal {}具体猫类：public class Cat extends Animal {}开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。狗工厂：public class DogFactory implements Factory {    public Animal createAnimal() {…}        }猫工厂：public class CatFactory implements Factory {    public Animal createAnimal() {…}        }  </code></pre></li></ul><p>5,适配器<br>6,模版</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;设计模式-模版-Template-设计模式概述和使用&quot;&gt;&lt;a href=&quot;#设计模式-模版-Template-设计模式概述和使用&quot; class=&quot;headerlink&quot; title=&quot;设计模式-模版(Template)设计模式概述和使用&quot;&gt;&lt;/a&gt;设计模式-模版(Template)设计模式概述和使用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:模版设计模式概述&lt;ul&gt;
&lt;li&gt;模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:优点和缺点&lt;ul&gt;
&lt;li&gt;a:优点&lt;ul&gt;
&lt;li&gt;使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;b:缺点&lt;ul&gt;
&lt;li&gt;如果算法骨架有修改的话，则需要修改抽象类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程语言" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JAVA" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>java基础巩固之动态代理(2)</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/03/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-2/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/03/Java基础巩固之动态代理-2/</id>
    <published>2014-12-03T15:53:00.000Z</published>
    <updated>2018-12-03T03:29:38.351Z</updated>
    
    <content type="html"><![CDATA[<p>1.代理模式<br>代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.<br>这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法</p><p>举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子<br><img src="../images/logo.png" alt="Alt text"><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.代理模式&lt;br&gt;代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.&lt;br&gt;这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法&lt;/p&gt;
&lt;p&gt;举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子&lt;br&gt;&lt;img src=&quot;../images/logo.png&quot; alt=&quot;Alt text&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JAVA" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>java基础巩固之反射(1)</title>
    <link href="github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/02/Untitled/"/>
    <id>github.com:ChinaArJun/ChinaArJun.github.io.git/2014/12/02/Untitled/</id>
    <published>2014-12-02T15:20:00.000Z</published>
    <updated>2018-12-03T02:37:24.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反射-类的加载概述和加载时机"><a href="#反射-类的加载概述和加载时机" class="headerlink" title="反射-类的加载概述和加载时机"></a>反射-类的加载概述和加载时机</h3><ul><li><p>A:类的加载概述</p><ul><li>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。</li><li>加载 <ul><li>就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。</li></ul></li><li><p>连接</p><ul><li>验证 是否有正确的内部结构，并和其他类协调一致</li><li>准备 负责为类的静态成员分配内存，并设置默认初始化值</li><li>解析 将类的二进制数据中的符号引用替换为直接引用</li></ul></li><li><p>初始化 就是我们以前讲过的初始化步骤</p></li></ul></li></ul><a id="more"></a><ul><li>B:加载时机<ul><li>创建类的实例</li><li>访问类的静态变量，或者为静态变量赋值</li><li>调用类的静态方法</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li></ul></li></ul><p>###27.02_反射(类加载器的概述和分类)</p><ul><li>A:类加载器的概述<ul><li>负责将.class文件加载到内存中，并为之生成对应的Class对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。</li></ul></li><li>B:类加载器的分类<ul><li>Bootstrap ClassLoader 根类加载器</li><li>Extension ClassLoader 扩展类加载器</li><li>Sysetm ClassLoader 系统类加载器</li></ul></li><li>C:类加载器的作用<ul><li>Bootstrap ClassLoader 根类加载器<ul><li>也被称为引导类加载器，负责Java核心类的加载</li><li>比如System,String等。在JDK中JRE的lib目录下rt.jar文件中</li></ul></li><li>Extension ClassLoader 扩展类加载器<ul><li>负责JRE的扩展目录中jar包的加载。</li><li>在JDK中JRE的lib目录下ext目录</li></ul></li><li>Sysetm ClassLoader 系统类加载器<ul><li>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径</li></ul></li></ul></li></ul><p>###27.03_反射(反射概述)</p><ul><li><p>A:反射概述</p><ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</li><li>对于任意一个对象，都能够调用它的任意一个方法和属性；</li><li>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li><li>要想解剖一个类,必须先要获取到该类的字节码文件对象。</li><li>而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。</li></ul></li><li><p>B:三种方式</p><ul><li>a:Object类的getClass()方法,判断两个对象是否是同一个字节码文件</li><li>b:静态属性class,锁对象</li><li>c:Class类中静态方法forName(),读取配置文件</li></ul></li><li>C:案例演示<ul><li>获取class文件对象的三种方式</li></ul></li></ul><h3 id="反射-Class-forName-读取配置文件举例"><a href="#反射-Class-forName-读取配置文件举例" class="headerlink" title="反射-Class.forName()读取配置文件举例"></a>反射-Class.forName()读取配置文件举例</h3><ul><li>榨汁机(Juicer)榨汁的案例</li><li>分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_Reflect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 榨汁机(Juicer)榨汁的案例</span></span><br><span class="line"><span class="comment"> * 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">/*Juicer j = new Juicer();</span></span><br><span class="line"><span class="comment">//j.run(new Apple());</span></span><br><span class="line"><span class="comment">j.run(new Orange());*/</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"config.properties"</span>));<span class="comment">//创建输入流对象,关联配置文件</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(br.readLine());<span class="comment">//读取配置文件一行内容,获取该类的字节码对象</span></span><br><span class="line">Fruit f = (Fruit) clazz.newInstance();<span class="comment">//通过字节码对象创建实例对象</span></span><br><span class="line">Juicer j = <span class="keyword">new</span> Juicer();</span><br><span class="line">j.run(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">squeeze</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">squeeze</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"榨出一杯苹果汁儿"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">squeeze</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"榨出一杯桔子汁儿"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Juicer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Fruit f)</span> </span>&#123;</span><br><span class="line">f.squeeze();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射-通过反射获取带参构造方法并使用"><a href="#反射-通过反射获取带参构造方法并使用" class="headerlink" title="反射-通过反射获取带参构造方法并使用"></a>反射-通过反射获取带参构造方法并使用</h3><ul><li>Constructor<ul><li>Class类的newInstance()方法是使用该类无参的构造函数创建对象, 如果一个类没有无参的构造函数, 就不能这样创建了,可以调用Class类的getConstructor(String.class,int.class)方法获取一个指定的构造函数然后再调用Constructor类的newInstance(“张三”,20)方法创建对象</li></ul></li></ul><h3 id="反射-通过反射获取成员变量并使用"><a href="#反射-通过反射获取成员变量并使用" class="headerlink" title="反射-通过反射获取成员变量并使用"></a>反射-通过反射获取成员变量并使用</h3><ul><li>Field<ul><li>Class.getField(String)方法可以获取类中的指定字段(可见的), 如果是私有的可以用getDeclaedField(“name”)方法获取,通过set(obj, “李四”)方法可以设置指定对象上该字段的值, 如果是私有的需要先调用setAccessible(true)设置访问权限,用获取的指定的字段调用get(obj)可以获取指定对象中该字段的值</li></ul></li></ul><h3 id="反射-通过反射获取方法并使用"><a href="#反射-通过反射获取方法并使用" class="headerlink" title="反射-通过反射获取方法并使用"></a>反射-通过反射获取方法并使用</h3><ul><li>Method<ul><li>Class.getMethod(String, Class…) 和 Class.getDeclaredMethod(String, Class…)方法可以获取类中的指定方法,调用invoke(Object, Object…)可以调用该方法,Class.getMethod(“eat”) invoke(obj) Class.getMethod(“eat”,int.class) invoke(obj,10)</li></ul></li></ul><h3 id="反射-通过反射越过泛型检查"><a href="#反射-通过反射越过泛型检查" class="headerlink" title="反射-通过反射越过泛型检查"></a>反射-通过反射越过泛型检查</h3><ul><li>A:案例演示<ul><li>ArrayList<integer>的一个对象，在这个集合中添加一个字符串数据，如何实现呢？</integer></li></ul></li></ul><h3 id="反射-通过反射写一个通用的设置某个对象的某个属性为指定的值"><a href="#反射-通过反射写一个通用的设置某个对象的某个属性为指定的值" class="headerlink" title="反射-通过反射写一个通用的设置某个对象的某个属性为指定的值"></a>反射-通过反射写一个通用的设置某个对象的某个属性为指定的值</h3><ul><li>public void setProperty(Object obj, String propertyName, Object value){}，此方法可将obj对象中名为propertyName的属性的值设置为value。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;反射-类的加载概述和加载时机&quot;&gt;&lt;a href=&quot;#反射-类的加载概述和加载时机&quot; class=&quot;headerlink&quot; title=&quot;反射-类的加载概述和加载时机&quot;&gt;&lt;/a&gt;反射-类的加载概述和加载时机&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A:类的加载概述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。&lt;/li&gt;
&lt;li&gt;加载 &lt;ul&gt;
&lt;li&gt;就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证 是否有正确的内部结构，并和其他类协调一致&lt;/li&gt;
&lt;li&gt;准备 负责为类的静态成员分配内存，并设置默认初始化值&lt;/li&gt;
&lt;li&gt;解析 将类的二进制数据中的符号引用替换为直接引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始化 就是我们以前讲过的初始化步骤&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程语言" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JAVA" scheme="github.com:ChinaArJun/ChinaArJun.github.io.git/tags/JAVA/"/>
    
  </entry>
  
</feed>
